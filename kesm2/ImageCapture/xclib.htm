<!--								    -->
<!--	XCLIB Reference Manual	External    02-Oct-2005 	    -->
<!--								    -->
<!--	Copyright (C)  1998-2005  EPIX, Inc.  All rights reserved.  -->
<!--								    -->
<!--								    -->
<!DOCTYPE HTML PUBLIC "-//WSC//DTD HTML 3.2 FINAL//EN">
<HTML>
<HEAD>
<TITLE>XCLIB Reference Manual</TITLE>
<STYLE>
    BODY {
        font-family: times,serif;
        color: black;
        font-size: 12pt;
    }
    PRE {
        color: black;
        font-size: 9pt;
    }
    H1 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 20pt;
    }
    H2 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 18pt;
    }
    H3 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 16pt;
    }
    H4 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 14pt;
    }
    H5 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 12pt;
    }
    H6 {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 12pt;
    }
    EM {
        font-family: times,serif;
        color: black;
        font-size: 12pt;
        font-style=italics;
    }
    EM.Ep {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 10pt;
    }
    EM.Ss {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 14pt;
    }
    B.Fg {
        font-family: Helvetica,sans-serif,sansserif;
        color: black;
        font-size: 12pt;
    }
</STYLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<BR>
<BR>
<BR>
<BR>
<BR>
<HR>
<DIV ALIGN="center">
<FONT SIZE="+2" FACE="Helvetica,sans-serif,sansserif">
<B>REFERENCE MANUAL</B>
<BR>
<BR>
<B>XCLIB<SUP>tm</SUP></B>
<BR>
<B>Imaging Board 'C' Library</B>
<BR>
<BR>
<B>VERSI0N 2.2</B>
<BR>
<BR>
<B>For use with:</B>
<BR>
<B>PIXCI<SUP>&reg;</SUP> Imaging Boards</B>
<BR>
<B></B>
<BR>
<B></B>
<BR>
<BR>
Copyright &copy; 1998-2005 EPIX, Inc.
<HR>
</FONT>
</DIV>
<DIV ALIGN="left">
<BLOCKQUOTE>
No part of this document may be reproduced, transmitted, photocopied,
or translated into another language without the written consent of EPIX,&nbsp;Inc.
Information in this document is subject to change without obligation or notice.
EPIX,&nbsp;Inc. makes no warranty of any kind with regard to this document,
including, but not limited to, the implied warranties of
merchantability and fitness for a particular purpose.
EPIX,&nbsp;Inc. assumes no responsibility for any errors that
may appear in this document.
EPIX,&nbsp;Inc. reserves the right to make changes to the specifications
of hardware and software at any time, without obligation or notice.
<BR>
<BR>
4MIP, SVIP, XCIP, XCAP, 4MEG VIDEO, 1MEG VIDEO, SILICON VIDEO MUX,
QUICK SET VIDEO, 12-7MUX, IMAGE MEMORY EXPANSION,
COC40, and COC402 are trademarks of EPIX,&nbsp;Inc.
<BR>
<BR>
EPIX, SILICON VIDEO, and PIXCI are registered trademarks of EPIX,&nbsp;Inc.
<BR>
<BR>
Other brand, product, and company names are trademarks or
registered trademarks of their respective owners.
<BR>
<BR>
Printing: 27-Apr-2006
</BLOCKQUOTE>
<HR SIZE="3">
<H1>Table of Contents</H1>
<UL TYPE="circle">
<LI>
<A HREF="#1.  Installation, Configuration, and Usage &mdash; Compile Time"CLASS="TOC">1.  Installation, Configuration, and Usage &mdash; Compile Time</A>
<UL TYPE="circle">
<LI>
<A HREF="#1.1.  Introduction"CLASS="TOC">1.1.  Introduction</A>
<LI>
<A HREF="#1.2.  Library Installation"CLASS="TOC">1.2.  Library Installation</A>
<LI>
<A HREF="#1.3.  Compiling"CLASS="TOC">1.3.  Compiling</A>
<UL TYPE="circle">
<LI>
<A HREF="#1.3.1.  Stack"CLASS="TOC">1.3.1.  Stack</A>
<LI>
<A HREF="#1.3.2.  Heap"CLASS="TOC">1.3.2.  Heap</A>
<LI>
<A HREF="#1.3.3.  Memory Allocation Hooks"CLASS="TOC">1.3.3.  Memory Allocation Hooks</A>
</UL>
<LI>
<A HREF="#1.4.  Compile Time Inclusions"CLASS="TOC">1.4.  Compile Time Inclusions</A>
<LI>
<A HREF="#1.5.  Common Types and Concepts"CLASS="TOC">1.5.  Common Types and Concepts</A>
<UL TYPE="circle">
<LI>
<A HREF="#1.5.1.  Types"CLASS="TOC">1.5.1.  Types</A>
<LI>
<A HREF="#1.5.2.  Modifiers"CLASS="TOC">1.5.2.  Modifiers</A>
<LI>
<A HREF="#1.5.3.  Call Back Types"CLASS="TOC">1.5.3.  Call Back Types</A>
<UL TYPE="circle">
<LI>
<A HREF="#1.5.3.1.  The pxabortfunc_t"CLASS="TOC">1.5.3.1.  The pxabortfunc_t</A>
</UL>
<LI>
<A HREF="#1.5.4.  Usage Assumptions"CLASS="TOC">1.5.4.  Usage Assumptions</A>
<LI>
<A HREF="#1.5.5.  On Frame Buffers and Memory"CLASS="TOC">1.5.5.  On Frame Buffers and Memory</A>
<LI>
<A HREF="#1.5.6.  On Snap Semantics"CLASS="TOC">1.5.6.  On Snap Semantics</A>
<LI>
<A HREF="#1.5.7.  On Imaging Boards with Multiple Functional Units"CLASS="TOC">1.5.7.  On Imaging Boards with Multiple Functional Units</A>
<LI>
<A HREF="#1.5.8.  On Multiple Imaging Boards"CLASS="TOC">1.5.8.  On Multiple Imaging Boards</A>
<LI>
<A HREF="#1.5.9.  On Multiple Identical Imaging Boards"CLASS="TOC">1.5.9.  On Multiple Identical Imaging Boards</A>
<LI>
<A HREF="#1.5.10.  On Video Format Configuration"CLASS="TOC">1.5.10.  On Video Format Configuration</A>
<LI>
<A HREF="#1.5.11.  On Video State ID's"CLASS="TOC">1.5.11.  On Video State ID's</A>
<LI>
<A HREF="#1.5.12.  On Error Codes"CLASS="TOC">1.5.12.  On Error Codes</A>
<LI>
<A HREF="#1.5.13.  On Structures and Signatures"CLASS="TOC">1.5.13.  On Structures and Signatures</A>
</UL>
<LI>
<A HREF="#1.6.  Common Structures"CLASS="TOC">1.6.  Common Structures</A>
<UL TYPE="circle">
<LI>
<A HREF="#1.6.1.  Coordinates, Images, and Image Window Structures"CLASS="TOC">1.6.1.  Coordinates, Images, and Image Window Structures</A>
<LI>
<A HREF="#1.6.2.  Imaging Board, Driver, and Video Format Configuration Structures"CLASS="TOC">1.6.2.  Imaging Board, Driver, and Video Format Configuration Structures</A>
</UL>
</UL>
<LI>
<A HREF="#2.  Installation and Configuration &mdash; Run Time"CLASS="TOC">2.  Installation and Configuration &mdash; Run Time</A>
<UL TYPE="circle">
<LI>
<A HREF="#2.1.  Driver Configuration Parameters"CLASS="TOC">2.1.  Driver Configuration Parameters</A>
<LI>
<A HREF="#2.2.  Windows 95/98/ME Environment"CLASS="TOC">2.2.  Windows 95/98/ME Environment</A>
<LI>
<A HREF="#2.3.  Windows NT/2000/XP/Server2003 Environment"CLASS="TOC">2.3.  Windows NT/2000/XP/Server2003 Environment</A>
<LI>
<A HREF="#2.4.  Tenberry DOS4GW DOS Extender Environment"CLASS="TOC">2.4.  Tenberry DOS4GW DOS Extender Environment</A>
<LI>
<A HREF="#2.5.  Linux &amp; Intel 80x86 Environment"CLASS="TOC">2.5.  Linux &amp; Intel 80x86 Environment</A>
</UL>
<LI>
<A HREF="#3.  SCF Style Interface"CLASS="TOC">3.  SCF Style Interface</A>
<UL TYPE="circle">
<LI>
<A HREF="#Buffer's Capture Field Count   ---   pxd_buffersFieldCount"CLASS="TOC">Buffer's Capture Field Count   ---   pxd_buffersFieldCount</A>
<LI>
<A HREF="#Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn"CLASS="TOC">Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn</A>
<LI>
<A HREF="#Buffer's Capture System Time   ---   pxd_buffersSysTicks"CLASS="TOC">Buffer's Capture System Time   ---   pxd_buffersSysTicks</A>
<LI>
<A HREF="#Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer"CLASS="TOC">Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer</A>
<LI>
<A HREF="#Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount"CLASS="TOC">Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount</A>
<LI>
<A HREF="#Last Captured Buffer: System Time   ---   pxd_capturedSysTicks"CLASS="TOC">Last Captured Buffer: System Time   ---   pxd_capturedSysTicks</A>
<LI>
<A HREF="#Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage"CLASS="TOC">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage</A>
<LI>
<A HREF="#Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3"CLASS="TOC">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3</A>
<LI>
<A HREF="#Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage"CLASS="TOC">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage</A>
<LI>
<A HREF="#Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3"CLASS="TOC">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3</A>
<LI>
<A HREF="#Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree"CLASS="TOC">Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree</A>
<LI>
<A HREF="#Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free"CLASS="TOC">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free</A>
<LI>
<A HREF="#Video Snap and Wait   ---   pxd_doSnap"CLASS="TOC">Video Snap and Wait   ---   pxd_doSnap</A>
<LI>
<A HREF="#Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate"CLASS="TOC">Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate</A>
<LI>
<A HREF="#Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose"CLASS="TOC">Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose</A>
<LI>
<A HREF="#Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"CLASS="TOC">Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</A>
<LI>
<A HREF="#Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose"CLASS="TOC">Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose</A>
<LI>
<A HREF="#Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"CLASS="TOC">Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</A>
<LI>
<A HREF="#Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"CLASS="TOC">Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</A>
<LI>
<A HREF="#DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate"CLASS="TOC">DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate</A>
<LI>
<A HREF="#DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose"CLASS="TOC">DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose</A>
<LI>
<A HREF="#DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"CLASS="TOC">DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</A>
<LI>
<A HREF="#DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose"CLASS="TOC">DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose</A>
<LI>
<A HREF="#DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"CLASS="TOC">DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</A>
<LI>
<A HREF="#DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"CLASS="TOC">DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</A>
<LI>
<A HREF="#Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate"CLASS="TOC">Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate</A>
<LI>
<A HREF="#Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose"CLASS="TOC">Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose</A>
<LI>
<A HREF="#Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"CLASS="TOC">Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</A>
<LI>
<A HREF="#Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose"CLASS="TOC">Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose</A>
<LI>
<A HREF="#Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"CLASS="TOC">Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</A>
<LI>
<A HREF="#Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"CLASS="TOC">Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</A>
<LI>
<A HREF="#General Purpose Input Signal: Sense   ---   pxd_getGPIn"CLASS="TOC">General Purpose Input Signal: Sense   ---   pxd_getGPIn</A>
<LI>
<A HREF="#General Purpose Input Signal: Reset   ---   pxd_setGPIn"CLASS="TOC">General Purpose Input Signal: Reset   ---   pxd_setGPIn</A>
<LI>
<A HREF="#General Purpose Output Signal: Set   ---   pxd_setGPOut"CLASS="TOC">General Purpose Output Signal: Set   ---   pxd_setGPOut</A>
<LI>
<A HREF="#General Purpose Output Signal: Get   ---   pxd_getGPOut"CLASS="TOC">General Purpose Output Signal: Get   ---   pxd_getGPOut</A>
<LI>
<A HREF="#General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger"CLASS="TOC">General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger</A>
<LI>
<A HREF="#Video Snap   ---   pxd_goSnap"CLASS="TOC">Video Snap   ---   pxd_goSnap</A>
<LI>
<A HREF="#Video Snap Pair   ---   pxd_goSnapPair"CLASS="TOC">Video Snap Pair   ---   pxd_goSnapPair</A>
<LI>
<A HREF="#Video Live   ---   pxd_goLive"CLASS="TOC">Video Live   ---   pxd_goLive</A>
<LI>
<A HREF="#Video Live Pair Alternate   ---   pxd_goLivePair"CLASS="TOC">Video Live Pair Alternate   ---   pxd_goLivePair</A>
<LI>
<A HREF="#Video Live Sequence   ---   pxd_goLiveSeq"CLASS="TOC">Video Live Sequence   ---   pxd_goLiveSeq</A>
<LI>
<A HREF="#Video UnLive   ---   pxd_goUnLive"CLASS="TOC">Video UnLive   ---   pxd_goUnLive</A>
<LI>
<A HREF="#Video Abort   ---   pxd_goAbortLive"CLASS="TOC">Video Abort   ---   pxd_goAbortLive</A>
<LI>
<A HREF="#Video Live Trigger   ---   pxd_goLiveTrig"CLASS="TOC">Video Live Trigger   ---   pxd_goLiveTrig</A>
<LI>
<A HREF="#Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig"CLASS="TOC">Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig</A>
<LI>
<A HREF="#Check if Video Initiated   ---   pxd_goneLive"CLASS="TOC">Check if Video Initiated   ---   pxd_goneLive</A>
<LI>
<A HREF="#Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio"CLASS="TOC">Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio</A>
<LI>
<A HREF="#Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim"CLASS="TOC">Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim</A>
<LI>
<A HREF="#Get Frame Buffer Image Color Components   ---   pxd_imageCdim"CLASS="TOC">Get Frame Buffer Image Color Components   ---   pxd_imageCdim</A>
<LI>
<A HREF="#Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim"CLASS="TOC">Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim</A>
<LI>
<A HREF="#Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim"CLASS="TOC">Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim</A>
<LI>
<A HREF="#Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim"CLASS="TOC">Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim</A>
<LI>
<A HREF="#Get Frame Buffer Image Count   ---   pxd_imageZdim"CLASS="TOC">Get Frame Buffer Image Count   ---   pxd_imageZdim</A>
<LI>
<A HREF="#Get Imaging Board Driver ID   ---   pxd_infoDriverId"CLASS="TOC">Get Imaging Board Driver ID   ---   pxd_infoDriverId</A>
<LI>
<A HREF="#Get Imaging Board Include Files ID   ---   pxd_infoIncludeId"CLASS="TOC">Get Imaging Board Include Files ID   ---   pxd_infoIncludeId</A>
<LI>
<A HREF="#Get Imaging Board Library ID   ---   pxd_infoLibraryId"CLASS="TOC">Get Imaging Board Library ID   ---   pxd_infoLibraryId</A>
<LI>
<A HREF="#Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize"CLASS="TOC">Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize</A>
<LI>
<A HREF="#Get Imaging Board's Model   ---   pxd_infoModel"CLASS="TOC">Get Imaging Board's Model   ---   pxd_infoModel</A>
<LI>
<A HREF="#Get Imaging Board's Submodel   ---   pxd_infoSubmodel"CLASS="TOC">Get Imaging Board's Submodel   ---   pxd_infoSubmodel</A>
<LI>
<A HREF="#Get Imaging Board Unit Count   ---   pxd_infoUnits"CLASS="TOC">Get Imaging Board Unit Count   ---   pxd_infoUnits</A>
<LI>
<A HREF="#Load Image: BMP Format   ---   pxd_loadBmp"CLASS="TOC">Load Image: BMP Format   ---   pxd_loadBmp</A>
<LI>
<A HREF="#Load Image: TIFF Format   ---   pxd_loadTiff"CLASS="TOC">Load Image: TIFF Format   ---   pxd_loadTiff</A>
<LI>
<A HREF="#Save Image: BMP Format   ---   pxd_saveBmp"CLASS="TOC">Save Image: BMP Format   ---   pxd_saveBmp</A>
<LI>
<A HREF="#Save Image: PCX Format   ---   pxd_savePcx"CLASS="TOC">Save Image: PCX Format   ---   pxd_savePcx</A>
<LI>
<A HREF="#Save Image: TARGA Format   ---   pxd_saveTga"CLASS="TOC">Save Image: TARGA Format   ---   pxd_saveTga</A>
<LI>
<A HREF="#Save Image: TIFF Format   ---   pxd_saveTiff"CLASS="TOC">Save Image: TIFF Format   ---   pxd_saveTiff</A>
<LI>
<A HREF="#Load Frame Buffers   ---   pxd_loadRawBuffers"CLASS="TOC">Load Frame Buffers   ---   pxd_loadRawBuffers</A>
<LI>
<A HREF="#Save Frame Buffers   ---   pxd_saveRawBuffers"CLASS="TOC">Save Frame Buffers   ---   pxd_saveRawBuffers</A>
<LI>
<A HREF="#Errors: Translate Error Code to String   ---   pxd_mesgErrorCode"CLASS="TOC">Errors: Translate Error Code to String   ---   pxd_mesgErrorCode</A>
<LI>
<A HREF="#Errors: Check &amp; Report Faults   ---   pxd_mesgFault"CLASS="TOC">Errors: Check &amp; Report Faults   ---   pxd_mesgFault</A>
<LI>
<A HREF="#Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText"CLASS="TOC">Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText</A>
<LI>
<A HREF="#PIXCI&reg; Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen"CLASS="TOC">PIXCI&reg; Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen</A>
<LI>
<A HREF="#PIXCI&reg; Imaging Board: Close   ---   pxd_PIXCIclose"CLASS="TOC">PIXCI&reg; Imaging Board: Close   ---   pxd_PIXCIclose</A>
<LI>
<A HREF="#Read Pixel Values as Unsigned Char   ---   pxd_readuchar"CLASS="TOC">Read Pixel Values as Unsigned Char   ---   pxd_readuchar</A>
<LI>
<A HREF="#Read Pixel Values as Unsigned Short   ---   pxd_readushort"CLASS="TOC">Read Pixel Values as Unsigned Short   ---   pxd_readushort</A>
<LI>
<A HREF="#Write Pixel Values as Unsigned Char   ---   pxd_writeuchar"CLASS="TOC">Write Pixel Values as Unsigned Char   ---   pxd_writeuchar</A>
<LI>
<A HREF="#Write Pixel Values as Unsigned Short   ---   pxd_writeushort"CLASS="TOC">Write Pixel Values as Unsigned Short   ---   pxd_writeushort</A>
<LI>
<A HREF="#Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate"CLASS="TOC">Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate</A>
<LI>
<A HREF="#Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree"CLASS="TOC">Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree</A>
<LI>
<A HREF="#Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit"CLASS="TOC">Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit</A>
<LI>
<A HREF="#Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone"CLASS="TOC">Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone</A>
<LI>
<A HREF="#Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive"CLASS="TOC">Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive</A>
<LI>
<A HREF="#Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive"CLASS="TOC">Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive</A>
<LI>
<A HREF="#Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits"CLASS="TOC">Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits</A>
<LI>
<A HREF="#Serial Port: Set Configuration   ---   pxd_serialConfigure"CLASS="TOC">Serial Port: Set Configuration   ---   pxd_serialConfigure</A>
<LI>
<A HREF="#Serial Port: Read   ---   pxd_serialRead"CLASS="TOC">Serial Port: Read   ---   pxd_serialRead</A>
<LI>
<A HREF="#Serial Port: Write   ---   pxd_serialWrite"CLASS="TOC">Serial Port: Write   ---   pxd_serialWrite</A>
<LI>
<A HREF="#Camera Link Serial: Initialize   ---   clSerialInit"CLASS="TOC">Camera Link Serial: Initialize   ---   clSerialInit</A>
<LI>
<A HREF="#Camera Link Serial: Close   ---   clSerialClose"CLASS="TOC">Camera Link Serial: Close   ---   clSerialClose</A>
<LI>
<A HREF="#Camera Link Serial: Read   ---   clSerialRead"CLASS="TOC">Camera Link Serial: Read   ---   clSerialRead</A>
<LI>
<A HREF="#Camera Link Serial: Write   ---   clSerialWrite"CLASS="TOC">Camera Link Serial: Write   ---   clSerialWrite</A>
<LI>
<A HREF="#Camera Link Serial: Read Available   ---   clGetNumBytesAvail"CLASS="TOC">Camera Link Serial: Read Available   ---   clGetNumBytesAvail</A>
<LI>
<A HREF="#Camera Link Serial: Read Flush   ---   clFlushPort"CLASS="TOC">Camera Link Serial: Read Flush   ---   clFlushPort</A>
<LI>
<A HREF="#Camera Link Serial: Error Text   ---   clGetErrorText"CLASS="TOC">Camera Link Serial: Error Text   ---   clGetErrorText</A>
<LI>
<A HREF="#Camera Link Serial: Ports   ---   clGetNumSerialPorts"CLASS="TOC">Camera Link Serial: Ports   ---   clGetNumSerialPorts</A>
<LI>
<A HREF="#Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier"CLASS="TOC">Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier</A>
<LI>
<A HREF="#Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo"CLASS="TOC">Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo</A>
<LI>
<A HREF="#Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates"CLASS="TOC">Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates</A>
<LI>
<A HREF="#Camera Link Serial: Set Baud Rate   ---   clSetBaudRate"CLASS="TOC">Camera Link Serial: Set Baud Rate   ---   clSetBaudRate</A>
<LI>
<A HREF="#Set EXSYNC and PRIN Values   ---   pxd_setExsyncPrin"CLASS="TOC">Set EXSYNC and PRIN Values   ---   pxd_setExsyncPrin</A>
<LI>
<A HREF="#Get EXSYNC Value   ---   pxd_getExsync"CLASS="TOC">Get EXSYNC Value   ---   pxd_getExsync</A>
<LI>
<A HREF="#Get PRIN Value   ---   pxd_getPrin"CLASS="TOC">Get PRIN Value   ---   pxd_getPrin</A>
<LI>
<A HREF="#Set EXSYNC and PRINC Modes   ---   pxd_setExsyncPrincMode"CLASS="TOC">Set EXSYNC and PRINC Modes   ---   pxd_setExsyncPrincMode</A>
<LI>
<A HREF="#Get EXSYNC Mode   ---   pxd_getExsyncMode"CLASS="TOC">Get EXSYNC Mode   ---   pxd_getExsyncMode</A>
<LI>
<A HREF="#Get PRINC Mode   ---   pxd_getPrincMode"CLASS="TOC">Get PRINC Mode   ---   pxd_getPrincMode</A>
<LI>
<A HREF="#Set Video Input Multiplexer   ---   pxd_setVidMux"CLASS="TOC">Set Video Input Multiplexer   ---   pxd_setVidMux</A>
<LI>
<A HREF="#Set Video Contrast and Brightness   ---   pxd_setContrastBrightness"CLASS="TOC">Set Video Contrast and Brightness   ---   pxd_setContrastBrightness</A>
<LI>
<A HREF="#Set Video Hue and Saturation   ---   pxd_setHueSaturation"CLASS="TOC">Set Video Hue and Saturation   ---   pxd_setHueSaturation</A>
<LI>
<A HREF="#Get Video Input Multiplexer   ---   pxd_getVidMux"CLASS="TOC">Get Video Input Multiplexer   ---   pxd_getVidMux</A>
<LI>
<A HREF="#Get Video Contrast   ---   pxd_getContrast"CLASS="TOC">Get Video Contrast   ---   pxd_getContrast</A>
<LI>
<A HREF="#Get Video Brightness   ---   pxd_getBrightness"CLASS="TOC">Get Video Brightness   ---   pxd_getBrightness</A>
<LI>
<A HREF="#Get Video Hue   ---   pxd_getHue"CLASS="TOC">Get Video Hue   ---   pxd_getHue</A>
<LI>
<A HREF="#Get Video U Saturation   ---   pxd_getUGain"CLASS="TOC">Get Video U Saturation   ---   pxd_getUGain</A>
<LI>
<A HREF="#Get Video V Saturation   ---   pxd_getVGain"CLASS="TOC">Get Video V Saturation   ---   pxd_getVGain</A>
<LI>
<A HREF="#Set Bright White Balance   ---   pxd_setImageBrightBalance"CLASS="TOC">Set Bright White Balance   ---   pxd_setImageBrightBalance</A>
<LI>
<A HREF="#Set Dark White Balance   ---   pxd_setImageDarkBalance"CLASS="TOC">Set Dark White Balance   ---   pxd_setImageDarkBalance</A>
<LI>
<A HREF="#Get Video Field Count   ---   pxd_videoFieldCount"CLASS="TOC">Get Video Field Count   ---   pxd_videoFieldCount</A>
<LI>
<A HREF="#Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame"CLASS="TOC">Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame</A>
<LI>
<A HREF="#Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded"CLASS="TOC">Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded</A>
<LI>
<A HREF="#Set SV2112 Exposure and Gain   ---   pxd_SV2112_setExposureAndGain"CLASS="TOC">Set SV2112 Exposure and Gain   ---   pxd_SV2112_setExposureAndGain</A>
<LI>
<A HREF="#Get SV2112 Exposure   ---   pxd_SV2112_getExposure"CLASS="TOC">Get SV2112 Exposure   ---   pxd_SV2112_getExposure</A>
<LI>
<A HREF="#Get SV2112 Gain   ---   pxd_SV2112_getGain"CLASS="TOC">Get SV2112 Gain   ---   pxd_SV2112_getGain</A>
<LI>
<A HREF="#Set SV2112 Resolution and Timing   ---   pxd_SV2112_setResolutionAndTiming"CLASS="TOC">Set SV2112 Resolution and Timing   ---   pxd_SV2112_setResolutionAndTiming</A>
<LI>
<A HREF="#Get SV2112 Decimation   ---   pxd_SV2112_getDecimation"CLASS="TOC">Get SV2112 Decimation   ---   pxd_SV2112_getDecimation</A>
<LI>
<A HREF="#Get SV2112 Aoi Top Edge   ---   pxd_SV2112_getAoiTop"CLASS="TOC">Get SV2112 Aoi Top Edge   ---   pxd_SV2112_getAoiTop</A>
<LI>
<A HREF="#Get SV2112 Aoi Left Edge   ---   pxd_SV2112_getAoiLeft"CLASS="TOC">Get SV2112 Aoi Left Edge   ---   pxd_SV2112_getAoiLeft</A>
<LI>
<A HREF="#Get SV2112 Pixel Clock Frequency   ---   pxd_SV2112_getPixelClock"CLASS="TOC">Get SV2112 Pixel Clock Frequency   ---   pxd_SV2112_getPixelClock</A>
<LI>
<A HREF="#Get SV2112 Scan Direction   ---   pxd_SV2112_getScanDirection"CLASS="TOC">Get SV2112 Scan Direction   ---   pxd_SV2112_getScanDirection</A>
<LI>
<A HREF="#Set SV2112 Video And Trigger Modes   ---   pxd_SV2112_setVideoAndTriggerMode"CLASS="TOC">Set SV2112 Video And Trigger Modes   ---   pxd_SV2112_setVideoAndTriggerMode</A>
<LI>
<A HREF="#Set SV2112 Controlled Exposure And Frame Rate   ---   pxd_SV2112_setCtrlExposureAndRate"CLASS="TOC">Set SV2112 Controlled Exposure And Frame Rate   ---   pxd_SV2112_setCtrlExposureAndRate</A>
<LI>
<A HREF="#Get SV2112 Video Mode   ---   pxd_SV2112_getVideoMode"CLASS="TOC">Get SV2112 Video Mode   ---   pxd_SV2112_getVideoMode</A>
<LI>
<A HREF="#Get SV2112 Controlled Video Mode   ---   pxd_SV2112_getCtrlVideoMode"CLASS="TOC">Get SV2112 Controlled Video Mode   ---   pxd_SV2112_getCtrlVideoMode</A>
<LI>
<A HREF="#Get SV2112 Controlled Trigger Mode   ---   pxd_SV2112_getCtrlTriggerMode"CLASS="TOC">Get SV2112 Controlled Trigger Mode   ---   pxd_SV2112_getCtrlTriggerMode</A>
<LI>
<A HREF="#Get SV2112 Controlled Frame Rate   ---   pxd_SV2112_getCtrlFrameRate"CLASS="TOC">Get SV2112 Controlled Frame Rate   ---   pxd_SV2112_getCtrlFrameRate</A>
<LI>
<A HREF="#Get SV2112 Controlled Exposure   ---   pxd_SV2112_getCtrlExposure"CLASS="TOC">Get SV2112 Controlled Exposure   ---   pxd_SV2112_getCtrlExposure</A>
<LI>
<A HREF="#Set SV1310 Exposure, Gain, and Offset   ---   pxd_SV1310_setExposureGainOffset"CLASS="TOC">Set SV1310 Exposure, Gain, and Offset   ---   pxd_SV1310_setExposureGainOffset</A>
<LI>
<A HREF="#Get SV1310 Exposure   ---   pxd_SV1310_getExposure"CLASS="TOC">Get SV1310 Exposure   ---   pxd_SV1310_getExposure</A>
<LI>
<A HREF="#Get SV1310 Gain   ---   pxd_SV1310_getGain"CLASS="TOC">Get SV1310 Gain   ---   pxd_SV1310_getGain</A>
<LI>
<A HREF="#Get SV1310 Offset   ---   pxd_SV1310_getOffset"CLASS="TOC">Get SV1310 Offset   ---   pxd_SV1310_getOffset</A>
<LI>
<A HREF="#Set SV1310 Color Specific Gain   ---   pxd_SV1310_setColorGain"CLASS="TOC">Set SV1310 Color Specific Gain   ---   pxd_SV1310_setColorGain</A>
<LI>
<A HREF="#Get SV1310 Color Specific Gain   ---   pxd_SV1310_getColorGain"CLASS="TOC">Get SV1310 Color Specific Gain   ---   pxd_SV1310_getColorGain</A>
<LI>
<A HREF="#Set SV1310 Resolution and Timing   ---   pxd_SV1310_setResolutionAndTiming"CLASS="TOC">Set SV1310 Resolution and Timing   ---   pxd_SV1310_setResolutionAndTiming</A>
<LI>
<A HREF="#Get SV1310 Subsample   ---   pxd_SV1310_getSubsample"CLASS="TOC">Get SV1310 Subsample   ---   pxd_SV1310_getSubsample</A>
<LI>
<A HREF="#Get SV1310 Aoi Top Edge   ---   pxd_SV1310_getAoiTop"CLASS="TOC">Get SV1310 Aoi Top Edge   ---   pxd_SV1310_getAoiTop</A>
<LI>
<A HREF="#Get SV1310 Aoi Left Edge   ---   pxd_SV1310_getAoiLeft"CLASS="TOC">Get SV1310 Aoi Left Edge   ---   pxd_SV1310_getAoiLeft</A>
<LI>
<A HREF="#Get SV1310 Pixel Clock Frequency   ---   pxd_SV1310_getPixelClock"CLASS="TOC">Get SV1310 Pixel Clock Frequency   ---   pxd_SV1310_getPixelClock</A>
<LI>
<A HREF="#Get SV1310 Readout Direction   ---   pxd_SV1310_getReadoutDirection"CLASS="TOC">Get SV1310 Readout Direction   ---   pxd_SV1310_getReadoutDirection</A>
<LI>
<A HREF="#Get SV1310 Frame Period   ---   pxd_SV1310_getFramePeriod"CLASS="TOC">Get SV1310 Frame Period   ---   pxd_SV1310_getFramePeriod</A>
<LI>
<A HREF="#Set SV1310 Video And Trigger Modes   ---   pxd_SV1310_setVideoAndTriggerMode"CLASS="TOC">Set SV1310 Video And Trigger Modes   ---   pxd_SV1310_setVideoAndTriggerMode</A>
<LI>
<A HREF="#Set SV1310 Controlled Frame Rate   ---   pxd_SV1310_setCtrlRate"CLASS="TOC">Set SV1310 Controlled Frame Rate   ---   pxd_SV1310_setCtrlRate</A>
<LI>
<A HREF="#Get SV1310 Video Mode   ---   pxd_SV1310_getVideoMode"CLASS="TOC">Get SV1310 Video Mode   ---   pxd_SV1310_getVideoMode</A>
<LI>
<A HREF="#Get SV1310 Controlled Video Mode   ---   pxd_SV1310_getCtrlVideoMode"CLASS="TOC">Get SV1310 Controlled Video Mode   ---   pxd_SV1310_getCtrlVideoMode</A>
<LI>
<A HREF="#Get SV1310 Controlled Trigger Mode   ---   pxd_SV1310_getCtrlTriggerMode"CLASS="TOC">Get SV1310 Controlled Trigger Mode   ---   pxd_SV1310_getCtrlTriggerMode</A>
<LI>
<A HREF="#Get SV1310 Controlled Frame Rate   ---   pxd_SV1310_getCtrlFrameRate"CLASS="TOC">Get SV1310 Controlled Frame Rate   ---   pxd_SV1310_getCtrlFrameRate</A>
<LI>
<A HREF="#Get SV1310 Controlled Exposure   ---   pxd_SV1310_getCtrlExposure"CLASS="TOC">Get SV1310 Controlled Exposure   ---   pxd_SV1310_getCtrlExposure</A>
<LI>
<A HREF="#Set SV1281 Exposure, Gain, and Offset   ---   pxd_SV1281_setExposureGainOffset"CLASS="TOC">Set SV1281 Exposure, Gain, and Offset   ---   pxd_SV1281_setExposureGainOffset</A>
<LI>
<A HREF="#Get SV1281 Exposure   ---   pxd_SV1281_getExposure"CLASS="TOC">Get SV1281 Exposure   ---   pxd_SV1281_getExposure</A>
<LI>
<A HREF="#Get SV1281 Gain   ---   pxd_SV1281_getGain"CLASS="TOC">Get SV1281 Gain   ---   pxd_SV1281_getGain</A>
<LI>
<A HREF="#Get SV1281 Offset   ---   pxd_SV1281_getOffset"CLASS="TOC">Get SV1281 Offset   ---   pxd_SV1281_getOffset</A>
<LI>
<A HREF="#Set SV1281 Resolution and Timing   ---   pxd_SV1281_setResolutionAndTiming"CLASS="TOC">Set SV1281 Resolution and Timing   ---   pxd_SV1281_setResolutionAndTiming</A>
<LI>
<A HREF="#Get SV1281 Aoi Top Edge   ---   pxd_SV1281_getAoiTop"CLASS="TOC">Get SV1281 Aoi Top Edge   ---   pxd_SV1281_getAoiTop</A>
<LI>
<A HREF="#Get SV1281 Aoi Left Edge   ---   pxd_SV1281_getAoiLeft"CLASS="TOC">Get SV1281 Aoi Left Edge   ---   pxd_SV1281_getAoiLeft</A>
<LI>
<A HREF="#Get SV1281 Pixel Clock Frequency   ---   pxd_SV1281_getPixelClock"CLASS="TOC">Get SV1281 Pixel Clock Frequency   ---   pxd_SV1281_getPixelClock</A>
<LI>
<A HREF="#Set SV1281 Video And Trigger Modes   ---   pxd_SV1281_setVideoAndTriggerMode"CLASS="TOC">Set SV1281 Video And Trigger Modes   ---   pxd_SV1281_setVideoAndTriggerMode</A>
<LI>
<A HREF="#Set SV1281 Controlled Frame Rate   ---   pxd_SV1281_setCtrlRate"CLASS="TOC">Set SV1281 Controlled Frame Rate   ---   pxd_SV1281_setCtrlRate</A>
<LI>
<A HREF="#Get SV1281 Video Mode   ---   pxd_SV1281_getVideoMode"CLASS="TOC">Get SV1281 Video Mode   ---   pxd_SV1281_getVideoMode</A>
<LI>
<A HREF="#Get SV1281 Controlled Video Mode   ---   pxd_SV1281_getCtrlVideoMode"CLASS="TOC">Get SV1281 Controlled Video Mode   ---   pxd_SV1281_getCtrlVideoMode</A>
<LI>
<A HREF="#Get SV1281 Controlled Trigger Mode   ---   pxd_SV1281_getCtrlTriggerMode"CLASS="TOC">Get SV1281 Controlled Trigger Mode   ---   pxd_SV1281_getCtrlTriggerMode</A>
<LI>
<A HREF="#Get SV1281 Controlled Frame Rate   ---   pxd_SV1281_getCtrlFrameRate"CLASS="TOC">Get SV1281 Controlled Frame Rate   ---   pxd_SV1281_getCtrlFrameRate</A>
<LI>
<A HREF="#Set SV9M001/SV9T001 Exposure and Gain   ---   pxd_SV9M001_setExposureAndGain"CLASS="TOC">Set SV9M001/SV9T001 Exposure and Gain   ---   pxd_SV9M001_setExposureAndGain</A>
<LI>
<A HREF="#Set SV9T001 Exposure and Digital Gain   ---   pxd_SV9M001_setExposureAndDigitalGain"CLASS="TOC">Set SV9T001 Exposure and Digital Gain   ---   pxd_SV9M001_setExposureAndDigitalGain</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Exposure   ---   pxd_SV9M001_getExposure"CLASS="TOC">Get SV9M001/SV9T001 Exposure   ---   pxd_SV9M001_getExposure</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Gain   ---   pxd_SV9M001_getGain"CLASS="TOC">Get SV9M001/SV9T001 Gain   ---   pxd_SV9M001_getGain</A>
<LI>
<A HREF="#Get SV9T001 Digital Gain   ---   pxd_SV9M001_getDigitalGain"CLASS="TOC">Get SV9T001 Digital Gain   ---   pxd_SV9M001_getDigitalGain</A>
<LI>
<A HREF="#Set SV9M001/SV9T001 Resolution and Timing   ---   pxd_SV9M001_setResolutionAndTiming"CLASS="TOC">Set SV9M001/SV9T001 Resolution and Timing   ---   pxd_SV9M001_setResolutionAndTiming</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Aoi Top Edge   ---   pxd_SV9M001_getAoiTop"CLASS="TOC">Get SV9M001/SV9T001 Aoi Top Edge   ---   pxd_SV9M001_getAoiTop</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Aoi Left Edge   ---   pxd_SV9M001_getAoiLeft"CLASS="TOC">Get SV9M001/SV9T001 Aoi Left Edge   ---   pxd_SV9M001_getAoiLeft</A>
<LI>
<A HREF="#Get SV9M001 Scan Direction   ---   pxd_SV9M001_getScanDirection"CLASS="TOC">Get SV9M001 Scan Direction   ---   pxd_SV9M001_getScanDirection</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Subsample   ---   pxd_SV9M001_getSubsample"CLASS="TOC">Get SV9M001/SV9T001 Subsample   ---   pxd_SV9M001_getSubsample</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Pixel Clock Frequency   ---   pxd_SV9M001_getPixelClock"CLASS="TOC">Get SV9M001/SV9T001 Pixel Clock Frequency   ---   pxd_SV9M001_getPixelClock</A>
<LI>
<A HREF="#Set SV9M001/SV9T001 Video And Trigger Modes   ---   pxd_SV9M001_setVideoAndTriggerMode"CLASS="TOC">Set SV9M001/SV9T001 Video And Trigger Modes   ---   pxd_SV9M001_setVideoAndTriggerMode</A>
<LI>
<A HREF="#Set SV9M001/SV9T001 Controlled Exposure And Frame Rate   ---   pxd_SV9M001_setCtrlRate"CLASS="TOC">Set SV9M001/SV9T001 Controlled Exposure And Frame Rate   ---   pxd_SV9M001_setCtrlRate</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Video Mode   ---   pxd_SV9M001_getVideoMode"CLASS="TOC">Get SV9M001/SV9T001 Video Mode   ---   pxd_SV9M001_getVideoMode</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Controlled Video Mode   ---   pxd_SV9M001_getCtrlVideoMode"CLASS="TOC">Get SV9M001/SV9T001 Controlled Video Mode   ---   pxd_SV9M001_getCtrlVideoMode</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Controlled Trigger Mode   ---   pxd_SV9M001_getCtrlTriggerMode"CLASS="TOC">Get SV9M001/SV9T001 Controlled Trigger Mode   ---   pxd_SV9M001_getCtrlTriggerMode</A>
<LI>
<A HREF="#Get SV9M001/SV9T001 Controlled Frame Rate   ---   pxd_SV9M001_getCtrlFrameRate"CLASS="TOC">Get SV9M001/SV9T001 Controlled Frame Rate   ---   pxd_SV9M001_getCtrlFrameRate</A>
<LI>
<A HREF="#Set SV642 Exposure and Gain   ---   pxd_SV642_setExposureAndGain"CLASS="TOC">Set SV642 Exposure and Gain   ---   pxd_SV642_setExposureAndGain</A>
<LI>
<A HREF="#Get SV642 Exposure   ---   pxd_SV642_getExposure"CLASS="TOC">Get SV642 Exposure   ---   pxd_SV642_getExposure</A>
<LI>
<A HREF="#Get SV642 Gain   ---   pxd_SV642_getGain"CLASS="TOC">Get SV642 Gain   ---   pxd_SV642_getGain</A>
<LI>
<A HREF="#Get SV642 Gain Range   ---   pxd_SV642_getGainRange"CLASS="TOC">Get SV642 Gain Range   ---   pxd_SV642_getGainRange</A>
<LI>
<A HREF="#Set SV642 Resolution and Timing   ---   pxd_SV642_setResolutionAndTiming"CLASS="TOC">Set SV642 Resolution and Timing   ---   pxd_SV642_setResolutionAndTiming</A>
<LI>
<A HREF="#Get SV642 Aoi Top Edge   ---   pxd_SV642_getAoiTop"CLASS="TOC">Get SV642 Aoi Top Edge   ---   pxd_SV642_getAoiTop</A>
<LI>
<A HREF="#Get SV642 Aoi Left Edge   ---   pxd_SV642_getAoiLeft"CLASS="TOC">Get SV642 Aoi Left Edge   ---   pxd_SV642_getAoiLeft</A>
<LI>
<A HREF="#Get SV642 Pixel Clock Frequency   ---   pxd_SV642_getPixelClock"CLASS="TOC">Get SV642 Pixel Clock Frequency   ---   pxd_SV642_getPixelClock</A>
<LI>
<A HREF="#Set SV642 Video And Trigger Modes   ---   pxd_SV642_setVideoAndTriggerMode"CLASS="TOC">Set SV642 Video And Trigger Modes   ---   pxd_SV642_setVideoAndTriggerMode</A>
<LI>
<A HREF="#Set SV642 Controlled Exposure And Frame Rate   ---   pxd_SV642_setCtrlRate"CLASS="TOC">Set SV642 Controlled Exposure And Frame Rate   ---   pxd_SV642_setCtrlRate</A>
<LI>
<A HREF="#Get SV642 Video Mode   ---   pxd_SV642_getVideoMode"CLASS="TOC">Get SV642 Video Mode   ---   pxd_SV642_getVideoMode</A>
<LI>
<A HREF="#Get SV642 Controlled Video Mode   ---   pxd_SV642_getCtrlVideoMode"CLASS="TOC">Get SV642 Controlled Video Mode   ---   pxd_SV642_getCtrlVideoMode</A>
<LI>
<A HREF="#Get SV642 Controlled Trigger Mode   ---   pxd_SV642_getCtrlTriggerMode"CLASS="TOC">Get SV642 Controlled Trigger Mode   ---   pxd_SV642_getCtrlTriggerMode</A>
<LI>
<A HREF="#Get SV642 Controlled Frame Rate   ---   pxd_SV642_getCtrlFrameRate"CLASS="TOC">Get SV642 Controlled Frame Rate   ---   pxd_SV642_getCtrlFrameRate</A>
</UL>
<LI>
<A HREF="#4.  Structured Style Interface - Open, Close, Information, and Fault Services"CLASS="TOC">4.  Structured Style Interface - Open, Close, Information, and Fault Services</A>
<UL TYPE="circle">
<LI>
<A HREF="#Get Imaging Board Include Files ID   ---   xclib_libincid"CLASS="TOC">Get Imaging Board Include Files ID   ---   xclib_libincid</A>
<LI>
<A HREF="#Get Imaging Board Library ID   ---   xclib_liblibid"CLASS="TOC">Get Imaging Board Library ID   ---   xclib_liblibid</A>
<LI>
<A HREF="#PIXCI&reg; Imaging Board: Structured Open   ---   xclib_open"CLASS="TOC">PIXCI&reg; Imaging Board: Structured Open   ---   xclib_open</A>
<LI>
<A HREF="#PIXCI&reg; Imaging Board: Structured Close   ---   xclib_close"CLASS="TOC">PIXCI&reg; Imaging Board: Structured Close   ---   xclib_close</A>
<LI>
<A HREF="#Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo"CLASS="TOC">Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo</A>
<LI>
<A HREF="#Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo"CLASS="TOC">Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo</A>
<LI>
<A HREF="#Obtain Last Logged Fault   ---   ::pxdev.getFault"CLASS="TOC">Obtain Last Logged Fault   ---   ::pxdev.getFault</A>
<LI>
<A HREF="#Get Driver Parameters   ---   ::xcdev.getDevParms"CLASS="TOC">Get Driver Parameters   ---   ::xcdev.getDevParms</A>
<LI>
<A HREF="#Set Driver Parameters   ---   ::xcdev.setDevParms"CLASS="TOC">Set Driver Parameters   ---   ::xcdev.setDevParms</A>
</UL>
<LI>
<A HREF="#5.  Structured Style Interface - Video Format Configuration Services"CLASS="TOC">5.  Structured Style Interface - Video Format Configuration Services</A>
<UL TYPE="circle">
<LI>
<A HREF="#Allocate Copy of Video State   ---   ::pxlib.allocStateCopy"CLASS="TOC">Allocate Copy of Video State   ---   ::pxlib.allocStateCopy</A>
<LI>
<A HREF="#Free Copy of Video State   ---   ::pxlib.freeStateCopy"CLASS="TOC">Free Copy of Video State   ---   ::pxlib.freeStateCopy</A>
<LI>
<A HREF="#Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy"CLASS="TOC">Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy</A>
<LI>
<A HREF="#Define Video State   ---   ::pxlib.defineState"CLASS="TOC">Define Video State   ---   ::pxlib.defineState</A>
<LI>
<A HREF="#Delete Video State   ---   ::pxlib.deleteState"CLASS="TOC">Delete Video State   ---   ::pxlib.deleteState</A>
<LI>
<A HREF="#Get Video State   ---   ::pxlib.getState"CLASS="TOC">Get Video State   ---   ::pxlib.getState</A>
<LI>
<A HREF="#Export Copy of Video State   ---   ::pxlib.exportStateCopy"CLASS="TOC">Export Copy of Video State   ---   ::pxlib.exportStateCopy</A>
<LI>
<A HREF="#Import Copy of Video State   ---   ::pxlib.importStateCopy"CLASS="TOC">Import Copy of Video State   ---   ::pxlib.importStateCopy</A>
<LI>
<A HREF="#Fixup Video State   ---   ::xclib.fixxStateCopy"CLASS="TOC">Fixup Video State   ---   ::xclib.fixxStateCopy</A>
<LI>
<A HREF="#Fill Video State   ---   ::xclib.fillStateCopy"CLASS="TOC">Fill Video State   ---   ::xclib.fillStateCopy</A>
<LI>
<A HREF="#Sign Video State   ---   ::xclib.signStateCopy"CLASS="TOC">Sign Video State   ---   ::xclib.signStateCopy</A>
<LI>
<A HREF="#Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy"CLASS="TOC">Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy</A>
<LI>
<A HREF="#Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs"CLASS="TOC">Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs</A>
<LI>
<A HREF="#Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs"CLASS="TOC">Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs</A>
</UL>
<LI>
<A HREF="#6.  Structured Style Interface - Memory Access Services"CLASS="TOC">6.  Structured Style Interface - Memory Access Services</A>
<UL TYPE="circle">
<LI>
<A HREF="#Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap"CLASS="TOC">Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap</A>
<LI>
<A HREF="#Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap"CLASS="TOC">Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap</A>
<LI>
<A HREF="#Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage"CLASS="TOC">Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage</A>
<LI>
<A HREF="#Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3"CLASS="TOC">Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3</A>
<LI>
<A HREF="#Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage"CLASS="TOC">Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage</A>
<LI>
<A HREF="#Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3"CLASS="TOC">Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3</A>
<LI>
<A HREF="#Read/Write Imaging Board Memory   ---   ::pxdev.io"CLASS="TOC">Read/Write Imaging Board Memory   ---   ::pxdev.io</A>
</UL>
<LI>
<A HREF="#7.  Structured Style Interface - Video Services"CLASS="TOC">7.  Structured Style Interface - Video Services</A>
<UL TYPE="circle">
<LI>
<A HREF="#Get Live/Snap Status   ---   ::xcdev.getLiveStatus"CLASS="TOC">Get Live/Snap Status   ---   ::xcdev.getLiveStatus</A>
<LI>
<A HREF="#Get Current Video Status   ---   ::pxdev.getVidStatus"CLASS="TOC">Get Current Video Status   ---   ::pxdev.getVidStatus</A>
<LI>
<A HREF="#Get Extended Video Status   ---   ::xcdev.getVidStatus"CLASS="TOC">Get Extended Video Status   ---   ::xcdev.getVidStatus</A>
<LI>
<A HREF="#Get Current Video Status Value   ---   ::pxdev.getVidStatusValue"CLASS="TOC">Get Current Video Status Value   ---   ::pxdev.getVidStatusValue</A>
<LI>
<A HREF="#Get Current Buffer Status   ---   ::pxlib.goingBufStatus"CLASS="TOC">Get Current Buffer Status   ---   ::pxlib.goingBufStatus</A>
<LI>
<A HREF="#Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf"CLASS="TOC">Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf</A>
<LI>
<A HREF="#Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf"CLASS="TOC">Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf</A>
<LI>
<A HREF="#Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf"CLASS="TOC">Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf</A>
<LI>
<A HREF="#Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf"CLASS="TOC">Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf</A>
<LI>
<A HREF="#Initiate Continuous Capture into Memory Space   ---   ::setLivePhys"CLASS="TOC">Initiate Continuous Capture into Memory Space   ---   ::setLivePhys</A>
<LI>
<A HREF="#Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf"CLASS="TOC">Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf</A>
<LI>
<A HREF="#Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf"CLASS="TOC">Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf</A>
<LI>
<A HREF="#Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive"CLASS="TOC">Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive</A>
<LI>
<A HREF="#Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive"CLASS="TOC">Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive</A>
<LI>
<A HREF="#Set Video Configuration   ---   ::xcdev.setVideoConfig"CLASS="TOC">Set Video Configuration   ---   ::xcdev.setVideoConfig</A>
<LI>
<A HREF="#Adjust Video Configuration   ---   ::xcdev.setVideoAdjust"CLASS="TOC">Adjust Video Configuration   ---   ::xcdev.setVideoAdjust</A>
</UL>
<LI>
<A HREF="#8.  Structured Style Interface - Miscellaneous Services"CLASS="TOC">8.  Structured Style Interface - Miscellaneous Services</A>
<UL TYPE="circle">
<LI>
<A HREF="#General Purpose Input Signal: Sense   ---   ::xcdev.getGpin"CLASS="TOC">General Purpose Input Signal: Sense   ---   ::xcdev.getGpin</A>
<LI>
<A HREF="#General Purpose Input Signal: Reset   ---   ::xcdev.setGpin"CLASS="TOC">General Purpose Input Signal: Reset   ---   ::xcdev.setGpin</A>
<LI>
<A HREF="#General Purpose Output Signal: Set   ---   ::xcdev.setGpout"CLASS="TOC">General Purpose Output Signal: Set   ---   ::xcdev.setGpout</A>
<LI>
<A HREF="#General Purpose Output Signal: Get   ---   ::xcdev.getGpout"CLASS="TOC">General Purpose Output Signal: Get   ---   ::xcdev.getGpout</A>
<LI>
<A HREF="#Device Control   ---   ::pxdev.ioctl"CLASS="TOC">Device Control   ---   ::pxdev.ioctl</A>
</UL>
<LI>
<A HREF="#9.  Structured Style Interface - Auxiliary Services"CLASS="TOC">9.  Structured Style Interface - Auxiliary Services</A>
<UL TYPE="circle">
<LI>
<A HREF="#Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream"CLASS="TOC">Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream</A>
<LI>
<A HREF="#Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream"CLASS="TOC">Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream</A>
<LI>
<A HREF="#Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString"CLASS="TOC">Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString</A>
<LI>
<A HREF="#Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox"CLASS="TOC">Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox</A>
<LI>
<A HREF="#Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf"CLASS="TOC">Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf</A>
<LI>
<A HREF="#Load Image: BMP Format   ---   ::pxaux.imageLoadBmp"CLASS="TOC">Load Image: BMP Format   ---   ::pxaux.imageLoadBmp</A>
<LI>
<A HREF="#Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff"CLASS="TOC">Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff</A>
<LI>
<A HREF="#Save Image: BMP Format   ---   ::pxaux.imageSaveBmp"CLASS="TOC">Save Image: BMP Format   ---   ::pxaux.imageSaveBmp</A>
<LI>
<A HREF="#Save Image: PCX Format   ---   ::pxaux.imageSavePcx"CLASS="TOC">Save Image: PCX Format   ---   ::pxaux.imageSavePcx</A>
<LI>
<A HREF="#Save Image: TARGA Format   ---   ::pxaux.imageSaveTga"CLASS="TOC">Save Image: TARGA Format   ---   ::pxaux.imageSaveTga</A>
<LI>
<A HREF="#Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff"CLASS="TOC">Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff</A>
<LI>
<A HREF="#Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar"CLASS="TOC">Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar</A>
<LI>
<A HREF="#Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort"CLASS="TOC">Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort</A>
<LI>
<A HREF="#Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt"CLASS="TOC">Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt</A>
<LI>
<A HREF="#Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar"CLASS="TOC">Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar</A>
<LI>
<A HREF="#Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort"CLASS="TOC">Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort</A>
<LI>
<A HREF="#Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt"CLASS="TOC">Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt</A>
<LI>
<A HREF="#Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB"CLASS="TOC">Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB</A>
<LI>
<A HREF="#Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB"CLASS="TOC">Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB</A>
<LI>
<A HREF="#Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits"CLASS="TOC">Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits</A>
</UL>
<LI>
<A HREF="#10.  Structured Style Interface - Camera Services"CLASS="TOC">10.  Structured Style Interface - Camera Services</A>
<UL TYPE="circle">
<LI>
<A HREF="#Camera Control: SILICON VIDEO&reg; 2112   ---   PXCam_SILICONVIDEO2112"CLASS="TOC">Camera Control: SILICON VIDEO&reg; 2112   ---   PXCam_SILICONVIDEO2112</A>
<LI>
<A HREF="#Camera Control: SILICON VIDEO&reg; 1310   ---   PXCam_SILICONVIDEO1310"CLASS="TOC">Camera Control: SILICON VIDEO&reg; 1310   ---   PXCam_SILICONVIDEO1310</A>
<LI>
<A HREF="#Camera Control: SILICON VIDEO&reg; 1281   ---   PXCam_SILICONVIDEO1281"CLASS="TOC">Camera Control: SILICON VIDEO&reg; 1281   ---   PXCam_SILICONVIDEO1281</A>
<LI>
<A HREF="#Camera Control: SILICON VIDEO&reg; 9M001   ---   PXCam_SILICONVIDEO9M001"CLASS="TOC">Camera Control: SILICON VIDEO&reg; 9M001   ---   PXCam_SILICONVIDEO9M001</A>
<LI>
<A HREF="#Camera Control: SILICON VIDEO&reg; 9T001   ---   PXCam_SILICONVIDEO9M001"CLASS="TOC">Camera Control: SILICON VIDEO&reg; 9T001   ---   PXCam_SILICONVIDEO9M001</A>
<LI>
<A HREF="#Camera Control: SILICON VIDEO&reg; 642   ---   PXCam_SILICONVIDEO642"CLASS="TOC">Camera Control: SILICON VIDEO&reg; 642   ---   PXCam_SILICONVIDEO642</A>
</UL>
<LI>
<A HREF="#11.  Device Independent Image Access Interface"CLASS="TOC">11.  Device Independent Image Access Interface</A>
<UL TYPE="circle">
<LI>
<A HREF="#PXIMAGE: Image and Pixel Specifications   ---   Struct pximage"CLASS="TOC">PXIMAGE: Image and Pixel Specifications   ---   Struct pximage</A>
<LI>
<A HREF="#PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind"CLASS="TOC">PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind</A>
<LI>
<A HREF="#PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou"CLASS="TOC">PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou</A>
<LI>
<A HREF="#PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset"CLASS="TOC">PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset</A>
<LI>
<A HREF="#PXIMAGE: Read Sequential Pixels   ---   pximage::ioread"CLASS="TOC">PXIMAGE: Read Sequential Pixels   ---   pximage::ioread</A>
<LI>
<A HREF="#PXIMAGE: Write Sequential Pixels   ---   pximage::iorite"CLASS="TOC">PXIMAGE: Write Sequential Pixels   ---   pximage::iorite</A>
<LI>
<A HREF="#PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait"CLASS="TOC">PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait</A>
<LI>
<A HREF="#PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen"CLASS="TOC">PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen</A>
<LI>
<A HREF="#PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts"CLASS="TOC">PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts</A>
<LI>
<A HREF="#PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp"CLASS="TOC">PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp</A>
<LI>
<A HREF="#PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta"CLASS="TOC">PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta</A>
<LI>
<A HREF="#PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw"CLASS="TOC">PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw</A>
<LI>
<A HREF="#PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset"CLASS="TOC">PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset</A>
<LI>
<A HREF="#PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap"CLASS="TOC">PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap</A>
<LI>
<A HREF="#PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr"CLASS="TOC">PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr</A>
</UL>
<LI>
<A HREF="#12.  Application Notes"CLASS="TOC">12.  Application Notes</A>
<UL TYPE="circle">
<LI>
<A HREF="#12.1.  Conversion of Application Programs from XCOBJ"CLASS="TOC">12.1.  Conversion of Application Programs from XCOBJ</A>
<LI>
<A HREF="#12.2.  Using a Serial (RS-232) Configurable Camera with the PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI"CLASS="TOC">12.2.  Using a Serial (RS-232) Configurable Camera with the PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI</A>
<UL TYPE="circle">
<LI>
<A HREF="#12.2.1.  Initialization"CLASS="TOC">12.2.1.  Initialization</A>
<LI>
<A HREF="#12.2.2.  Adjustments"CLASS="TOC">12.2.2.  Adjustments</A>
</UL>
<LI>
<A HREF="#12.3.  Using a Video Format Configuration Exported by XCAP"CLASS="TOC">12.3.  Using a Video Format Configuration Exported by XCAP</A>
<LI>
<A HREF="#12.4.  Capture into Devices"CLASS="TOC">12.4.  Capture into Devices</A>
<UL TYPE="circle">
<LI>
<A HREF="#12.4.1.  PIXCI&reg; SV4 SV5, or SV5A and DirectDraw"CLASS="TOC">12.4.1.  PIXCI&reg; SV4 SV5, or SV5A and DirectDraw</A>
<LI>
<A HREF="#12.4.2.  PIXCI&reg; and StreamStor"CLASS="TOC">12.4.2.  PIXCI&reg; and StreamStor</A>
</UL>
<LI>
<A HREF="#12.5.  Adjusting White Balance of a Bayer Output Camera with the PIXCI&reg; Imaging Board"CLASS="TOC">12.5.  Adjusting White Balance of a Bayer Output Camera with the PIXCI&reg; Imaging Board</A>
<LI>
<A HREF="#12.6.  Processing Images from a Bayer Output Camera with the PIXCI&reg; CL, D, or E Series"CLASS="TOC">12.6.  Processing Images from a Bayer Output Camera with the PIXCI&reg; CL, D, or E Series</A>
</UL>
<LI>
<A HREF="#13.  Release Notes"CLASS="TOC">13.  Release Notes</A>
<LI>
<A HREF="#14.  Distribution Contents"CLASS="TOC">14.  Distribution Contents</A>
<LI>
<A HREF="#Footnotes"CLASS="TOC">15.  Footnotes</A>
<LI>
<A HREF="#Index"CLASS="TOC">Index</A>
</UL>
<!-- BODY BODY BODY -->
<HR SIZE="3">
<A NAME="Installation, Configuration, and Usage &mdash; Compile Time"CLASS="Ch"></A>
<A NAME="1.  Installation, Configuration, and Usage &mdash; Compile Time"></A>
<H1>1.  Installation, Configuration, and Usage &mdash; Compile Time</H1>
<BR>
<A NAME="Introduction"CLASS="Ch"></A>
<A NAME="1.1.  Introduction"></A>
<H2>1.1.  Introduction</H2>
<P>
This manual describes the XCLIB and XCLIB-Lite ``C'' Library
for use with the EPIX&reg;
PIXCI&reg;
imaging boards.
The library supports all current and previous versions of the
PIXCI&reg;
imaging boards,
allowing convenient control and access to the features
of single imaging boards, or multiple imaging boards,
or one or more imaging boards with multiple functional units.<A HREF="#Footnote 1"CLASS="Ff"><SUP>[1]</SUP></A>
<P>
A comprehensive example Windows program named
<CODE CLASS="Em">xclibex2.cpp</CODE>
is included with the library,
and demonstrates many of the library's functions.
In particular, it demonstrates a variety of techniques
for capturing and displaying video
on the graphics display (S/VGA), including the display of nondestructive overlays,
and the use of events to receive notification of captured images.
The example also demonstrates access to numeric pixel data.
<P>
An example DOS and Windows command line program named
<CODE CLASS="Em">xclibex1.c</CODE>
is included with the library,
and demonstrates capturing images,
access to numeric pixel data,
and saving images in standard formats.
Under DOS, and in conjunction with the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
the examples also demonstrates displaying
video on the graphics display (S/VGA).
<P>
An example Visual Basic program named
<CODE CLASS="Em">xclibex3.txt</CODE>
and an example VB.NET program named
<CODE CLASS="Em">xclibex6.txt</CODE>
are included with the library, demonstrating
the fundamental library functions.
<P>
An example Windows program named
<CODE CLASS="Em">xclibex4.cpp</CODE>
is included with the library,
and demonstrates capture of image sequences
at video rate and subsequent display on the graphics display (S/VGA).
An example Windows program named
<CODE CLASS="Em">xclibex5.cpp</CODE>
is included with the library,
and demonstrates simultaneous operation of two imaging boards
at different resolutions.
An example Windows program named
<CODE CLASS="Em">xclibexp.cpp</CODE>
is included with the library,
and demonstrates live display of processed video images.
<P>
An example Windows program named
<CODE CLASS="Em">xclibexc.cpp</CODE>
is included with the library for use with the
SILICON VIDEO&reg; 2112, 2112C, 1310, 1310C, 1281M, 1281C,
9M001, 9M001C, 9T001C, 642M, and 642C cameras,
and demonstrates camera specific controls as well as
capturing and displaying video
on the graphics display (S/VGA).
<P>
An example Linux command line program named
<CODE CLASS="Em">xclibel1.c</CODE>
is included with the library,
and demonstrates capturing images,
access to numeric pixel data,
and saving images in standard formats.
<P>
An example Linux GUI program named
<CODE CLASS="Em">xclibel3.c</CODE>
is included with the library,
and demonstrates capturing images,
and displaying video
on the graphics display (S/VGA), using the Gnome Desktop.
<P>
These example programs can be compiled and executed to gain familiarity
with the library,
as well as the source code of each read in conjunction with this manual.
Instructions on setting options and compilation are contained within each
program.
<P>
A word about conventions used in this manual.
Highlighted phrases such as
<A HREF="#Introduction"CLASS="Er">Introduction</A>
are a reference to a section of this manual.
Highlighted phrases such as
<CITE CLASS="Ec">FUNDAMENTALS OF DIGITAL IMAGE PROCESSING</CITE>
are a reference to this manual or another publication.
Highlighted phrases such as
<CODE CLASS="Em">file.xyz</CODE>
are a reference to a file.
Highlighted phrases such as
<EM CLASS="Ep">threshold</EM>
typically refer to a function's parameters.
Older HTML browsers may not show these variations in a distinguished manner.
Unless explicitly differentiated otherwise, references to XCLIB include XCLIB-Lite.
<P>
This manual groups the library functions according
to expected patterns of use, or common effect.
The
<A HREF="#Index"CLASS="Er">Index</A>
provides an alphabetically sorted
listing of function names.
<BR>
<A NAME="Library Installation"CLASS="Ch"></A>
<A NAME="1.2.  Library Installation"></A>
<H2>1.2.  Library Installation</H2>
<P>
While XCLIB is easy to install,
like most manufacturer's of PC software we recommend as a precaution
that a hard disk backup be performed
before installing XCLIB.
<P>
To install XCLIB on a PC with hard disk:
<OL TYPE="1">
<P>
<LI>
If XCLIB is provided on diskette(s):
<OL TYPE="i">
<P>
<LI>
Insert XCLIB diskette #1 into the A: or B: drive.
<P>
<LI>
Execute the SETUP program, from a command prompt,
or via the Windows
''Start'',
''Run'':
<BLOCKQUOTE>
<PRE>
    &gt; A:SETUP
or
    &gt; B:SETUP
</PRE>
</BLOCKQUOTE>
<P>
<LI>
Follow the installation program's directions, such as to
select an installation directory, and insert additional diskettes
(depending upon version) as instructed.
</OL>
<P>
<LI>
If XCLIB is provided on CD:
<OL TYPE="i">
<P>
<LI>
If your PC is set to allow automatic execution
of loaded CDs, the CD's interactive index program
will be executed automatically.
Otherwise, execute the index program, from a command prompt,
or via the Windows
''Start'',
''Run'':
<BLOCKQUOTE>
<PRE>
    &gt; Z:SETUP       (replace Z with drive letter for your CD)
</PRE>
</BLOCKQUOTE>
<P>
<LI>
Select
''Setup PIXCI(R) Imaging Software''
and one of:
<BLOCKQUOTE>
<PRE>
    XCLIB-Lite 'C' Library for Win 95/98/ME
    XCLIB-Lite 'C' Library for Win NT/2000/XP/Server2003
    XCLIB 'C' Library for Win 95/98/ME
    XCLIB 'C' Library for Win NT/2000/XP/Server2003
    XCLIB 'C' Library for DOS+Watcom+Tenberry
    XCLIB+PXIPL `C' Library for Win 95/98/ME
    XCLIB+PXIPL `C' Library for Win NT/2000/XP/Server2003
or
    XCLIB+PXIPL `C' Library for DOS+Watcom+Tenberry
</PRE>
</BLOCKQUOTE>
as appropriate.
Click
''OK''.
<P>
<LI>
Follow the installation program's directions, such as to
select an installation directory.
</OL>
<P>
<LI>
If XCLIB is provided via the internet:
<OL TYPE="i">
<P>
<LI>
As directed by your customer service representative,
download a specified
<CODE CLASS="Em">&nbsp;.EXE</CODE>
file from the EPIX, Inc. ftp site.
<P>
<LI>
Execute the downloaded program, from a command prompt,
or via the Windows
''Start'',
''Run'':
<BLOCKQUOTE>
<PRE>
    &gt; MY.EXE
</PRE>
</BLOCKQUOTE>
<P>
<LI>
Follow the installation program's directions, such as to
select an installation directory.
<P>
<LI>
Delete the downloaded
<CODE CLASS="Em">&nbsp;.EXE</CODE>
file from your PC's hard drive.
</OL>
</OL>
After installation, any files in the chosen directory named
<CODE CLASS="Em">*.TXT</CODE>
etc. contain distribution listings, corrections, or additions
to this manual, or other up-to-date information.
<P>
The example
<CODE CLASS="Em">xclibex1.c</CODE>,
<CODE CLASS="Em">xclibex2.cpp</CODE>,
<CODE CLASS="Em">xclibex3.txt</CODE>,
<CODE CLASS="Em">xclibex6.txt</CODE>,
<CODE CLASS="Em">xclibex4.cpp</CODE>,
<CODE CLASS="Em">xclibex5.cpp</CODE>,
<CODE CLASS="Em">xclibel1.c</CODE>,
or
<CODE CLASS="Em">xclibel3.c</CODE>
program, or your application program,
can now be compiled and run.
<BR>
<A NAME="Compiling"CLASS="Ch"></A>
<A NAME="1.3.  Compiling"></A>
<H2>1.3.  Compiling</H2>
<P>
The library is compatible with
the following compilers, versions, memory models, and environments:
<A NAME="Libraries NX0"CLASS="NX"></A>
<A NAME="Compilation NX1"CLASS="NX"></A>
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="center" COLSPAN="1">
            
</TD>
<TD ALIGN="center" COLSPAN="1">
     
</TD>
<TD ALIGN="center" COLSPAN="1">
            
</TD>
<TD ALIGN="center" COLSPAN="1">
                   
</TD>
<TD ALIGN="center" COLSPAN="1">
Execution  
</TD>
<TD ALIGN="center" COLSPAN="1">
Run Time
</TD>
</TR>
<TR>
<TD ALIGN="center" COLSPAN="1">
Compiler    
</TD>
<TD ALIGN="center" COLSPAN="1">
Model
</TD>
<TD ALIGN="center" COLSPAN="1">
Library Name
</TD>
<TD ALIGN="center" COLSPAN="1">
Compiled w. Options
</TD>
<TD ALIGN="center" COLSPAN="1">
Environment
</TD>
<TD ALIGN="center" COLSPAN="1">
Modules
</TD>
</TR>
<TR><TD COLSPAN="6"><HR NOSHADE SIZE="3"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
Any 32 bit Microsoft 
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLIBW95.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>-GB -MT -LD</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
Windows 95
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLIBW95.DLL</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
Compatible Compiler  
</TD>
<TD ALIGN="left" COLSPAN="1">
      or                    
</TD>
<TD ALIGN="left" COLSPAN="1">
                         
</TD>
<TD ALIGN="left" COLSPAN="1">
Windows 98
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>EPIXXCW5.VXD</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLYBW95.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
                         
</TD>
<TD ALIGN="left" COLSPAN="1">
Windows ME
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>EPIXXCW5.INF</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
                            
</TD>
<TD ALIGN="left" COLSPAN="1">
                         
</TD>
<TD ALIGN="left" COLSPAN="1">
          
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>EPIXXC.SYS (optional)</CODE>
</TD>
</TR>
<TR><TD COLSPAN="6"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
Any 32 bit Microsoft 
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLIBWNT.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>-GB -MT -LD</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
Windows NT  
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLIBWNT.DLL</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
Compatible Compiler  
</TD>
<TD ALIGN="left" COLSPAN="1">
      or                    
</TD>
<TD ALIGN="left" COLSPAN="1">
                         
</TD>
<TD ALIGN="left" COLSPAN="1">
            
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>EPIXXCWT.SYS</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLYBWNT.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
                         
</TD>
<TD ALIGN="left" COLSPAN="1">
            
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>EPIXXCWT.INF</CODE>
</TD>
</TR>
<TR><TD COLSPAN="6"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
Any 32 bit Microsoft 
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLIBWNT.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>-GB -MT -LD</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
Windows 2000       
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLIBWNT.DLL</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
Compatible Compiler  
</TD>
<TD ALIGN="left" COLSPAN="1">
      or                    
</TD>
<TD ALIGN="left" COLSPAN="1">
                         
</TD>
<TD ALIGN="left" COLSPAN="1">
Windows XP         
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>EPIXXCW2.SYS</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLIBWNT.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
                         
</TD>
<TD ALIGN="left" COLSPAN="1">
Windows Server 2003
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>EPIXXCW2.INF</CODE>
</TD>
</TR>
<TR><TD COLSPAN="6"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
GNU V3.2.2         
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>xclib_i386.a</CODE> 
</TD>
<TD ALIGN="left" COLSPAN="1">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
Linux 2.4 kernels 
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>pixci_i386.o</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
                   
</TD>
<TD ALIGN="left" COLSPAN="1">
                             
</TD>
<TD ALIGN="left" COLSPAN="1">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (2.4.21-0.13mdk) 
</TD>
</TR>
<TR><TD COLSPAN="6"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
GNU V4.0.0         
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>xclib_i386.a</CODE> 
</TD>
<TD ALIGN="left" COLSPAN="1">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
Linux 2.6 kernels    
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>pixci_i386.ko</CODE>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="2">
                   
</TD>
<TD ALIGN="left" COLSPAN="1">
                             
</TD>
<TD ALIGN="left" COLSPAN="1">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (2.6.11-1.1369-FC4) 
</TD>
</TR>
<TR><TD COLSPAN="6"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
Watcom C/C++ V10.0   
</TD>
<TD ALIGN="left" COLSPAN="1">
f, 32 bit
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLBW0DF.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>-4r -mf -w3 -ox</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
DOS4GW      
</TD>
<TD ALIGN="left" COLSPAN="1">
none
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
         
</TD>
<TD ALIGN="left" COLSPAN="1">
                               
</TD>
<TD ALIGN="left" COLSPAN="1">
                             
</TD>
<TD ALIGN="left" COLSPAN="1">
Professional
</TD>
</TR>
<TR><TD COLSPAN="6"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
Watcom C/C++ V11.0   
</TD>
<TD ALIGN="left" COLSPAN="1">
f, 32 bit
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>XCLBW1DF.LIB</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
<CODE>-4r -mf -w3 -ox</CODE>
</TD>
<TD ALIGN="left" COLSPAN="1">
DOS4GW      
</TD>
<TD ALIGN="left" COLSPAN="1">
none
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
                     
</TD>
<TD ALIGN="left" COLSPAN="1">
         
</TD>
<TD ALIGN="left" COLSPAN="1">
                               
</TD>
<TD ALIGN="left" COLSPAN="1">
                             
</TD>
<TD ALIGN="left" COLSPAN="1">
Professional
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
For Linux, the XCAP application includes a driver recompilation kit,
allowing compiling an additional XCLIB driver so as to exactly match the current kernel.
The Compiled w. Options column shows the significant
options used for creation of each library.
The exact options shown are neither necessary,
nor necessarily desirable, when compiling an application program.
<BR>
<A NAME="Stack"CLASS="Ch"></A>
<A NAME="1.3.1.  Stack"></A>
<H3>1.3.1.  Stack</H3>
<P>
The base XCLIB ``C'' Library requires up to
4096 bytes of available stack space.
If the optional
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
is used,
up to an additional 4096 bytes of stack is required.
The application program may require significant amounts of additional stack space.
Additional stack space may have to be declared during compilation
or linkage to accommodate the total requirement.
<P>
<BR>
<B CLASS="Hv">Note.</B>
<A NAME="Stack Overflow NX2"CLASS="NX"></A>
For efficiency, the XCLIB library
is compiled without explicit stack checks (probes).
Invoking a library function with insufficient available stack
space will produce strange and catastrophic results.
<BR>
<A NAME="Heap"CLASS="Ch"></A>
<A NAME="1.3.2.  Heap"></A>
<H3>1.3.2.  Heap</H3>
<P>
The XCLIB ``C'' Library does not require any large
<CITE CLASS="Ec">malloc</CITE>'ed
storage, other than the host memory allocated for image frame buffers.
The PIXCI&reg;&nbsp;CL3SD has on-board frame buffer memory,
smaller amounts of host memory (approximately 64 or 128 bytes
per frame buffer) may be allocated for per-buffer status information.
<P>
With the PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X,
CL1, CL2, E1, E4, E1DB, SI, or CL3SD imaging board,
when used with a color camera where XCLIB provides
white balancing,
approximately 8*2<SUP><SMALL>BitsPerPixel</SMALL></SUP> bytes of
<CITE CLASS="Ec">malloc</CITE>'ed
storage is required for each video state.
<P>
Several small amounts of storage, of a few hundred bytes each, are
<CITE CLASS="Ec">malloc</CITE>'ed
for storage of video state and internal structures.
<BR>
<A NAME="Memory Allocation Hooks"CLASS="Ch"></A>
<A NAME="1.3.3.  Memory Allocation Hooks"></A>
<H3>1.3.3.  Memory Allocation Hooks</H3>
<P>
The XCLIB invokes the ``C'' library function
<CITE CLASS="Ec">malloc</CITE>
to obtain memory for temporary use.
The application programmer may modify
the memory allocation used by XCLIB.
This substitution is not available when XCLIB is embedded in a
Windows DLL.
<P>
Most memory allocated and freed by XCLIB,
except memory allocated for image frame buffers,
and most memory allocated and freed by the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>,
if used,
is actually obtained and released by invoking internal functions
<CITE CLASS="Ec">pxmalloc</CITE>,
<CITE CLASS="Ec">pxfree</CITE>,
<CITE CLASS="Ec">pxrealloc</CITE>,
<CITE CLASS="Ec">pxmallocf16</CITE>,
and
<CITE CLASS="Ec">pxfreef16</CITE>
which are defined in module PXMALLOC.OBJ as:<A HREF="#Footnote 2"CLASS="Ff"><SUP>[2]</SUP></A>
<BLOCKQUOTE>
<PRE>
/* 16/32 bit environments */
void *     _cfunfcc pxmalloc(uint len)          { if(!len)return(NULL);
                                                  return(malloc(len));   }
void       _cfunfcc pxfree(void*buf)            { free(buf);             }
void *     _cfunfcc pxrealloc(void*p, uint len) { if(!p&amp;&amp;!len)return(NULL);
                                                  return(realloc(p,len));}
<BR>
/* 16 bit environments */
void _far* _cfunfcc pxmallocf16(uint len)       { if(!len)return(NULL);
                                                  return(_fmalloc(len)); }
void       _cfunfcc pxfreef16(void _far*buf)    { _ffree(buf);           }
<BR>
/* 32 bit environments */
void *     _cfunfcc pxmallocf16(uint len)       { if(!len)return(NULL);
                                                  return(malloc(len));   }
void       _cfunfcc pxfreef16(void*buf)         { free(buf);             }
</PRE>
</BLOCKQUOTE>
The application program may provide alternate functions with the
same name and semantics,
to be selected by the linker in preference to the above definitions.
<BR>
<A NAME="Compile Time Inclusions"CLASS="Ch"></A>
<A NAME="1.4.  Compile Time Inclusions"></A>
<H2>1.4.  Compile Time Inclusions</H2>
<A NAME="Inclusions NX3"CLASS="NX"></A>
<P>
The
<CODE CLASS="Em">xcliball.h</CODE>
file
directly or indirectly contains all prototype function declarations
and definitions of constants and declaration of structures
needed for XCLIB.
Proper use of library functions requires inclusion of
<CODE CLASS="Em">xcliball.h</CODE>
by using the statement:
<BLOCKQUOTE>
<PRE>
#include &quot;xcliball.h&quot;
</PRE>
</BLOCKQUOTE>
at the start of each source file of the application program
that uses XCLIB functions.
<P>
If using
<CODE CLASS="Em">xcliball.h</CODE>
within a C++ program, then:
<BLOCKQUOTE>
<PRE>
extern &quot;C&quot; {
#include &quot;xcliball.h&quot;
}
</PRE>
</BLOCKQUOTE>
should be used.<A HREF="#Footnote 3"CLASS="Ff"><SUP>[3]</SUP></A>
<P>
If using
<CODE CLASS="Em">xcliball.h</CODE>
in a Windows environment, a
<BLOCKQUOTE>
<PRE>
#include &lt;windows.h&gt;
</PRE>
</BLOCKQUOTE>
must (not necessarily immediately) precede
<BLOCKQUOTE>
<PRE>
#include &quot;xcliball.h&quot;
</PRE>
</BLOCKQUOTE>
<P>
Several examples shown in this manual utilize the ``C'' construct
''NULL''
to represent
''(void&nbsp;*)&nbsp;0''.
Application programs which use NULL must include the appropriate ``C''
include file, such as
<CODE CLASS="Em">stdio.h</CODE>
or
<CODE CLASS="Em">stdlib.h</CODE>.
<BR>
<A NAME="Common Types and Concepts"CLASS="Ch"></A>
<A NAME="1.5.  Common Types and Concepts"></A>
<H2>1.5.  Common Types and Concepts</H2>
<P>
Common concepts, data types, and modifiers are discussed below,
rather than repeatedly discussed with each function.
These concepts and data types are applicable
to both the SCF Style Interface and the Structured Style Interface.
<BR>
<A NAME="Types"CLASS="Ch"></A>
<A NAME="1.5.1.  Types"></A>
<H3>1.5.1.  Types</H3>
<P>
The following data types
are automatically provided via inclusion of
<CODE CLASS="Em">xcliball.h</CODE>;
the programmer need not
''define''
or
''typedef''
these symbols.
<P>
Types defined by ``C'':
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
Symbol      
</TD>
<TD ALIGN="left" COLSPAN="1">
 ``C'' Definition   
</TD>
<TD ALIGN="left" COLSPAN="1">
 Use
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
size_t      
</TD>
<TD ALIGN="left" COLSPAN="1">
 typically unsigned int 
</TD>
<TD ALIGN="left" COLSPAN="1">
 size of memory objects
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
            
</TD>
<TD ALIGN="left" COLSPAN="1">
 or unsigned long       
</TD>
<TD ALIGN="left" COLSPAN="1">
 (i.e. malloc())
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
<A NAME="size_t NX4"CLASS="NX"></A>
<A NAME="Type size_t NX5"CLASS="NX"></A>
<P>
Extended data types:
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
Symbol       
</TD>
<TD ALIGN="left" COLSPAN="1">
 ``C'' Definition 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Use
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
uchar        
</TD>
<TD ALIGN="left" COLSPAN="1">
 unsigned char    
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
ushort       
</TD>
<TD ALIGN="left" COLSPAN="1">
 unsigned short   
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
uint         
</TD>
<TD ALIGN="left" COLSPAN="1">
 unsigned int     
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
ulong        
</TD>
<TD ALIGN="left" COLSPAN="1">
 unsigned long    
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
schar        
</TD>
<TD ALIGN="left" COLSPAN="1">
 signed char      
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
sshort       
</TD>
<TD ALIGN="left" COLSPAN="1">
 signed short     
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
sint         
</TD>
<TD ALIGN="left" COLSPAN="1">
 signed int       
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
slong        
</TD>
<TD ALIGN="left" COLSPAN="1">
 signed long      
</TD>
<TD ALIGN="left" COLSPAN="1">
 general
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxcoord_t  
</TD>
<TD ALIGN="left" COLSPAN="1">
 int              
</TD>
<TD ALIGN="left" COLSPAN="1">
 x, y image coordinates
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxbuffer_t 
</TD>
<TD ALIGN="left" COLSPAN="1">
 long             
</TD>
<TD ALIGN="left" COLSPAN="1">
 image buffer number
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvbtime_t 
</TD>
<TD ALIGN="left" COLSPAN="1">
 unsigned long    
</TD>
<TD ALIGN="left" COLSPAN="1">
 video field counts/time
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
_farimap   
</TD>
<TD ALIGN="left" COLSPAN="1">
 _far or blank  
</TD>
<TD ALIGN="left" COLSPAN="1">
 farness of an 'imap' pointer
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
<A NAME="uchar NX6"CLASS="NX"></A>
<A NAME="uint NX7"CLASS="NX"></A>
<A NAME="ushort NX8"CLASS="NX"></A>
<A NAME="ulong NX9"CLASS="NX"></A>
<A NAME="schar NX10"CLASS="NX"></A>
<A NAME="sint NX11"CLASS="NX"></A>
<A NAME="sshort NX12"CLASS="NX"></A>
<A NAME="slong NX13"CLASS="NX"></A>
<A NAME="pxcoord_t NX14"CLASS="NX"></A>
<A NAME="pxbuffer_t NX15"CLASS="NX"></A>
<A NAME="pxvbtime_t NX16"CLASS="NX"></A>
<A NAME="_farimap NX17"CLASS="NX"></A>
<A NAME="uchar"CLASS="Tr"></A>
<A NAME="uint"CLASS="Tr"></A>
<A NAME="ushort"CLASS="Tr"></A>
<A NAME="ulong"CLASS="Tr"></A>
<A NAME="schar"CLASS="Tr"></A>
<A NAME="sint"CLASS="Tr"></A>
<A NAME="sshort"CLASS="Tr"></A>
<A NAME="slong"CLASS="Tr"></A>
<A NAME="pxcoord_t"CLASS="Tr"></A>
<A NAME="pxbuffer_t"CLASS="Tr"></A>
<A NAME="pxvbtime_t"CLASS="Tr"></A>
<A NAME="_farimap"CLASS="Tr"></A>
<A NAME="Type uchar NX18"CLASS="NX"></A>
<A NAME="Type uint NX19"CLASS="NX"></A>
<A NAME="Type ushort NX20"CLASS="NX"></A>
<A NAME="Type ulong NX21"CLASS="NX"></A>
<A NAME="Type schar NX22"CLASS="NX"></A>
<A NAME="Type sint NX23"CLASS="NX"></A>
<A NAME="Type sshort NX24"CLASS="NX"></A>
<A NAME="Type slong NX25"CLASS="NX"></A>
<A NAME="Type pxcoord_t NX26"CLASS="NX"></A>
<A NAME="Type pxbuffer_t NX27"CLASS="NX"></A>
<A NAME="Type pxvbtime_t NX28"CLASS="NX"></A>
<A NAME="Type _farimap NX29"CLASS="NX"></A>
<BR>
<A NAME="Modifiers"CLASS="Ch"></A>
<A NAME="1.5.2.  Modifiers"></A>
<H3>1.5.2.  Modifiers</H3>
The following function calling convention modifiers
are automatically provided via inclusion of
<CODE CLASS="Em">xcliball.h</CODE>;
the programmer need not
''define''
or
''typedef''
these symbols:
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
Symbol          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Typical Definition
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
_cfunfcc      
</TD>
<TD ALIGN="left" COLSPAN="1">
 _fastcall or _pascal or _stdcall
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
_cfunvcc      
</TD>
<TD ALIGN="left" COLSPAN="1">
 _cdecl or blank
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
_cfunacc      
</TD>
<TD ALIGN="left" COLSPAN="1">
 _cdecl or blank
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
<A NAME="_cfunfcc NX30"CLASS="NX"></A>
<A NAME="_cfunvcc NX31"CLASS="NX"></A>
<A NAME="_cfunacc NX32"CLASS="NX"></A>
<A NAME="_cfunfcc"CLASS="Tr"></A>
<A NAME="_cfunvcc"CLASS="Tr"></A>
<A NAME="_cfunacc"CLASS="Tr"></A>
<A NAME="Type _cfunfcc NX33"CLASS="NX"></A>
<A NAME="Type _cfunvcc NX34"CLASS="NX"></A>
<A NAME="Type _cfunacc NX35"CLASS="NX"></A>
These modifiers vary in different environments,
accommodating different conventions under DOS, Windows,
and various compilers.
Function prototypes apply modifiers automatically, thus
the programmer need not normally be aware of their existence,
nor are the modifiers normally shown in documentation.
The exception to the programmer's need of awareness, and shown
in the documentation,
are modifiers for functions that are
''called back''
from library functions.
<BR>
<A NAME="Call Back Types"CLASS="Ch"></A>
<A NAME="1.5.3.  Call Back Types"></A>
<H3>1.5.3.  Call Back Types</H3>
The following call back function calling convention modifiers
are automatically provided via inclusion of
<CODE CLASS="Em">xcliball.h</CODE>;
the programmer need not
''define''
or
''typedef''
these symbols:
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
Symbol          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Use
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxabortfunc_t 
</TD>
<TD ALIGN="left" COLSPAN="1">
 premature termination callback predicate function
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
<A NAME="pxabortfunc_t NX36"CLASS="NX"></A>
<A NAME="pxabortfunc_t"CLASS="Tr"></A>
<A NAME="Type pxabortfunc_t NX37"CLASS="NX"></A>
<P>
<A NAME="The pxabortfunc_t"CLASS="Ch"></A>
<A NAME="1.5.3.1.  The pxabortfunc_t"></A>
<H4>1.5.3.1.  The pxabortfunc_t</H4>
Some services, such as the
<A HREF="#::bufferSaveStream"CLASS="Er">::bufferSaveStream</A>
and
<A HREF="#::bufferLoadStream"CLASS="Er">::bufferLoadStream</A>
accept an
<EM CLASS="Ep">abortp</EM>
parameter of type
<EM CLASS="Ep">pxabortfunc_t</EM>,
which is declared in
<CODE CLASS="Em">xcliball.h</CODE>
as:
<BLOCKQUOTE>
<PRE>
typedef int (_cfunfcc pxabortfunc_t)(void*,int,int);
</PRE>
</BLOCKQUOTE>
If
<EM CLASS="Ep">abortp</EM>&ne;NULL,
the service will periodically invoke:
<BLOCKQUOTE>
<PRE>
(*abortp)(abortp, ipos, npos);
</PRE>
</BLOCKQUOTE>
and prematurely terminate if the return value is nonzero,
echoing the same return value.
Use of termination values less than 0 is required, and use of the
particular value PXERBREAK, is suggested.
<P>
The values passed as
<EM CLASS="Ep">done</EM>
and
<EM CLASS="Ep">total</EM>
indicate the approximate progress of the service.
If
<EM CLASS="Ep">total</EM>&gt;0,
then the service, or one phase of the service, is approximately
<EM CLASS="Ep">done</EM>*100./<EM CLASS="Ep">total</EM>
percent complete.
If
<EM CLASS="Ep">total</EM>=0
and
<EM CLASS="Ep">done</EM>=0,
that invocation of
<EM CLASS="Ep">*abortp</EM>
is not updating the progress information,
or the service does not provide progress information.
<P>
If
<EM CLASS="Ep">total</EM>&lt;0,
then the processing is being done in phases,
with each phase independently reporting progress from 0 to 100%;
the number of phases is
-<EM CLASS="Ep">total</EM>,
of which the current phase is
<EM CLASS="Ep">done</EM>,
where
1&lt;=<EM CLASS="Ep">done</EM>&lt;=-<EM CLASS="Ep">total</EM>.
The processing time required may differ among the phases.
<P>
If
<EM CLASS="Ep">total</EM>=0
and
<EM CLASS="Ep">done</EM>&ne;0,
then the value
<EM CLASS="Ep">done</EM>
should be added to an internal
''disable''
counter whose
initial value is 0.
While the disable counter is less than 0,
interpretation of invocations with
<EM CLASS="Ep">total</EM>&gt;0
(percent completion)
or
<EM CLASS="Ep">total</EM>&lt;0
(operation phase)
should be ignored.
<P>
The
<EM CLASS="Ep">total</EM>
and
<EM CLASS="Ep">done</EM>
values are intended solely for optionally
advising an interactive user of computational progress,
and have accuracy suitable only for such use.
<BR>
<A NAME="Usage Assumptions"CLASS="Ch"></A>
<A NAME="1.5.4.  Usage Assumptions"></A>
<H3>1.5.4.  Usage Assumptions</H3>
<P>
Except where noted otherwise, the library functions expect that the
library is currently open for use,
except of course
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>
which open the library.
The
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
can be used if the open failed,
to obtain additional information on the cause of failure.
<BR>
<A NAME="On Frame Buffers and Memory"CLASS="Ch"></A>
<A NAME="1.5.5.  On Frame Buffers and Memory"></A>
<H3>1.5.5.  On Frame Buffers and Memory</H3>
<P>
For PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, SV5A,
D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, or A imaging boards
which do not have on-board frame buffer memory,
the XCLIB architecture
uses a fixed amount of frame buffer memory.
Under Windows 95, 98, ME, NT, 2000, XP, and Server 2003, the frame buffer
memory is allocated when Windows boots;
the total size is fixed until the next reboot.
Under DOS+Tenberry, the frame buffer
memory is allocated when the XCLIB is opened;
the total size is fixed until XCLIB is re-opened.
Under Linux, the frame buffer
memory is allocated when Linux boots;
the total size is fixed until the next reboot.
<P>
For all PIXCI&reg;&nbsp;imaging boards,
the frame buffer memory is partitioned into image
frame buffers, based upon the number of PIXCI(rg
imaging boards in use and the video format configuration
and resolution for each imaging board.
The frame buffer memory is re-partitioned
whenever the number of PIXCI(rg imaging boards in use changes,
or the video format configuration changes.
<P>
An XCLIB function such as:
<BLOCKQUOTE>
<PRE>
    pxd_goLive(..., 1);
</PRE>
</BLOCKQUOTE>
which commands live capture of all fields or frames
into image frame buffer 1,
does not produce a
''history''
of all fields or frames captured, nor use any memory
other than image frame buffer 1;
each newly captured field or frame overlays the data
of the previously captured field or frame.
Similarly,
<BLOCKQUOTE>
<PRE>
    pxd_doSnap(..., 1, ...);
    pxd_doSnap(..., 1, ...);
</PRE>
</BLOCKQUOTE>
snaps two fields or frames into image frame buffer 1;
the latter overlaying the former.
<P>
The image frame buffers for each imaging board
are numbered consecutively starting with 1.
Thus when using multiple imaging boards, the XCLIB function
<BLOCKQUOTE>
<PRE>
    pxd_goLive(0x03, 1);
</PRE>
</BLOCKQUOTE>
which commands both imaging boards one and two to begin
capturing into buffer number 1,
does not cause conflict or overwriting of image data;
each board has its own, unique, buffer number 1.
Similarly, when accessing pixel data or saving the contents
of the frame buffer to a file,
the appropriate functions require a buffer number
as well as a qualifying imaging board number (i.e.
''unit'').
<P>
Video capture is always into one of these image frame buffers,
and never to an
<CITE CLASS="Ec">malloc</CITE>'ed
buffer provided by the application program.
The XCLIB library provides functions to read/write all or portions
of a frame buffer to a program's array or
<CITE CLASS="Ec">malloc</CITE>'ed
buffer.
The XCLIB library also provides the application program
with a pointer into the actual image frame buffer.<A HREF="#Footnote 4"CLASS="Ff"><SUP>[4]</SUP></A>
<P>
Since the total number of image frame buffers
cannot be increased arbitrarily (for a given number
of image boards and a fixed video format resolution),
a live sequence capture with:
<BLOCKQUOTE>
<PRE>
    pxd_LiveSeq(...)
</PRE>
</BLOCKQUOTE>
is limited to the number of image frame buffers.
However, nothing precludes the application from
executing a continuous live sequence capture
using the image frame buffers in a circular fashion,
and copying the contents of a newly captured
image frame buffer elsewhere (such as
<CITE CLASS="Ec">malloc</CITE>'ed
memory, or to disk)
before the live sequence capture
''returns''
and re-uses that buffer.
<BR>
<A NAME="On Snap Semantics"CLASS="Ch"></A>
<A NAME="1.5.6.  On Snap Semantics"></A>
<H3>1.5.6.  On Snap Semantics</H3>
<P>
Functions to snap a video field or frame,
such as
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>,
capture the next field or frame following its invocation;
that is, the function
''arms''
the PIXCI&reg; imaging board to capture the next field or frame
into a frame buffer.
This is in contrast to having the imaging board consume
resources continuously capturing every field or frame,
and having a hypothetical snap function retrieve the last
field or frame captured.
This hypothetical behavior
<U CLASS="U">can</U>
be obtained in XCLIB using
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>
or similar functions,
but it isn't the behavior of the snap functions.
<BR>
<A NAME="On Imaging Boards with Multiple Functional Units"CLASS="Ch"></A>
<A NAME="1.5.7.  On Imaging Boards with Multiple Functional Units"></A>
<H3>1.5.7.  On Imaging Boards with Multiple Functional Units</H3>
<P>
<A NAME="Functional Units NX38"CLASS="NX"></A>
The PIXCI&reg;&nbsp;E1DB imaging board contains multiple, independent
functional units within a single physical board
and replaces two PIXCI&reg;&nbsp;E1 imaging boards.
The XCLIB Library presents the two halves of the
PIXCI&reg;&nbsp;E1DB imaging board as two PIXCI&reg;&nbsp;E1 imaging boards
and are accessed and controlled via a
<EM CLASS="Ep">unitmap</EM>
parameter as described below.
Each half of the PIXCI&reg;&nbsp;E1DB may be opened and used independently,
except that the second half of the PIXCI&reg;&nbsp;E1DB can not be opened
without the first half also opened.
Within software documentation,
''imaging board''
is synonomous with
''functional units''
unless explicitly stated otherwise.
<BR>
<A NAME="On Multiple Imaging Boards"CLASS="Ch"></A>
<A NAME="1.5.8.  On Multiple Imaging Boards"></A>
<H3>1.5.8.  On Multiple Imaging Boards</H3>
<P>
Each open instance of the library allows
operation of one or more identical imaging boards;
the imaging boards may have
independent video format and resolution.
Relevant XCLIB functions allow simultaneous control
of multiple boards via the
<EM CLASS="Ep">unitmap</EM>
parameter.<A HREF="#Footnote 5"CLASS="Ff"><SUP>[5]</SUP></A>
<P>
Multiple instances of the
library may be opened for mutually exclusive subsets
of imaging boards.
Different open instances are independent;
they do not share Video State ID's or
Video Format Configuration's.
A single invocation of a XCLIB function
can't control multiple imaging boards across multiple open
instances of the library.
<P>
If using the SCF Style Interface,
only one instance of the library may be opened
and the imaging boards must have the same video format and resolution.
<BR>
<A NAME="On Multiple Identical Imaging Boards"CLASS="Ch"></A>
<A NAME="1.5.9.  On Multiple Identical Imaging Boards"></A>
<H3>1.5.9.  On Multiple Identical Imaging Boards</H3>
<P>
A single open instance of
XCLIB supports the operation of multiple identical
PIXCI(rg imaging boards, typically referred to as
''units''.
Each relevant XCLIB function provides a
<EM CLASS="Ep">unitmap</EM>
parameter to select which boards, or boards,
an invocation of that function is to affect.
The
<EM CLASS="Ep">unitmap</EM>
is a bit-map;
the
<EM CLASS="Ep">i'th</EM>
bit has value 1 to select the
<EM CLASS="Ep">i</EM>'th
imaging board.
<P>
Some functions allow operation on multiple
imaging boards with a single invocation;
they describe
<EM CLASS="Ep">unitmap</EM>
with the phrasing
''on each of the multiple boards selected by ...''.
<P>
Some functions only allow operation on a single imaging board
with a single invocation;
they describe
<EM CLASS="Ep">unitmap</EM>
with the phrasing
''the single imaging board selected by ...''.
Should the
<EM CLASS="Ep">unitmap</EM>
have more than one bit set to 1, the imaging board corresponding
to the rightmost 1 bit is selected for use.
<BR>
<A NAME="On Video Format Configuration"CLASS="Ch"></A>
<A NAME="1.5.10.  On Video Format Configuration"></A>
<H3>1.5.10.  On Video Format Configuration</H3>
<P>
<A NAME="Video Format Configuration NX39"CLASS="NX"></A>
The Video Format Configuration
is a group of dozens of parameters
that defines the video format
(i.e. whether NTSC, RS-170, PAL, or CCIR
for applicable imaging boards,
or camera manufacturer and model for other
imaging boards),
the resolution (i.e. capturing more or fewer pixels
per line or column),
and other settings related to the imaging board's hardware.
<P>
The XCLIB provides a suitable default Video Format Configuration
for each PIXCI(rg imaging board, model, and submodel.
<P>
The easiest and suggested method of creating an
alternate Video Format Configuration is to use
<CITE CLASS="Ec">XCAP</CITE>.
XCAP uses an identical and compatible<A HREF="#Footnote 6"CLASS="Ff"><SUP>[6]</SUP></A>
Video Format Configuration,
although XCAP uses the term
''Video Setup''.
In XCAP, use:
<BLOCKQUOTE>
<PRE>
    PIXCI&reg;
    PIXCI&reg; Video Setup
    .. adjust video configuration followed by OK ..
    PIXCI&reg;
    PIXCI&reg; Save Video Setup
</PRE>
</BLOCKQUOTE>
After running XCAP, specify the path name of the saved video setup file
as the third parameter to
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or as the fifth parameter to
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>.
<P>
The contents of the saved video setup file
is readable and editable text;
the
<CODE CLASS="Em">pxlibvs.h</CODE>
and
<CODE CLASS="Em">xclibvs.h</CODE>
files describe the various fields.
Using the
Structured Style Interface,<A HREF="#Footnote 7"CLASS="Ff"><SUP>[7]</SUP></A>
the structures composing the
Video Format Configuration,
as described in
<CODE CLASS="Em">pxlibvs.h</CODE>
and
<CODE CLASS="Em">xclibvs.h</CODE>,
can be manipulated directly.
<P>
Alternately, using the SCF Style Interface
a video setup file can be
''loaded''
without re-opening XCLIB by using<A HREF="#Footnote 8"CLASS="Ff"><SUP>[8]</SUP></A>
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>.
<BR>
<A NAME="On Video State ID's"CLASS="Ch"></A>
<A NAME="1.5.11.  On Video State ID's"></A>
<H3>1.5.11.  On Video State ID's</H3>
<P>
<A NAME="Video State ID NX40"CLASS="NX"></A>
For efficiency, XCLIB maintains
copies of Video Format Configurations
and associates a unique
''video state id''
integer, greater than zero, with each.
Thereafter, the video state id may be used
to refer to the Video Format Configuration.
In XCLIB, the process of association is termed
''defining a video state''.
<BR>
<A NAME="On Error Codes"CLASS="Ch"></A>
<A NAME="1.5.12.  On Error Codes"></A>
<H3>1.5.12.  On Error Codes</H3>
<P>
Library functions return a common set of return codes,
indicating success or failure.
These codes are defined via inclusion of
<CODE CLASS="Em">xcliball.h</CODE>
with mnemonic names beginning with
''PXER''.
All error return codes are negative values.
Specific error conditions can be differentiated by
reading the definitions of these codes in
<CODE CLASS="Em">pxerrno.h</CODE>,
or by use of the
<A HREF="#pxd_mesgErrorCode"CLASS="Er">pxd_mesgErrorCode</A>
function.
<BR>
<A NAME="On Structures and Signatures"CLASS="Ch"></A>
<A NAME="1.5.13.  On Structures and Signatures"></A>
<H3>1.5.13.  On Structures and Signatures</H3>
<P>
Various structures which might change between versions
of XCLIB utilize a
''signature'',
so that an application compiled with an older
version of XCLIB can't declare an older, smaller, structure
and have it accepted by a newer library expecting a newer, larger, structure.
Structures that are changed typically define added fields
so that a zero value maintains the previous structure's effect.
<P>
Applications should initialize structures by zeroing
the entire structure to 0,
and setting the
<EM CLASS="Ep">ddch.len</EM>
and
<EM CLASS="Ep">ddch.cnt</EM>
to the size of the structure,
and to a signature constant,
respectively.
<A NAME="ddch.len NX41"CLASS="NX"></A>
<A NAME="ddch.cnt NX42"CLASS="NX"></A>
<A NAME="ddch.len"CLASS="Tr"></A>
<A NAME="ddch.cnt"CLASS="Tr"></A>
For example,
<BLOCKQUOTE>
<PRE>
    struct pxdevfault fault_structure;
<BR>
    memset(&amp;fault_structure, 0, sizeof(fault_structure));
    fault_structure.ddch.len = sizeof(fault_structure);
    fault_structure.ddch.mos = PXMOS_DEVFAULT;
</PRE>
</BLOCKQUOTE>
initializes the
<A HREF="#pxdevfault"CLASS="Er">pxdevfault</A>
structure.
<BR>
<A NAME="Common Structures"CLASS="Ch"></A>
<A NAME="1.6.  Common Structures"></A>
<H2>1.6.  Common Structures</H2>
<P>
Common structures are discussed below,
rather than repeatedly discussed with each function.
These concepts and data types are applicable
to the Structured Interface, and are not needed for
the SCF Style Interface.
Declaration of all structures
are automatically provided via inclusion of
<CODE CLASS="Em">xcliball.h</CODE>.
<P>
Most structures have an abbreviated name
<CITE CLASS="Ec">typedef</CITE>'ed.
These follow the convention of the structure's name
followed by
''_s''.
For example, either of:
<BLOCKQUOTE>
<PRE>
    struct  pxy     a_pair_of_xy_coordinates;
            pxy_s   another_pair_of_xy_coordinates;
</PRE>
</BLOCKQUOTE>
may be used.
<BR>
<A NAME="Coordinates, Images, and Image Window Structures"CLASS="Ch"></A>
<A NAME="1.6.1.  Coordinates, Images, and Image Window Structures"></A>
<H3>1.6.1.  Coordinates, Images, and Image Window Structures</H3>
<P>
The
<EM CLASS="Ep">pxy</EM>
struct provides a pair of x, y coordinates defining a point in two dimensions:
<A NAME="Struct pxy NX43"CLASS="NX"></A>
<A NAME="pxy, struct NX44"CLASS="NX"></A>
<A NAME="pxy_s NX45"CLASS="NX"></A>
<A NAME="pxypoint_s NX46"CLASS="NX"></A>
<A NAME="pxy"CLASS="Tr"></A>
<A NAME="pxy_s"CLASS="Tr"></A>
<A NAME="pxypoint_s"CLASS="Tr"></A>
<BLOCKQUOTE>
<PRE>
struct pxy {
    pxcoord_t   x;
    pxcoord_t   y;
};
typedef struct pxy pxy_s;
typedef struct pxy pxypoint_s;
</PRE>
</BLOCKQUOTE>
The
<EM CLASS="Ep">pxyz</EM>
struct provides a triplet of x, y, z coordinates
defining a point in three dimensions:
<A NAME="Struct pxyz NX47"CLASS="NX"></A>
<A NAME="pxyz, struct NX48"CLASS="NX"></A>
<A NAME="pxyz_s NX49"CLASS="NX"></A>
<A NAME="pxypointz_s NX50"CLASS="NX"></A>
<A NAME="pxyz"CLASS="Tr"></A>
<A NAME="pxyz_s"CLASS="Tr"></A>
<A NAME="pxyzpoint_s"CLASS="Tr"></A>
<BLOCKQUOTE>
<PRE>
struct pxyz {
    pxcoord_t   x;
    pxcoord_t   y;
    pxcoord_t   z;
};
typedef struct pxyz pxyz_s;
typedef struct pxyz pxyzpoint_s;
</PRE>
</BLOCKQUOTE>
<P>
The
<EM CLASS="Ep">pxywindow</EM>
struct provides a pair of x, y coordinates defining a rectangle in two dimensions:
<A NAME="Struct pxywindow NX51"CLASS="NX"></A>
<A NAME="pxywindow, struct NX52"CLASS="NX"></A>
<A NAME="pxywindow_s NX53"CLASS="NX"></A>
<A NAME="pxywindow_s"CLASS="Tr"></A>
<A NAME="pxywindow"CLASS="Tr"></A>
<BLOCKQUOTE>
<PRE>
struct pxywindow {
    struct  pxy nw;   // north west corner inclusive
    struct  pxy se;   // south east corner, usually exclusive
};
typedef struct pxywindow pxywindow_s;
</PRE>
</BLOCKQUOTE>
The
<EM CLASS="Ep">pxyzwindow</EM>
struct provides a pair of x, y, z coordinates defining a rectangle in three dimensions:
<A NAME="Struct pxyzwindow NX54"CLASS="NX"></A>
<A NAME="pxyzwindow, struct NX55"CLASS="NX"></A>
<A NAME="pxyzwindow_s NX56"CLASS="NX"></A>
<A NAME="pxyzwindow"CLASS="Tr"></A>
<A NAME="pxyzwindow_s"CLASS="Tr"></A>
<BLOCKQUOTE>
<PRE>
struct pxyzwindow {
    struct  pxyz nw;  // north west corner inclusive
    struct  pxyz se;  // south east corner, usually exclusive
};
typedef struct pxywindow pxyzwindow_s;
</PRE>
</BLOCKQUOTE>
<P>
The
<EM CLASS="Ep">pximage</EM>
struct is used as an object<A HREF="#Footnote 9"CLASS="Ff"><SUP>[9]</SUP></A> defining:
(a)&nbsp;An image,
(b)&nbsp;The dimensions of the image,
(c)&nbsp;A rectangular area of interest,
(d)&nbsp;The means of accessing the image,
(e)&nbsp;Other parameters for internal use.
The
<EM CLASS="Ep">pximage</EM>
must be initialized<A HREF="#Footnote 10"CLASS="Ff"><SUP>[10]</SUP></A>
using a provided function, such as
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
or
<A HREF="#::initPximage"CLASS="Er">::initPximage</A>.
<P>
The following abstract of the
<EM CLASS="Ep">pximage</EM>
shows some of the fields
of interest to the application programmer.
<A NAME="Struct pximage NX57"CLASS="NX"></A>
<A NAME="pximage, struct NX58"CLASS="NX"></A>
<A NAME="pximage_s NX59"CLASS="NX"></A>
<A NAME="pximage"CLASS="Tr"></A>
<A NAME="pximage_s"CLASS="Tr"></A>
<BLOCKQUOTE>
<PRE>
struct pximage {
    struct  pxywindow imdim; // nw.x = nw.y = 0. se.x &amp; se.y is dimension of image
    struct  pxywindow wind;  // subwindow within imdim
        ...         ...
};
typedef struct pximage pximage_s;
</PRE>
</BLOCKQUOTE>
The
<EM CLASS="Ep">pximage</EM>.<EM CLASS="Ep">imdim</EM>
provides the image's dimensions.
The
<EM CLASS="Ep">pximage</EM>.<EM CLASS="Ep">wind</EM>
defines an area of interest within the image; the
<EM CLASS="Ep">pximage</EM>.<EM CLASS="Ep">wind</EM>
may be directly altered by the application programmer.
<P>
Similarly, the
<EM CLASS="Ep">pximage3</EM>
defines a sequence of images
(or depending on point of view, a three-dimensional image),
and means of access.
The following abstract of the
<EM CLASS="Ep">pximage3</EM>
shows some of the fields
of interest to the application programmer.
<A NAME="Struct pximage3 NX60"CLASS="NX"></A>
<A NAME="pximage3, struct NX61"CLASS="NX"></A>
<A NAME="pximage3_s NX62"CLASS="NX"></A>
<A NAME="pximage3"CLASS="Tr"></A>
<A NAME="pximage3_s"CLASS="Tr"></A>
<BLOCKQUOTE>
<PRE>
struct pximage3 {
    struct  pxyzwindow imdim; // nw.x = nw.y = nw.z = 0. se.x, se.y &amp; se.z is dimension of image
    struct  pxyzwindow wind;  // subwindow within imdim
        ...         ...
};
typedef struct pximage3 pximage3_s;
</PRE>
</BLOCKQUOTE>
<BR>
<A NAME="Imaging Board, Driver, and Video Format Configuration Structures"CLASS="Ch"></A>
<A NAME="1.6.2.  Imaging Board, Driver, and Video Format Configuration Structures"></A>
<H3>1.6.2.  Imaging Board, Driver, and Video Format Configuration Structures</H3>
<P>
The structures used for access to and control of the
imaging board(s), driver, and Video Format Configuration
are listed.
Each structure is declared and described in the specified file.
<A NAME="Struct pxddch NX63"CLASS="NX"></A>
<A NAME="Struct pxvidstate NX64"CLASS="NX"></A>
<A NAME="Struct pxvidformat NX65"CLASS="NX"></A>
<A NAME="Struct pxvidimage NX66"CLASS="NX"></A>
<A NAME="Struct pxviddim NX67"CLASS="NX"></A>
<A NAME="Struct pxvidres NX68"CLASS="NX"></A>
<A NAME="Struct pxvidphys NX69"CLASS="NX"></A>
<A NAME="Struct pxvidmode NX70"CLASS="NX"></A>
<A NAME="Struct pxvidopt NX71"CLASS="NX"></A>
<A NAME="Struct pxvidmem NX72"CLASS="NX"></A>
<A NAME="Struct pxcamcntl NX73"CLASS="NX"></A>
<A NAME="Struct xcsv2format NX74"CLASS="NX"></A>
<A NAME="Struct xcsv2mode NX75"CLASS="NX"></A>
<A NAME="Struct xcdxxformat NX76"CLASS="NX"></A>
<A NAME="Struct pxdevinfo NX77"CLASS="NX"></A>
<A NAME="Struct xcdevinfo NX78"CLASS="NX"></A>
<A NAME="Struct xcdevparms NX79"CLASS="NX"></A>
<A NAME="Struct pxtimestamp NX80"CLASS="NX"></A>
<A NAME="Struct pxvidstatus NX81"CLASS="NX"></A>
<A NAME="Struct xcvidstatus NX82"CLASS="NX"></A>
<A NAME="Struct pxdevfault NX83"CLASS="NX"></A>
<A NAME="Struct pximagebuf NX84"CLASS="NX"></A>
<A NAME="Struct pximage3buf NX85"CLASS="NX"></A>
<A NAME="Struct pxtrigspec NX86"CLASS="NX"></A>
<A NAME="Struct xclibs NX87"CLASS="NX"></A>
<A NAME="Struct pxdevservice NX88"CLASS="NX"></A>
<A NAME="Struct pxauxservice NX89"CLASS="NX"></A>
<A NAME="Struct xcdevservice NX90"CLASS="NX"></A>
<A NAME="Struct xclibservice NX91"CLASS="NX"></A>
<A NAME="Struct pxbufstatus NX92"CLASS="NX"></A>
<A NAME="pxddch, struct NX93"CLASS="NX"></A>
<A NAME="pxvidstate, struct NX94"CLASS="NX"></A>
<A NAME="pxvidformat, struct NX95"CLASS="NX"></A>
<A NAME="pxvidimage, struct NX96"CLASS="NX"></A>
<A NAME="pxviddim, struct NX97"CLASS="NX"></A>
<A NAME="pxvidres, struct NX98"CLASS="NX"></A>
<A NAME="pxvidphys, struct NX99"CLASS="NX"></A>
<A NAME="pxvidmode, struct NX100"CLASS="NX"></A>
<A NAME="pxvidopt, struct NX101"CLASS="NX"></A>
<A NAME="pxvidmem, struct NX102"CLASS="NX"></A>
<A NAME="pxcamcntl, struct NX103"CLASS="NX"></A>
<A NAME="xcsv2format, struct NX104"CLASS="NX"></A>
<A NAME="xcsv2mode, struct NX105"CLASS="NX"></A>
<A NAME="xcdxxformat, struct NX106"CLASS="NX"></A>
<A NAME="pxdevinfo, struct NX107"CLASS="NX"></A>
<A NAME="xcdevinfo, struct NX108"CLASS="NX"></A>
<A NAME="xcdevparms, struct NX109"CLASS="NX"></A>
<A NAME="pxtimestamp, struct NX110"CLASS="NX"></A>
<A NAME="pxvidstatus, struct NX111"CLASS="NX"></A>
<A NAME="xcvidstatus, struct NX112"CLASS="NX"></A>
<A NAME="pxdevfault, struct NX113"CLASS="NX"></A>
<A NAME="pximagebuf, struct NX114"CLASS="NX"></A>
<A NAME="pximage3buf, struct NX115"CLASS="NX"></A>
<A NAME="pxtrigspec, struct NX116"CLASS="NX"></A>
<A NAME="xclibs, struct NX117"CLASS="NX"></A>
<A NAME="pxdevservice, struct NX118"CLASS="NX"></A>
<A NAME="pxauxservice, struct NX119"CLASS="NX"></A>
<A NAME="xcdevservice, struct NX120"CLASS="NX"></A>
<A NAME="xclibservice, struct NX121"CLASS="NX"></A>
<A NAME="pxbufstatus, struct NX122"CLASS="NX"></A>
<A NAME="pxddch_s NX123"CLASS="NX"></A>
<A NAME="pxvidstate_s NX124"CLASS="NX"></A>
<A NAME="pxvidformat_s NX125"CLASS="NX"></A>
<A NAME="pxvidimage_s NX126"CLASS="NX"></A>
<A NAME="pxviddim_s NX127"CLASS="NX"></A>
<A NAME="pxvidres_s NX128"CLASS="NX"></A>
<A NAME="pxvidphys_s NX129"CLASS="NX"></A>
<A NAME="pxvidmode_s NX130"CLASS="NX"></A>
<A NAME="pxvidopt_s NX131"CLASS="NX"></A>
<A NAME="pxvidmem_s NX132"CLASS="NX"></A>
<A NAME="pxcamcntl_s NX133"CLASS="NX"></A>
<A NAME="xcsv2format_s NX134"CLASS="NX"></A>
<A NAME="xcsv2mode_s NX135"CLASS="NX"></A>
<A NAME="xcdxxformat_s NX136"CLASS="NX"></A>
<A NAME="pxdevinfo_s NX137"CLASS="NX"></A>
<A NAME="xcdevinfo_s NX138"CLASS="NX"></A>
<A NAME="xcdevparms_s NX139"CLASS="NX"></A>
<A NAME="pxtimestamp_s NX140"CLASS="NX"></A>
<A NAME="pxvidstatus_s NX141"CLASS="NX"></A>
<A NAME="xcvidstatus_s NX142"CLASS="NX"></A>
<A NAME="pxdevfault_s NX143"CLASS="NX"></A>
<A NAME="pximagebuf_s NX144"CLASS="NX"></A>
<A NAME="pximage3buf_s NX145"CLASS="NX"></A>
<A NAME="pxtrigspec_s NX146"CLASS="NX"></A>
<A NAME="xclibs_s NX147"CLASS="NX"></A>
<A NAME="pxdevservice_s NX148"CLASS="NX"></A>
<A NAME="pxauxservice_s NX149"CLASS="NX"></A>
<A NAME="xcdevservice_s NX150"CLASS="NX"></A>
<A NAME="xclibservice_s NX151"CLASS="NX"></A>
<A NAME="pxbufstatus_s NX152"CLASS="NX"></A>
<A NAME="pxddch"CLASS="Tr"></A>
<A NAME="pxvidstate"CLASS="Tr"></A>
<A NAME="pxvidformat"CLASS="Tr"></A>
<A NAME="pxvidimage"CLASS="Tr"></A>
<A NAME="pxviddim"CLASS="Tr"></A>
<A NAME="pxvidres"CLASS="Tr"></A>
<A NAME="pxvidphys"CLASS="Tr"></A>
<A NAME="pxvidmode"CLASS="Tr"></A>
<A NAME="pxvidopt"CLASS="Tr"></A>
<A NAME="pxvidmem"CLASS="Tr"></A>
<A NAME="pxcamcntl"CLASS="Tr"></A>
<A NAME="xcsv2format"CLASS="Tr"></A>
<A NAME="xcsv2mode"CLASS="Tr"></A>
<A NAME="xcdxxformat"CLASS="Tr"></A>
<A NAME="pxdevinfo"CLASS="Tr"></A>
<A NAME="xcdevinfo"CLASS="Tr"></A>
<A NAME="xcdevparms"CLASS="Tr"></A>
<A NAME="pxtimestamp"CLASS="Tr"></A>
<A NAME="pxvidstatus"CLASS="Tr"></A>
<A NAME="xcvidstatus"CLASS="Tr"></A>
<A NAME="pxdevfault"CLASS="Tr"></A>
<A NAME="pximagebuf"CLASS="Tr"></A>
<A NAME="pximage3buf"CLASS="Tr"></A>
<A NAME="pxtrigspec"CLASS="Tr"></A>
<A NAME="xclibs"CLASS="Tr"></A>
<A NAME="pxdevservice"CLASS="Tr"></A>
<A NAME="pxauxservice"CLASS="Tr"></A>
<A NAME="xcdevservice"CLASS="Tr"></A>
<A NAME="xclibservice"CLASS="Tr"></A>
<A NAME="pxbufstatus"CLASS="Tr"></A>
<A NAME="pxddch_s"CLASS="Tr"></A>
<A NAME="pxvidstate_s"CLASS="Tr"></A>
<A NAME="pxvidformat_s"CLASS="Tr"></A>
<A NAME="pxvidimage_s"CLASS="Tr"></A>
<A NAME="pxviddim_s"CLASS="Tr"></A>
<A NAME="pxvidres_s"CLASS="Tr"></A>
<A NAME="pxvidphys_s"CLASS="Tr"></A>
<A NAME="pxvidmode_s"CLASS="Tr"></A>
<A NAME="pxvidopt_s"CLASS="Tr"></A>
<A NAME="pxvidmem_s"CLASS="Tr"></A>
<A NAME="pxcamcntl_s"CLASS="Tr"></A>
<A NAME="xcsv2format_s"CLASS="Tr"></A>
<A NAME="xcsv2mode_s"CLASS="Tr"></A>
<A NAME="xcdxxformat_s"CLASS="Tr"></A>
<A NAME="pxdevinfo_s"CLASS="Tr"></A>
<A NAME="xcdevinfo_s"CLASS="Tr"></A>
<A NAME="xcdevparms_s"CLASS="Tr"></A>
<A NAME="pxtimestamp_s"CLASS="Tr"></A>
<A NAME="pxvidstatus_s"CLASS="Tr"></A>
<A NAME="xcvidstatus_s"CLASS="Tr"></A>
<A NAME="pxdevfault_s"CLASS="Tr"></A>
<A NAME="pximagebuf_s"CLASS="Tr"></A>
<A NAME="pximage3buf_s"CLASS="Tr"></A>
<A NAME="pxtrigspec_s"CLASS="Tr"></A>
<A NAME="xclibs_s"CLASS="Tr"></A>
<A NAME="pxdevservice_s"CLASS="Tr"></A>
<A NAME="pxauxservice_s"CLASS="Tr"></A>
<A NAME="xcdevservice_s"CLASS="Tr"></A>
<A NAME="xclibservice_s"CLASS="Tr"></A>
<A NAME="pxbufstatus_s"CLASS="Tr"></A>
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
Structure   
</TD>
<TD ALIGN="left" COLSPAN="1">
                             
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
Name        
</TD>
<TD ALIGN="left" COLSPAN="1">
 Use                         
</TD>
<TD ALIGN="left" COLSPAN="1">
 File
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxddch      
</TD>
<TD ALIGN="left" COLSPAN="1">
 Version signatures          
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR><TD COLSPAN="3"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidstate  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Video Format Configuration  
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidformat 
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidimage  
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxviddim    
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidres    
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidphys   
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidmode   
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidopt    
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidmem    
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxcamcntl   
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xcsv2format 
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 xclibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xcsv2mode   
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 xclibvs.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xcdxxformat 
</TD>
<TD ALIGN="left" COLSPAN="1">
 ..  substructure            
</TD>
<TD ALIGN="left" COLSPAN="1">
 xclibvs.h
</TD>
</TR>
<TR><TD COLSPAN="3"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxbufstatus 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Buffer status               
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxdevinfo   
</TD>
<TD ALIGN="left" COLSPAN="1">
 Driver and board info       
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxdevfault  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Logged fault                
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pximagebuf  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Non-frame image buffer      
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pximage3buf 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Non-frame image buffers     
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxtimestamp 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Time stamp                  
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxtrigspec  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Trigger specification       
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxvidstatus 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Video and capture status    
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xcdevinfo   
</TD>
<TD ALIGN="left" COLSPAN="1">
 Extended driver and board info 
</TD>
<TD ALIGN="left" COLSPAN="1">
 xclibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xcdevparms  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Driver configuration        
</TD>
<TD ALIGN="left" COLSPAN="1">
 xclibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xcvidstatus 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Extended video and capture status 
</TD>
<TD ALIGN="left" COLSPAN="1">
 xclibsv.h
</TD>
</TR>
<TR><TD COLSPAN="3"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xclibs      
</TD>
<TD ALIGN="left" COLSPAN="1">
 Access to XCLIB services    
</TD>
<TD ALIGN="left" COLSPAN="1">
 xclibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxauxservice
</TD>
<TD ALIGN="left" COLSPAN="1">
 .. substructure             
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
pxdevservice
</TD>
<TD ALIGN="left" COLSPAN="1">
 .. substructure             
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xcdevservice
</TD>
<TD ALIGN="left" COLSPAN="1">
 .. substructure             
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
xclibservice
</TD>
<TD ALIGN="left" COLSPAN="1">
 .. substructure             
</TD>
<TD ALIGN="left" COLSPAN="1">
 pxlibsv.h
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
<HR SIZE="3">
<A NAME="Installation and Configuration &mdash; Run Time"CLASS="Ch"></A>
<A NAME="2.  Installation and Configuration &mdash; Run Time"></A>
<H1>2.  Installation and Configuration &mdash; Run Time</H1>
<P>
The following installation instructions are oriented
to the application program developer, following
installation of the library files, as described above.
Application programs intended for distribution to third parties
must be provided with the appropriate run time support modules
and suitable installation instructions.
The entire XCLIB distribution is not required for
third parties using application programs,
and is normally
<U CLASS="U">not</U>
licensed for distribution to third parties.
<BR>
<A NAME="Driver Configuration Parameters"CLASS="Ch"></A>
<A NAME="2.1.  Driver Configuration Parameters"></A>
<H2>2.1.  Driver Configuration Parameters</H2>
<A NAME="Driver Configuration Parameter"CLASS="Tr"></A>
<P>
Configuration parameters can be
specified in a Driver Configuration Parameter string which is passed to
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>;
or, depending upon the run time environment (see below),
specified in an alternate manner.
<P>
<A NAME="Driver Configuration Parameters NX153"CLASS="NX"></A>
The Driver Configuration Parameter string may contain any of the
following parameters, separated by spaces, in any order.
Each parameter's flag is followed by a number,
whose value is interpreted as hexadecimal if preceded by
''0x''
or
''0X'',
octal if preceded by
''0o''
or
''0O'',
binary if preceded by
''0b''
or
''0B'',
and is otherwise interpreted as decimal.
<DL>
<BR><DT>-IM <I>n</I><DD>
Requested size, in Kbyte, to be reserved for the entire
image frame buffer memory.
Default: 16384&nbsp;Kbyte under Windows NT, 2000, XP, and Server 2003,
4096&nbsp;Kbyte for others.
<P>
For the PIXCI&reg; CL3SD which has on-board frame buffer memory,
memory reserved by this parameter is needed only for support of
<A HREF="#pxd_buffersFieldCount"CLASS="Er">pxd_buffersFieldCount</A>,
<A HREF="#pxd_buffersSysTicks"CLASS="Er">pxd_buffersSysTicks</A>,
<A HREF="#pxd_buffersGPIn"CLASS="Er">pxd_buffersGPIn</A>,
and
<A HREF="#::goingBufStatus"CLASS="Er">::goingBufStatus</A>.
Currently, 64 bytes are needed for each frame buffer.
Default: 4096&nbsp;Kbyte.
<BR><DT>-XU <I>n</I><DD>
If &ne;0, allow other applications
to share use of imaging boards previously
opened for use by the first application.
Not currently supported.
Default: 0.
<BR><DT>-XM <I>n</I><DD>
If &ne;0, reserve the proportionate share of image frame buffer
memory for imaging boards not opened by the first application,
for use with other imaging boards opened later.
If 0, all image frame buffer memory is shared
amongst the imaging boards opened by the first application.
Affects PIXCI&reg; imaging boards other than CL3SD,
which has on-board frame buffer memory.
Default: 1.
<BR><DT>-PO <I>n</I><DD>
If &ne;0, the polling period, in &micro;seconds, for
driver features that are not driven by an interrupt.
Ignored under Tenberry DOS4GW DOS extender.
Default: 5000 &micro;seconds.
<BR><DT>-MB <I>n</I><DD>
If &ne;0,
the image frame buffer memory, of size
specified by
''-IM'',
is split into partitions of this size.
Depending on operating system and
''-IA''
parameters, this may imply that each partition is
individually allocated, so that a larger,
total amount of memory can be allocated.
Or that the contiguous memory
is treated as individual partitions for the sake
of the operating system and processor's virtual memory
management, which could not otherwise
''map''
the entire frame buffer memory at once.
In either case, (a)&nbsp;A single frame buffer can't
extend across partitions;,
(b)&nbsp;The partition size should be
a multiple of the frame buffer size so as to maximize the
number of buffers and minimize wasted space, and
(c)&nbsp;A maximum of 256 partitions is supported.
Default: 0.
<BR><DT>-MH <I>n</I><DD>
If &ne;0,
the amount of lower memory to pass over
before allocating the requested
image frame buffer memory.
This may be necessary for use with some graphics display (S/VGA) or
network interface cards which,
a)&nbsp;May be allocating memory after the PIXCI(rg driver,
and b)&nbsp;May require memory with lower addresses.
Only used with non-forceful image frame buffer allocation,
under Windows NT, 2000, XP, and Server 2003.
Default: 0.
<BR><DT>-IA <I>n</I><DD>
If &ne;0,
the physical address of memory at which image
frame buffers are assumed to start.
Only used with forceful image frame buffer allocation,
under Windows 95, 98, ME, NT, 2000, XP, Server 2003,
and Linux.
Default: 0.
<BR><DT>-QP <I>n</I><DD>
If &ne;0, an assigned auxiliary interrupt
number (not IRQ number!)
within Tenberry's range of auto pass-up interrupts: 0x08 to 0x2E.
Only used with the Tenberry DOS4GW DOS extender.
Default: 0.
<BR><DT>-DM <I>n</I><DD>
A bit map selecting which of the PIXCI&reg; imaging boards
present should be used.
The
<EM CLASS="Ep">i'th</EM>
bit of the bit-map selects the
<EM CLASS="Ep">i</EM>'th
board found, sequentially, on the PCI bus.
The relationship between bit
<EM CLASS="Ep">i</EM>
and the order of motherboard slots is
motherboard, BIOS, and OS dependent and can neither be specified
nor interrogated via XCLIB.
<P>
For example, 0x01 selects the first board, 0x04 selects
the third board, and 0b1001 selects the first and fourth board.
After the library is open, the customary
<EM CLASS="Ep">unitmap</EM>
function parameter selects
<U CLASS="U">logical</U>
boards, not
<U CLASS="U">physical</U>
boards.
Thus, while
<EM CLASS="Ep">-DM 0x0A</EM>
selects use of the second and fourth
physical PIXCI&reg; imaging boards, the
<EM CLASS="Ep">unitmap</EM>
would be 0x01 to select the first logical (second physical),
0x02 to select the second logical (fourth physical),
or 0x03 to select the first and second logical (second and fourth physical)
imaging board(s).
Default: 1.
<BR><DT>-MO <I>n</I><DD>
To be described.
Default: 0.
<BR><DT>-QU <I>n</I><DD>
If &ne;0, utilize the imaging boards' hardware interrupts.
For PIXCI&reg; SV4, SV5, SV5A, D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, A, SI, and CL3SD imaging boards,
the interrupt may be disabled if the polling period (-PO)
is small relative to a field's period.
For PIXCI&reg; SV2 and SV3, disabling the interrupt
will adversely affect all capture modes other than snap.
For PIXCI&reg; D, D24, D32, the interrupt may be disabled
only if the interrupt is not shared.
For all PIXCI&reg; imaging boards operated under Tenberry DOS4GW DOS extender,
use of hardware interrupts is required.
Disabling use of interrupts is intended primarily for diagnosing
interrupt conflicts, and is not recommended.
Default: 1.
<BR><DT>-QS <I>n</I><DD>
If &ne;0, allow sharing the imaging boards' assigned hardware interrupt
with other devices.
Ignored under Tenberry DOS4GW DOS extender and Linux.
Default: 1.
<BR><DT>-MU <I>n</I><DD>
If bit 0x01 is not set, the frame buffer memory is not mapped
directly into the application's address space.
If bit 0x02 is set, the frame buffer memory is not
permanently mapped into the driver's address space.
These options minimize use of the operating systems memory management
resources, but may increase overhead in accessing frame buffer memory.
These options are typically required when using very large
amounts of frame buffer memory
(typically, more than 1 or 2 Gbyte under under Windows NT, 2000, XP, and Server 2003,
or more than a few hundred Mbyte under Windows 95/98/ME),
but are not currently supported for all Video Format Configurations.
Default: 1.
<BR><DT>-WT <I>n</I><DD>
If bits 0x05 are set to 0x01 or to 0x05,
alternate methods of Windows NT resource allocation are used,
avoiding problems seen on some motherboards where the same resources
are assigned to multiple imaging boards.
Only used with Windows NT.
<P>
If bit 0x20 is set, a high resolution kernel timer is used
for time stamping video events.
Windows documentation states that use of this timer incurs
additional overhead.
Only used with Window NT, 2000, XP, and Server 2003.
<P>
Other bits to be described.
Default: 0.
<BR><DT>-SV5 <I>n</I><DD>
Setting bit 0x02 enables compatibility with 430FX PCI controllers.
Setting bit 0x04 enables compatibility with VIA/SIS PCI controllers.
<P>
Default: 0.
<BR><DT>-SV6 <I>n</I><DD>
Setting bit 0x08 enables compatibility with VIA/SIS PCI controllers.
<P>
Default: 0.
<BR><DT>-I2C <I>n</I><DD>
Bit rate of the I<SUB><SMALL>2</SMALL></SUB>C or two wire serial bus used within
some PIXCI&reg; imaging boards.
Specifies an upper bound for the bit rate; actual bit rate
is dependent on PC characteristics and is typically slower.
Value of 0 selects predefined, board-dependent, default values.
<P>
Particularly useful for use with SILICON VIDEO&reg; camera heads;
at the time of writing all (2112(C), 1310(C), 1281(C), 9M001(C), 9T001, and 642)
SILICON VIDEO&reg; camera heads use a I<SUB><SMALL>2</SMALL></SUB>C or two wire serial bus
to control camera head features.
<P>
Does
<U CLASS="U">not</U>
affect the serial baud rate of Camera Link compatible imaging boards.
<P>
Default: 0.
</DL>
<BR>
<A NAME="Windows 95/98/ME Environment"CLASS="Ch"></A>
<A NAME="2.2.  Windows 95/98/ME Environment"></A>
<H2>2.2.  Windows 95/98/ME Environment</H2>
<P>
The EPIXXCW5.VXD driver, the
XCLIBW95.DLL, and the PXIPLW95.DLL
if the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
is used,
must be installed in order to
operate any application program using XCLIB.
<P>
Typically, XCAP is used to install the driver, specify
frame buffer memory allocation, specify other
Driver Configuration Parameters, and verify proper operation;
these settings are then available to the XCLIB program.
The options in XCAP's:
<BLOCKQUOTE>
<PRE>
    PIXCI
    PIXCI Open/Close
    Advanced
</PRE>
</BLOCKQUOTE>
directly correspond to the Driver Configuration Parameters.
Alternately, the details of manual
installation of the
EPIXXCW5.VXD driver
and specification of frame buffer memory allocation,
are described in the
<CITE CLASS="Ec">XCAP Reference Manual</CITE>
and also the
<CITE CLASS="Ec">PIXCI&reg; User's Manual</CITE>.
<P>
Driver Configuration Parameters
may be specified in the Windows'
SYSTEM.INI file:
<BLOCKQUOTE>
<PRE>
[EPIX_XC]
PIXCI=&lt;DriverConfigurationParameters&gt;
</PRE>
</BLOCKQUOTE>
Windows must be rebooted for the new specification to take effect.
<P>
The
''-IM'',
''-MH'',
''-IA'',
and
''-MB''
parameters are effective only when specified in
SYSTEM.INI, and can't be specified with
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>.
<P>
The
XCLIBW95.DLL, and the PXIPLW95.DLL
if the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
is used,
must be available in order to
operate any application program using XCLIB, such as by placing the
DLL(s) in the same directory as the application program,
or by placing the DLL(s) in the Windows directory.
<P>
Frame buffer memory is allocated once during Windows initialization;
the contents of frame buffer memory is retained as the driver is closed and opened,
but lost if Windows is restarted.
<BR>
<A NAME="Windows NT/2000/XP/Server2003 Environment"CLASS="Ch"></A>
<A NAME="2.3.  Windows NT/2000/XP/Server2003 Environment"></A>
<H2>2.3.  Windows NT/2000/XP/Server2003 Environment</H2>
<P>
The EPIXXCWT.SYS driver for Windows NT or the
EPIXXCW2.SYS driver for Windows&nbsp;2000, XP, and Server 2003,
the
XCLIBWNT.DLL, and the PXIPLWNT.DLL
if the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
is used,
must be installed in order to
operate any application program using XCLIB.
<P>
Typically, XCAP is used to install the driver, specify
frame buffer memory allocation, specify other
Driver Configuration Parameters, and verify proper operation;
these settings are then available to the XCLIB program.
The options in XCAP's:
<BLOCKQUOTE>
<PRE>
    PIXCI
    PIXCI Open/Close
    Advanced
</PRE>
</BLOCKQUOTE>
directly correspond to the Driver Configuration Parameters.
Alternately, the details of manual
installation of the
EPIXXCWT.SYS or EPIXXCW2.SYS driver
and specification of frame buffer memory allocation,
are described in the
<CITE CLASS="Ec">XCAP Reference Manual</CITE>
and also the
<CITE CLASS="Ec">PIXCI&reg; User's Manual</CITE>.
<P>
Driver Configuration Parameters
may be specified in the Windows&nbsp;NT
registry:
<PRE>
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EPIXXCWT
    PIXCI   =  &lt;DriverConfigurationParameters&gt;
</PRE>
or the Windows&nbsp;2000, XP, and Server 2003 registry:
<PRE>
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EPIXXCW2
    PIXCI   =  &lt;DriverConfigurationParameters&gt;
</PRE>
Windows must be rebooted for the new specification to take effect.
<P>
The
''-IM'',
''-MH'',
and
''-MB''
parameters are effective only when specified in the Windows registry,
and can't be specified with
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>.
<P>
The
XCLIBWNT.DLL, and the PXIPLWNT.DLL
if the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
is used,
must be available in order to
operate any application program using XCLIB, such as by placing the
DLL(s) in the same directory as the application program,
or by placing the DLL(s) in the Windows directory.
<P>
Frame buffer memory is allocated once during Windows initialization;
the contents of frame buffer memory is retained as the driver is closed and opened,
but lost if Windows is restarted.
<BR>
<A NAME="Tenberry DOS4GW DOS Extender Environment"CLASS="Ch"></A>
<A NAME="2.4.  Tenberry DOS4GW DOS Extender Environment"></A>
<H2>2.4.  Tenberry DOS4GW DOS Extender Environment</H2>
<P>
No run time module is needed for execution of
application programs in the Watcom/DOS4GW environment.
<P>
<A NAME="EMM386 NX154"CLASS="NX"></A>
It is suggested that
EMM386.SYS be removed from C:\CONFIG.SYS and
<U CLASS="U">not</U>
be used with XCLIB, as it significantly slows hardware interrupts.
Also, according to the manufacturer of DOS4GW,
some versions of EMM386.SYS have bugs that affect the operation of DOS4GW.
<P>
Frame buffer memory is allocated
when
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>
is invoked;
the contents of frame buffer memory is lost
when XCLIB is closed.
<BR>
<A NAME="Linux &amp; Intel 80x86 Environment"CLASS="Ch"></A>
<A NAME="2.5.  Linux &amp; Intel 80x86 Environment"></A>
<H2>2.5.  Linux &amp; Intel 80x86 Environment</H2>
<P>
The
''pixci_i386.o''
(for 2.4 kernels)
or
''pixci_i386.ko''
(for 2.6 kernels)
loadable driver must be installed by
<CITE CLASS="Ec">insmod</CITE>
in order to operate any application program using XCLIB.
<P>
Driver Configuration Parameters
may be specified as an option to
<CITE CLASS="Ec">insmod</CITE>,
by assignation to module parameter
''PIXCIPARM'',
such as:
<PRE>
    insmod -o pixci [ -force ] pixci_i386.o  [ PIXCIPARM=&lt;driver_config_parameters&gt; ]
</PRE>
or
<PRE>
    insmod pixci_i386.ko [ PIXCIPARM=&lt;driver_config_parameters&gt; ]
</PRE>
Some versions of
<CITE CLASS="Ec">insmod</CITE>
under 2.6 kernels object to quoted spaces in the Driver Configuration Parameters;
an underscore (i.e.
''_'')
may be used instead of a space.
<P>
The
''-IM''
and
''-MB''
parameters are effective only when specified with
<CITE CLASS="Ec">insmod</CITE>,
and can't be specified with
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>.
<P>
Frame buffer memory is allocated
when the
''pixci_i386.o''
or
''pixci_i386.ko''
is loaded;
the contents of frame buffer memory is lost
when
''pixci_i386.o''
or
''pixci_i386.ko''
is unloaded.
<HR SIZE="3">
<A NAME="SCF Style Interface"CLASS="Ch"></A>
<A NAME="3.  SCF Style Interface"></A>
<H1>3.  SCF Style Interface</H1>
<P>
The so-called
Simple ``C'' Function
Style Interface provides sufficient services
for most common applications using a single imaging board,
or using multiple, identical, imaging boards,
or using one or more identical imaging boards
each with multiple functional units.
<P>
The SCF style interface differs from the non-SCF functions
in several regards.
First, the SCF functions do not (explicitly) use structures
and minimize the use of pointers.
These functions can be easily used by casual ``C'' programmers,
and invoked from languages other than ``C'', such as Visual Basic,
Borland Delphi, LabView, or any other
Windows programming environment that allows
calling an arbitrary function in an arbitrary DLL.
In contrast, the non-SCF functions provide a
''structured''
and
''object oriented''
interface, providing easier use for more advanced C/C++ programmers.
<P>
Second, the SCF functions do not allow low level changes
to the video format configuration.
Rather, the video format configuration is
either chosen from the predefined selections,
or loaded from a video format file,<A HREF="#Footnote 11"CLASS="Ff"><SUP>[11]</SUP></A>
previously saved by the XCAP application.
In contrast, the non-SCF functions provide full access to all of the
dozens of parameters with which the video format configuration
can be customized.
<P>
Third, while the SCF functions support multiple imaging boards,
or imaging boards with multiple functional units,
the boards or units must be identical and configured
for the same video format and resolution.
In contrast, the non-SCF functions
support multiple identical imaging boards and functional units with
independent video format and resolution,
or by opening multiple instances of the library
the non-SCF functions support access to multiple, non-identical,
imaging boards.<A HREF="#Footnote 12"CLASS="Ff"><SUP>[12]</SUP></A>
<P>
Fourth, the SCF functions share common names
with libraries for other families of EPIX, Inc. imaging boards.
This allows easier porting of application programs
from one board family to another, but complicates
using boards from both families within the same program.
In contrast, the non-SCF functions do not share common
names with libraries for other families of EPIX, Inc. imaging boards,
requiring additional editing of source code when
porting the application program.
<P>
The SCF functions are not intended to be used in conjunction
with non-SCF functions; though upon advice of EPIX, Inc, Technical Support,
the
<A HREF="#pxd_xclibEscape"CLASS="Er">pxd_xclibEscape</A>
and
<A HREF="#pxd_xclibEscaped"CLASS="Er">pxd_xclibEscaped</A>
functions
can be used in special circumstances.<A HREF="#Footnote 13"CLASS="Ff"><SUP>[13]</SUP></A>
<P>
The source for many of the SCF function
''wrappers''
for programmers
wishing to understand their manner of implementation
in terms of the non-SCF functions,
is available from EPIX, Inc. Technical Support.
<HR SIZE="1">
<A NAME="pxd_buffersFieldCount NX155"CLASS="NX"></A>
<A NAME="pxd_buffersFieldCount"CLASS="Sf"></A>
<A NAME="Buffer's Capture Field Count NX156"CLASS="NX"></A>
<A NAME="Buffer's Capture Field Count   ---   pxd_buffersFieldCount"CLASS="Sf"></A>
<A NAME="Buffer's Capture Field Count   ---   pxd_buffersFieldCount"></A>
<H6 CLASS="Sf">Buffer's Capture Field Count   ---   pxd_buffersFieldCount</H6>
<A NAME="pxd_buffersGPIn NX157"CLASS="NX"></A>
<A NAME="pxd_buffersGPIn"CLASS="Sg"></A>
<A NAME="Buffer's Capture General Purpose Input NX158"CLASS="NX"></A>
<A NAME="Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn"CLASS="Sg"></A>
<A NAME="Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn"></A>
<H6 CLASS="Sg">Buffer's Capture General Purpose Input   ---   pxd_buffersGPIn</H6>
<A NAME="pxd_buffersSysTicks NX159"CLASS="NX"></A>
<A NAME="pxd_buffersSysTicks"CLASS="Sg"></A>
<A NAME="Buffer's Capture System Time NX160"CLASS="NX"></A>
<A NAME="Buffer's Capture System Time   ---   pxd_buffersSysTicks"CLASS="Sg"></A>
<A NAME="Buffer's Capture System Time   ---   pxd_buffersSysTicks"></A>
<H6 CLASS="Sg">Buffer's Capture System Time   ---   pxd_buffersSysTicks</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
pxvbtime_t pxd_buffersFieldCount(unitmap, buffer);
int        pxd_buffersGPIn(unitmap, buffer);
uint32     pxd_buffersTicks(unitmap, buffer);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Information about the specified, captured, frame buffer is returned.
<P>
The
<EM CLASS="Ep">pxd_buffersFieldCount</EM>
returns the video field count when the specified frame buffer
was captured,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The field count is initialized to 0
when
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
is invoked,
and (typically, but dependent upon imaging board)
counts all video fields, whether captured or not.
<P>
The
<A HREF="#pxd_buffersGPIn"CLASS="Er">pxd_buffersGPIn</A>
returns the value(s)
of the general purpose
input signals, if any, when the specified frame buffer
was captured.
The return value is in the same imaging board dependent format
as for
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>.
For the PIXCI&reg;&nbsp;SV2 and SV3 imaging boards, the
<A HREF="#pxd_buffersGPIn"CLASS="Er">pxd_buffersGPIn</A>
is not available and always returns 0.
<P>
The
<A HREF="#pxd_buffersSysTicks"CLASS="Er">pxd_buffersSysTicks</A>
returns the low 32 bits of the system time
when the specified frame buffer was captured,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
Under Windows 95, 98, and ME, the
system time is in 1 millisecond units.
Under Windows NT, 2000, XP, and Server 2003 the
system time is in 100 nanosecond units;
if the high resolution timer option (see
<A HREF="#Driver Configuration Parameters"CLASS="Er">Driver Configuration Parameters</A>)
is used, the units are dependent upon Windows and the host computer.
Under DOS+Tenberry, the
system time is in 54.94 millisecond (i.e. 1/18.2&nbsp;Hz)
units.
Under Linux, the system time units
are dependent on the Linux version and host hardware
(i.e. the reciprocal of Linux's
''HZ'');
for common 2.4 and 2.6 kernels on a PC, the system time is in 10 millisecond units.<A HREF="#Footnote 14"CLASS="Ff"><SUP>[14]</SUP></A>
<P>
The return values of these functions is undefined
if the specified frame buffer has not yet been captured,
or if the Video Format Configuration
has been changed thereby causing frame buffer memory to be reorganized.
<P>
For the PIXCI&reg; CL3SD imaging board, these
features are available only if the
''-IM''
<A HREF="#Device Configuration Parameters"CLASS="Er">Device Configuration Parameters</A>
specifies
''frame''
buffer memory, even though the
PIXCI&reg; CL3SD imaging board has on-board memory.
These features are not available if the
''-MU''
<A HREF="#Driver Configuration Parameter"CLASS="Er">Driver Configuration Parameter</A>
is used.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
All functions return 0 if
the library is not open or the feature is not available.
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
See
<A HREF="#pxd_capturedFieldCount"CLASS="Er">pxd_capturedFieldCount</A>,
<A HREF="#pxd_capturedSysTicks"CLASS="Er">pxd_capturedSysTicks</A>,
and
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>
which provide similar information
if invoked in a timely manner,
and are
supported for all PIXCI&reg; imaging boards and
<A HREF="#Driver Configuration Parameters"CLASS="Er">Driver Configuration Parameters</A>.
<HR SIZE="1">
<A NAME="pxd_capturedBuffer NX161"CLASS="NX"></A>
<A NAME="pxd_capturedBuffer"CLASS="Sf"></A>
<A NAME="Last Captured Buffer: Buffer Number NX162"CLASS="NX"></A>
<A NAME="Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer"CLASS="Sf"></A>
<A NAME="Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer"></A>
<H6 CLASS="Sf">Last Captured Buffer: Buffer Number   ---   pxd_capturedBuffer</H6>
<A NAME="pxd_capturedFieldCount NX163"CLASS="NX"></A>
<A NAME="pxd_capturedFieldCount"CLASS="Sg"></A>
<A NAME="Last Captured Buffer: Field Count NX164"CLASS="NX"></A>
<A NAME="Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount"CLASS="Sg"></A>
<A NAME="Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount"></A>
<H6 CLASS="Sg">Last Captured Buffer: Field Count   ---   pxd_capturedFieldCount</H6>
<A NAME="pxd_capturedSysTicks NX165"CLASS="NX"></A>
<A NAME="pxd_capturedSysTicks"CLASS="Sg"></A>
<A NAME="Last Captured Buffer: System Time NX166"CLASS="NX"></A>
<A NAME="Last Captured Buffer: System Time   ---   pxd_capturedSysTicks"CLASS="Sg"></A>
<A NAME="Last Captured Buffer: System Time   ---   pxd_capturedSysTicks"></A>
<H6 CLASS="Sg">Last Captured Buffer: System Time   ---   pxd_capturedSysTicks</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
pxbuffer_t pxd_capturedBuffer(unitmap);
pxvbtime_t pxd_capturedFieldCount(unitmap);
uint32     pxd_capturedSysTicks(unitmap);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Information about the last captured frame buffer is returned.
<P>
The
<A HREF="#pxd_capturedBuffer"CLASS="Er">pxd_capturedBuffer</A>
returns the buffer number into which the last frame was captured,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#pxd_capturedFieldCount"CLASS="Er">pxd_capturedFieldCount</A>
returns the video field count when the last frame
was captured,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The field count is initialized to 0
when
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
is invoked,
and (typically, but dependent upon imaging board)
counts all video fields, whether captured or not.
<P>
The
<A HREF="#pxd_capturedSysTicks"CLASS="Er">pxd_capturedSysTicks</A>
returns the low 32 bits of the system time
when the last frame was captured,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
Under Windows 95, 98, and ME, the
system time is in 1 millisecond units.
Under Windows NT, 2000, XP, and Server 2003 the
system time is in 100 nanosecond units;
if the high resolution timer option (see
<A HREF="#Driver Configuration Parameters"CLASS="Er">Driver Configuration Parameters</A>)
is used, the units are dependent upon Windows and the host computer.
Under DOS+Tenberry, the
system time is in 54.94 millisecond (i.e. 1/18.2&nbsp;Hz)
units.
Under Linux, the system time units
are dependent on the Linux version and host hardware
(i.e. the reciprocal of Linux's
''HZ'');
for common 2.4 and 2.6 kernels on a PC, the system time is in 10 millisecond units.<A HREF="#Footnote 15"CLASS="Ff"><SUP>[15]</SUP></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
All functions return 0 if
the library is not open for use or no
frame has even been captured since the library was
opened.
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
See
<A HREF="#pxd_buffersFieldCount"CLASS="Er">pxd_buffersFieldCount</A>
and
<A HREF="#pxd_buffersSysTicks"CLASS="Er">pxd_buffersSysTicks</A>
which provides similar information
saved on a per buffer basis, rather
than having to be retrieved before another
video frame is captured.
<HR SIZE="1">
<A NAME="pxd_defineImage NX167"CLASS="NX"></A>
<A NAME="pxd_defineImage"CLASS="Sf"></A>
<A NAME="Get PXIMAGE: Access Imaging Board Frame Buffer NX168"CLASS="NX"></A>
<A NAME="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage"CLASS="Sf"></A>
<A NAME="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage"></A>
<H6 CLASS="Sf">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_defineImage</H6>
<A NAME="pxd_defineImage3 NX169"CLASS="NX"></A>
<A NAME="pxd_defineImage3"CLASS="Sg"></A>
<A NAME="Get PXIMAGE3: Access Imaging Board Frame Buffers NX170"CLASS="NX"></A>
<A NAME="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3"CLASS="Sg"></A>
<A NAME="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3"></A>
<H6 CLASS="Sg">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_defineImage3</H6>
<A NAME="pxd_definePximage NX171"CLASS="NX"></A>
<A NAME="pxd_definePximage"CLASS="Sg"></A>
<A NAME="Get PXIMAGE: Access Imaging Board Frame Buffer NX172"CLASS="NX"></A>
<A NAME="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage"CLASS="Sg"></A>
<A NAME="Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage"></A>
<H6 CLASS="Sg">Get PXIMAGE: Access Imaging Board Frame Buffer   ---   pxd_definePximage</H6>
<A NAME="pxd_definePximage3 NX173"CLASS="NX"></A>
<A NAME="pxd_definePximage3"CLASS="Sg"></A>
<A NAME="Get PXIMAGE3: Access Imaging Board Frame Buffers NX174"CLASS="NX"></A>
<A NAME="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3"CLASS="Sg"></A>
<A NAME="Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3"></A>
<H6 CLASS="Sg">Get PXIMAGE3: Access Imaging Board Frame Buffers   ---   pxd_definePximage3</H6>
<A NAME="pxd_definePximageFree NX175"CLASS="NX"></A>
<A NAME="pxd_definePximageFree"CLASS="Sg"></A>
<A NAME="Get PXIMAGE: Release Access to Imaging Board Frame Buffers NX176"CLASS="NX"></A>
<A NAME="Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree"CLASS="Sg"></A>
<A NAME="Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree"></A>
<H6 CLASS="Sg">Get PXIMAGE: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximageFree</H6>
<A NAME="pxd_definePximage3Free NX177"CLASS="NX"></A>
<A NAME="pxd_definePximage3Free"CLASS="Sg"></A>
<A NAME="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers NX178"CLASS="NX"></A>
<A NAME="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free"CLASS="Sg"></A>
<A NAME="Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free"></A>
<H6 CLASS="Sg">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers   ---   pxd_definePximage3Free</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
struct pximage  * pxd_defineImage (unitmap, framebuf, ulx, uly, lrx, lry, colorspace);
struct pximage3 * pxd_defineImage3(unitmap, startbuf, endbuf, ulx, uly, lrx, lry, colorspace);
<BR>
struct pximage  * pxd_definePximage (unitmap, framebuf, ulx, uly, lrx, lry, colorspace);
struct pximage3 * pxd_definePximage3(unitmap, startbuf, endbuf, ulx, uly, lrx, lry, colorspace);
void              pxd_definePximageFree(image);
void              pxd_definePximage3Free(image3)
<BR>
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
char                *colorspace;    // Name of requested color representation
<BR>
pxbuffer_t          startbuf;       // First image frame buffer
pxbuffer_t          endbuf;         // Last image frame buffer
<BR>
struct pximage      image;          // Image access to be released
struct pximage3     image3;         // Image access to be released
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
A reference to an image frame buffer and an area of interest within the image
frame buffer, or a reference to a sequence of image frame buffers
and an area of interest within each image frame buffer,
is constructed and returned.
<P>
These functions are useful for constructing a reference
which specifies
an image frame buffer and an area of interest
for use with other library functions,
in particular functions in the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>,
which expect a
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*'',
to specify image access,
and where the programmer prefers to avoid the (explicit)
use of structures and pointers.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit to be accessed.
For
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>,
the
<EM CLASS="Ep">framebuf</EM>,
where
1&lt;=<EM CLASS="Ep">framebuf</EM>&lt;=<EM CLASS="Ep">pxd_imageZdim(),</EM>
specifies the image frame buffer to be accessed.
For
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>,
the
<EM CLASS="Ep">startbuf</EM>
and
<EM CLASS="Ep">endbuf</EM>,
where
<EM CLASS="Ep">startbuf</EM>&lt;=<EM CLASS="Ep">endbuf,</EM>
1&lt;=<EM CLASS="Ep">startbuf</EM>&lt;=<EM CLASS="Ep">pxd_imageZdim(),</EM>
and
1&lt;=<EM CLASS="Ep">endbuf</EM>&lt;=<EM CLASS="Ep">pxd_imageZdim(),</EM>
specify the first and last, inclusively, image frame buffer
to be accessed.
The
<EM CLASS="Ep">ulx</EM>
and
<EM CLASS="Ep">uly</EM>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>())
or the extreme bottom vertical coordinate
(i.e.
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>()),
respectively.
<P>
The
<EM CLASS="Ep">colorspace</EM>
specifies the color space and color component(s)
in which the image frame buffer(s) are to be accessed.
Valid choices are:
<BLOCKQUOTE>
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
colorspace  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Number of Components 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Color Representation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Default&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 ? 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Image frame buffer's default representation,
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
            
</TD>
<TD ALIGN="left" COLSPAN="1">
   
</TD>
<TD ALIGN="left" COLSPAN="1">
 typically Grey, RGB, BGR, or YCrCb.
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
<BR>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Display&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 ? 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Optimum representation for display purposes,
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
            
</TD>
<TD ALIGN="left" COLSPAN="1">
   
</TD>
<TD ALIGN="left" COLSPAN="1">
 typically Grey, RGB, BGR, RGBx, or BGRx.
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
<BR>
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RGB&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofRGB&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofRGB&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofRGB&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BGR&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red (RGB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofBGR&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofBGR&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofBGR&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BSH&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness, Saturation, Hue (HSB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofBSH&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;SofBSH&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Saturation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;HofBSH&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Hue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RGBx&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofRGBx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofRGBx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofRGBx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BGRx&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red, Pad (RGB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofBGRx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofBGRx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofBGRx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Grey&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GREY&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale (alternate spelling for &quot;Grey&quot;)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Gray&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale (alternate spelling for &quot;Grey&quot;)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GRAY&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale (alternate spelling for &quot;Grey&quot;)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YCrCb&quot;     
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity, Red Chroma, Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YofYCrCb&quot;  
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofYCrCb&quot;  
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofYCrCb&quot;  
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YCrCbX&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity, Red Chroma, Blue Chroma, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YofYCrCbX&quot; 
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofYCrCbX&quot; 
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofYCrCbX&quot; 
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Bayer&quot;     
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Raw Bayer Pattern Values
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;CbYCrY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 2 
</TD>
<TD ALIGN="left" COLSPAN="1">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;CMY&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cyan, Magenta, Yellow
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;CofCMY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cyan
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;MofCMY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Magenta
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YofCMY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Yellow
</TD>
</TR>
</TABLE>
</PRE>
</BLOCKQUOTE>
<P>
The
''BGRx''
selection, when read into a
''uchar''
buffer on Intel machines with little-endian architecture
(i.e. least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, results in pixels that are compatible with Windows' RGB() data type.
<P>
The
''Bayer''
selection is available only in conjunction with cameras
that actually output raw Bayer pattern values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
<P>
The
''CbYCrY''
selection is available only in conjunction with imaging boards
that actually capture CbYCrY (UYVY) values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x), BGR(x), or YCrCb.
<P>
The
''Display''
selection chooses an optimum color representation
for use with
<CITE CLASS="Ec">pxio8_GDIDisplay</CITE>
and similar display functions
(in the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>),
and is dependent upon the camera, video
format configuration, and current graphics display system (S/VGA card).
<P>
For ease of use, the
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
and
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
return
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
that need
<U CLASS="U">not</U>
(and must not)
be
<CITE CLASS="Ec">free</CITE>'ed<CITE CLASS="Ec">.</CITE>
Instead,
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
and
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
provide references to a limited number
of statically
allocated structures.
The limit is sufficient to support the convenient use of
any library function in the manner shown
in the example below; invoking
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
or
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
as
''in-line''
functions.
The returned
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
should
<U CLASS="U">not</U>
be assigned to a pointer variable and used repeatedly.
<P>
In contrast, the
<A HREF="#pxd_definePximage"CLASS="Er">pxd_definePximage</A>
and
<A HREF="#pxd_definePximage3"CLASS="Er">pxd_definePximage3</A>
return a
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
that after use
<U CLASS="U">must</U>
be released via
<A HREF="#pxd_definePximageFree"CLASS="Er">pxd_definePximageFree</A>
or
<A HREF="#pxd_definePximage3Free"CLASS="Er">pxd_definePximage3Free</A>,
respectively.
The
<A HREF="#pxd_definePximage"CLASS="Er">pxd_definePximage</A>
and
<A HREF="#pxd_definePximage3"CLASS="Er">pxd_definePximage3</A>
alternatives are appropriate
when accessing the library from a multi-threaded
environment, or when the programmer
chooses to assign the return values to a
pointer variable for repeated use.
The
<A HREF="#pxd_definePximage"CLASS="Er">pxd_definePximage</A>
and
<A HREF="#pxd_definePximage3"CLASS="Er">pxd_definePximage3</A>
creates a copy of the image access structures in
<CITE CLASS="Ec">malloc</CITE>'ed
memory, but does not copy the image contents;
each use of the returned
''struct pximage&nbsp;*''
or
''struct pximage3&nbsp;*''
access the current contents of the frame buffer.
<P>
The XCLIB-Lite does not support this feature.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<P>
Returns NULL if the library is not open for use,
if XCLIB-Lite is being used,
if the
<EM CLASS="Ep">colorspace</EM>
or other parameter is invalid,
or for
<A HREF="#pxd_definePximage"CLASS="Er">pxd_definePximage</A>
and
<A HREF="#pxd_definePximage3"CLASS="Er">pxd_definePximage3</A>
if memory could not be
<CITE CLASS="Ec">malloc</CITE>'ed.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
Consider the typical image processing library function
<CITE CLASS="Ec">pxip8_pixand</CITE>,
which should be invoked as:
<BLOCKQUOTE>
<PRE>
int pxip8_pixand(abortp, sip, dip, mask);
pxabortfunc_t   **abortp;   // premature termination function, or NULL
struct  pximage *sip;       // source
struct  pximage *dip;       // destination
int     mask;               // and mask
</PRE>
</BLOCKQUOTE>
The following invokes this library function,
operating on the upper left quadrant of image frame buffer 1
and placing the result in the lower right
quadrant of image frame buffer 2,
without explicitly using structures or pointers.
<BLOCKQUOTE>
<PRE>
int xdim, ydim;
<BR>
xdim = pxd_imageXdim();
ydim = pxd_imageYdim();
pxip8_pixand(NULL,                  // no abort
             pxd_defineImage(1, 1, 0,      0,      xdim/2, ydim/2, &quot;Default&quot;),
             pxd_defineImage(1, 2, xdim/2, ydim/2, xdim,   ydim,   &quot;Default&quot;),
             0xC0 );                // chosen mask value
</PRE>
</BLOCKQUOTE>
<P>
Consider the typical image processing library function
<CITE CLASS="Ec">pxio8_tifwriteseq</CITE>,
which saves a sequence of images.
It may be invoked as:
<BLOCKQUOTE>
<PRE>
pxio8_tifwriteseq(NULL,
                  pxd_defineImage3(1, 1, pxd_imageZdim(), 0, 0, -1, -1, &quot;Default&quot;),
                  NULL, &quot;test.tif&quot;, 8, 0, 0, NULL);
</PRE>
</BLOCKQUOTE>
to save the entire AOI of all image frame buffers.
<HR SIZE="1">
<A NAME="pxd_doSnap NX179"CLASS="NX"></A>
<A NAME="pxd_doSnap"CLASS="Sf"></A>
<A NAME="Video Snap and Wait NX180"CLASS="NX"></A>
<A NAME="Video Snap and Wait   ---   pxd_doSnap"CLASS="Sf"></A>
<A NAME="Video Snap and Wait   ---   pxd_doSnap"></A>
<H6 CLASS="Sf">Video Snap and Wait   ---   pxd_doSnap</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_doSnap(unitmap, buffer, timeout);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
ulong               timeout;        // Snap timeout, in milliseconds
int
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
initiates capture of a single image into the
<EM CLASS="Ep">buffer</EM>,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>,
and waits for capture to be complete
before returning.
<P>
The
<EM CLASS="Ep">timeout</EM>
specifies a period of time after which the
snap should be aborted and  the function return
without having completed acquisition of a frame buffer.
If
<EM CLASS="Ep">timeout</EM>=0,
a default timeout, as appropriate for the current video format
configuration, is used.
<P>
For the PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and CL3SD imaging board
configured for triggered
capture, the
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
''arms''
the imaging board to capture the next externally triggered
frame, or both
''arms''
and initiates a software triggered frame,
according to the Video Format Configuration.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERRESOURCEBUSY<DD>
Video is already being captured
and must be terminated before
initiating a new capture.
<BR><DT>PXERTIMEOUT<DD>
The operation was aborted
due to timeout.
<BR><DT>PXERDEVFAULT<DD>
Capture was not completed properly,
the
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
may provide additional information.
<BR><DT>PXER*<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_eventFieldCreate NX181"CLASS="NX"></A>
<A NAME="pxd_eventFieldCreate"CLASS="Sf"></A>
<A NAME="Windows: Register Event upon Video Field NX182"CLASS="NX"></A>
<A NAME="Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate"CLASS="Sf"></A>
<A NAME="Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate"></A>
<H6 CLASS="Sf">Windows: Register Event upon Video Field   ---   pxd_eventFieldCreate</H6>
<A NAME="pxd_eventFieldClose NX183"CLASS="NX"></A>
<A NAME="pxd_eventFieldClose"CLASS="Sg"></A>
<A NAME="Windows: Unregister Event upon Video Field NX184"CLASS="NX"></A>
<A NAME="Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose"CLASS="Sg"></A>
<A NAME="Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose"></A>
<H6 CLASS="Sg">Windows: Unregister Event upon Video Field   ---   pxd_eventFieldClose</H6>
<A NAME="pxd_eventCapturedFieldCreate NX185"CLASS="NX"></A>
<A NAME="pxd_eventCapturedFieldCreate"CLASS="Sg"></A>
<A NAME="Windows: Register Event upon Captured Video Field NX186"CLASS="NX"></A>
<A NAME="Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"CLASS="Sg"></A>
<A NAME="Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"></A>
<H6 CLASS="Sg">Windows: Register Event upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</H6>
<A NAME="pxd_eventCapturedFieldClose NX187"CLASS="NX"></A>
<A NAME="pxd_eventCapturedFieldClose"CLASS="Sg"></A>
<A NAME="Windows: Unregister Event upon Captured Video Field NX188"CLASS="NX"></A>
<A NAME="Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose"CLASS="Sg"></A>
<A NAME="Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose"></A>
<H6 CLASS="Sg">Windows: Unregister Event upon Captured Video Field   ---   pxd_eventCapturedFieldClose</H6>
<A NAME="pxd_eventGPTriggerCreate NX189"CLASS="NX"></A>
<A NAME="pxd_eventGPTriggerCreate"CLASS="Sg"></A>
<A NAME="Windows: Register Event upon General Purpose Trigger NX190"CLASS="NX"></A>
<A NAME="Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"CLASS="Sg"></A>
<A NAME="Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"></A>
<H6 CLASS="Sg">Windows: Register Event upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</H6>
<A NAME="pxd_eventGPTriggerClose NX191"CLASS="NX"></A>
<A NAME="pxd_eventGPTriggerClose"CLASS="Sg"></A>
<A NAME="Windows: Unregister Event upon General Purpose Trigger NX192"CLASS="NX"></A>
<A NAME="Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"CLASS="Sg"></A>
<A NAME="Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"></A>
<H6 CLASS="Sg">Windows: Unregister Event upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
HANDLE pxd_eventFieldCreate(unitmap);
void   pxd_eventFieldClose(unitmap, hEvent);
HANDLE pxd_eventCapturedFieldCreate(unitmap);
void   pxd_eventCapturedFieldClose(unitmap, hEvent);
HANDLE pxd_eventGPTriggerCreate(unitmap, which, rsvd);
void   pxd_eventGPTriggerClose(unitmap, which, rsvd, hEvent);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
HANDLE              hEvent;         // HANDLE returned by previous create
int                 which;          // Which of N triggers to use, N &gt;= 0
int                 rsvd;           // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="Windows NX193"CLASS="NX"></A>
The
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
returns a handle to a Windows event which is signaled
once per video field, whether captured or not,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
For PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A:
The event is signaled at (approximately) the start of vertical drive.
For PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and A:
The event is signaled at (approximately) the end of vertical drive.
For PIXCI&reg;&nbsp;CL3SD:
The event is signaled at vertical drive, which is so short as to
make end vs. start distinctions irrelevant.
<P>
The
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
returns a HANDLE to a Windows event which is signaled
once per captured video field,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The event is signaled at (approximately) after the last pixel captured
within the field.
<P>
The
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
returns a HANDLE to a Windows event which is signaled
once per trigger initiated by the
general purpose trigger signal(s), if any,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The
<EM CLASS="Ep">which</EM>
specifies which of several trigger(s) is to be sensed.
<P>
The Windows HANDLE returned by
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>,
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>,
or
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>,
can be used with
<CITE CLASS="Ec">WaitForSingleObject</CITE>
or any other appropriate Windows' API function, such as:
<BLOCKQUOTE>
<PRE>
    HANDLE  hEvent = pxd_eventFieldCreate(0x1);
    for (;;) {
        WaitForSingleObject(hEvent, INFINITE);
        // do something upon signal
    }
</PRE>
</BLOCKQUOTE>
If using multiple threads in conjunction with
<CITE CLASS="Ec">WaitForSingleObject</CITE>
or similar functions, note that entry into XCLIB functions
must synchronized by the application
to prevent overlapping entry by multiple threads.
<P>
The
<A HREF="#pxd_eventFieldClose"CLASS="Er">pxd_eventFieldClose</A>,
<A HREF="#pxd_eventCapturedFieldClose"CLASS="Er">pxd_eventCapturedFieldClose</A>,
or
<A HREF="#pxd_eventGPTriggerClose"CLASS="Er">pxd_eventGPTriggerClose</A>,
terminates the event previously created with
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>,
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>,
or
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>,
respectively.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>,
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>,
and
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>,
return a Windows' HANDLE, or NULL
if error.
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
The
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
and
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
provide signals or counts, respectively,
upon the same general purpose trigger signal.
See
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
for additional discussion on the availability and use
of general purpose trigger signal(s).
<HR SIZE="1">
<A NAME="pxd_eventFieldCreate NX194"CLASS="NX"></A>
<A NAME="pxd_eventFieldCreate"CLASS="Sf"></A>
<A NAME="DOS: Register Callback upon Video Field NX195"CLASS="NX"></A>
<A NAME="DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate"CLASS="Sf"></A>
<A NAME="DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate"></A>
<H6 CLASS="Sf">DOS: Register Callback upon Video Field   ---   pxd_eventFieldCreate</H6>
<A NAME="pxd_eventFieldClose NX196"CLASS="NX"></A>
<A NAME="pxd_eventFieldClose"CLASS="Sg"></A>
<A NAME="DOS: Unregister Callback upon Video Field NX197"CLASS="NX"></A>
<A NAME="DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose"CLASS="Sg"></A>
<A NAME="DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose"></A>
<H6 CLASS="Sg">DOS: Unregister Callback upon Video Field   ---   pxd_eventFieldClose</H6>
<A NAME="pxd_eventCapturedFieldCreate NX198"CLASS="NX"></A>
<A NAME="pxd_eventCapturedFieldCreate"CLASS="Sg"></A>
<A NAME="DOS: Register Callback upon Captured Video Field NX199"CLASS="NX"></A>
<A NAME="DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"CLASS="Sg"></A>
<A NAME="DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"></A>
<H6 CLASS="Sg">DOS: Register Callback upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</H6>
<A NAME="pxd_eventCapturedFieldClose NX200"CLASS="NX"></A>
<A NAME="pxd_eventCapturedFieldClose"CLASS="Sg"></A>
<A NAME="DOS: Unregister Callback upon Captured Video Field NX201"CLASS="NX"></A>
<A NAME="DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose"CLASS="Sg"></A>
<A NAME="DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose"></A>
<H6 CLASS="Sg">DOS: Unregister Callback upon Captured Video Field   ---   pxd_eventCapturedFieldClose</H6>
<A NAME="pxd_eventGPTriggerCreate NX202"CLASS="NX"></A>
<A NAME="pxd_eventGPTriggerCreate"CLASS="Sg"></A>
<A NAME="DOS: Register Callback upon General Purpose Trigger NX203"CLASS="NX"></A>
<A NAME="DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"CLASS="Sg"></A>
<A NAME="DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"></A>
<H6 CLASS="Sg">DOS: Register Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</H6>
<A NAME="pxd_eventGPTriggerClose NX204"CLASS="NX"></A>
<A NAME="pxd_eventGPTriggerClose"CLASS="Sg"></A>
<A NAME="DOS: Unregister Callback upon General Purpose Trigger NX205"CLASS="NX"></A>
<A NAME="DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"CLASS="Sg"></A>
<A NAME="DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"></A>
<H6 CLASS="Sg">DOS: Unregister Callback upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_eventFieldCreate(unitmap, irqfunc, statep);
int pxd_eventFieldClose(unitmap, irqfunc);
int pxd_eventCapturedFieldCreate(unitmap, irqfunc, statep);
int pxd_eventCapturedFieldClose(unitmap, irqfunc);
int pxd_eventGPTriggerCreate(unitmap, which, rsvd, irqfunc, statep);
int pxd_eventGPTriggerClose(unitmap, which, rsvd, irqfunc);
<BR>
typedef int (_cfunfcc pxasyncfunc_t)(void*,int,int);
                                    // _cfunfcc is a predefined function modifier
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxasyncfunc_t       irqfunc         // Callback function
void                *statep;        // Argument to call back function
int                 which;          // Which of N triggers to use, &gt;= 0
int                 rsvd;           // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="DOS NX206"CLASS="NX"></A>
The
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
registers a callback function to be invoked
once per video field, whether captured or not,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
For PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A:
The function is invoked at (approximately) the start of vertical drive.
For PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and A:
The function is invoked at (approximately) the end of vertical drive.
For PIXCI&reg;&nbsp;CL3SD:
The function is invoked at vertical drive, which is so short as to
make end vs. start distinctions irrelevant.
<P>
The
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
registers a callback function to be invoked
once per captured video field,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The function is invoked at (approximately) after the last pixel captured
within the field.
<P>
The
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
registers a callback function to be invoked
once per trigger initiated by the
general purpose trigger signal(s), if any,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The
<EM CLASS="Ep">which</EM>
specifies which of several trigger(s) is to be sensed.
<P>
The
<EM CLASS="Ep">irqfunc</EM>
specifies the callback function to be invoked, such as:
<PRE>
    int _cfunfcc my_irq_callback(void *statep, int unitmap, int reserved)
    {
    }
</PRE>
where
<EM CLASS="Ep">statep</EM>
is the value previously passed to
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>,
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>,
or
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>,
where
<EM CLASS="Ep">unitmap</EM>
specifies the unit upon which the event occurred,
and where
<EM CLASS="Ep">reserved</EM>
is currently unused and 0.
<P>
As any other interrupt handler, the
<EM CLASS="Ep">irqfunc</EM>
must operate under severe constraints.
It, and all functions it invokes,
must be compiled to avoid stack checks (probes),
must not use excessive stack or time,
must not use most DOS or BIOS
functions (including
<CITE CLASS="Ec">printf</CITE>).
The
<EM CLASS="Ep">irqfunc</EM>
should not be declared with the compiler's
''_interrupt''
or
''__interrupt''
adjective.
<P>
The
<A HREF="#pxd_eventFieldClose"CLASS="Er">pxd_eventFieldClose</A>,
<A HREF="#pxd_eventCapturedFieldClose"CLASS="Er">pxd_eventCapturedFieldClose</A>,
or
<A HREF="#pxd_eventGPTriggerClose"CLASS="Er">pxd_eventGPTriggerClose</A>
unregisters the callback function previously registered with
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>,
or
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>,
respectively.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
The
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
and
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
provide callbacks or counts, respectively,
upon the same general purpose trigger signal.
See
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
for additional discussion on the availability and use
of general purpose trigger signal(s).
<HR SIZE="1">
<A NAME="pxd_eventFieldCreate NX207"CLASS="NX"></A>
<A NAME="pxd_eventFieldCreate"CLASS="Sf"></A>
<A NAME="Linux: Register Signal upon Video Field NX208"CLASS="NX"></A>
<A NAME="Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate"CLASS="Sf"></A>
<A NAME="Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate"></A>
<H6 CLASS="Sf">Linux: Register Signal upon Video Field   ---   pxd_eventFieldCreate</H6>
<A NAME="pxd_eventFieldClose NX209"CLASS="NX"></A>
<A NAME="pxd_eventFieldClose"CLASS="Sg"></A>
<A NAME="Linux: Unregister Signal upon Video Field NX210"CLASS="NX"></A>
<A NAME="Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose"CLASS="Sg"></A>
<A NAME="Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose"></A>
<H6 CLASS="Sg">Linux: Unregister Signal upon Video Field   ---   pxd_eventFieldClose</H6>
<A NAME="pxd_eventCapturedFieldCreate NX211"CLASS="NX"></A>
<A NAME="pxd_eventCapturedFieldCreate"CLASS="Sg"></A>
<A NAME="Linux: Register Signal upon Captured Video Field NX212"CLASS="NX"></A>
<A NAME="Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"CLASS="Sg"></A>
<A NAME="Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate"></A>
<H6 CLASS="Sg">Linux: Register Signal upon Captured Video Field   ---   pxd_eventCapturedFieldCreate</H6>
<A NAME="pxd_eventCapturedFieldClose NX213"CLASS="NX"></A>
<A NAME="pxd_eventCapturedFieldClose"CLASS="Sg"></A>
<A NAME="Linux: Unregister Signal upon Captured Video Field NX214"CLASS="NX"></A>
<A NAME="Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose"CLASS="Sg"></A>
<A NAME="Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose"></A>
<H6 CLASS="Sg">Linux: Unregister Signal upon Captured Video Field   ---   pxd_eventCapturedFieldClose</H6>
<A NAME="pxd_eventGPTriggerCreate NX215"CLASS="NX"></A>
<A NAME="pxd_eventGPTriggerCreate"CLASS="Sg"></A>
<A NAME="Linux: Register Signal upon General Purpose Trigger NX216"CLASS="NX"></A>
<A NAME="Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"CLASS="Sg"></A>
<A NAME="Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate"></A>
<H6 CLASS="Sg">Linux: Register Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerCreate</H6>
<A NAME="pxd_eventGPTriggerClose NX217"CLASS="NX"></A>
<A NAME="pxd_eventGPTriggerClose"CLASS="Sg"></A>
<A NAME="Linux: Unregister Signal upon General Purpose Trigger NX218"CLASS="NX"></A>
<A NAME="Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"CLASS="Sg"></A>
<A NAME="Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose"></A>
<H6 CLASS="Sg">Linux: Unregister Signal upon General Purpose Trigger   ---   pxd_eventGPTriggerClose</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_eventFieldCreate(unitmap, signum, rsvd2);
int pxd_eventFieldClose(unitmap, signum);
int pxd_eventCapturedFieldCreate(unitmap, signum, rsvd2);
int pxd_eventCapturedFieldClose(unitmap, signum);
int pxd_eventGPTriggerCreate(unitmap, which, rsvd, signum, rsvd2);
int pxd_eventGPTriggerClose(unitmap, which, rsvd, signum);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 signum;         // Signal number
int                 which;          // Which of N triggers to use, &gt;= 0
int                 rsvd;           // Reserved, should be 0
void                *rsvd2;         // Reserved, should be NULL
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="Linux NX219"CLASS="NX"></A>
The
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
registers a signal number to be signaled
once per video field, whether captured or not,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
For PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A:
The signal is issued at (approximately) the start of vertical drive.
For PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and A:
The signal is issued at (approximately) the end of vertical drive.
For PIXCI&reg;&nbsp;CL3SD:
The signal is issued at vertical drive, which is so short as to
make end vs. start distinctions irrelevant.
<P>
The
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
registers a signal number to be signaled
once per captured video field,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The function is invoked at (approximately) after the last pixel captured
within the field.
<P>
The
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
registers a signal number to be signaled
once per trigger initiated by the
general purpose trigger signal(s), if any,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.
The
<EM CLASS="Ep">which</EM>
specifies which of several trigger(s) is to be sensed.
<P>
The
<EM CLASS="Ep">signum</EM>
specifies the Linux signal number to be used,
such as SIGUSR1.
(see Linux's
<CODE CLASS="Em">signal.h</CODE>).
Handling the signal, such as with
<CITE CLASS="Ec">signal()</CITE>
or
<CITE CLASS="Ec">sigaction()</CITE>
is the caller's responsibility.
<P>
If the caller's signal handling function is to call
XCLIB functions, note that
entry into XCLIB functions
must be synchronized by the application
to prevent overlapping entry by multiple threads.
<P>
The
<A HREF="#pxd_eventFieldClose"CLASS="Er">pxd_eventFieldClose</A>,
<A HREF="#pxd_eventCapturedFieldClose"CLASS="Er">pxd_eventCapturedFieldClose</A>,
or
<A HREF="#pxd_eventGPTriggerClose"CLASS="Er">pxd_eventGPTriggerClose</A>
unregisters the signaling previously registered with
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>,
or
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>,
respectively.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
The
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
and
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
provide signals or counts, respectively,
upon the same general purpose trigger signal.
See
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
for additional discussion on the availability and use
of general purpose trigger signal(s).
<HR SIZE="1">
<A NAME="pxd_getGPIn NX220"CLASS="NX"></A>
<A NAME="pxd_getGPIn"CLASS="Sf"></A>
<A NAME="General Purpose Input Signal: Sense NX221"CLASS="NX"></A>
<A NAME="General Purpose Input Signal: Sense   ---   pxd_getGPIn"CLASS="Sf"></A>
<A NAME="General Purpose Input Signal: Sense   ---   pxd_getGPIn"></A>
<H6 CLASS="Sf">General Purpose Input Signal: Sense   ---   pxd_getGPIn</H6>
<A NAME="pxd_setGPIn NX222"CLASS="NX"></A>
<A NAME="pxd_setGPIn"CLASS="Sg"></A>
<A NAME="General Purpose Input Signal: Reset NX223"CLASS="NX"></A>
<A NAME="General Purpose Input Signal: Reset   ---   pxd_setGPIn"CLASS="Sg"></A>
<A NAME="General Purpose Input Signal: Reset   ---   pxd_setGPIn"></A>
<H6 CLASS="Sg">General Purpose Input Signal: Reset   ---   pxd_setGPIn</H6>
<A NAME="pxd_setGPOut NX224"CLASS="NX"></A>
<A NAME="pxd_setGPOut"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Set NX225"CLASS="NX"></A>
<A NAME="General Purpose Output Signal: Set   ---   pxd_setGPOut"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Set   ---   pxd_setGPOut"></A>
<H6 CLASS="Sg">General Purpose Output Signal: Set   ---   pxd_setGPOut</H6>
<A NAME="pxd_getGPOut NX226"CLASS="NX"></A>
<A NAME="pxd_getGPOut"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Get NX227"CLASS="NX"></A>
<A NAME="General Purpose Output Signal: Get   ---   pxd_getGPOut"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Get   ---   pxd_getGPOut"></A>
<H6 CLASS="Sg">General Purpose Output Signal: Get   ---   pxd_getGPOut</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  pxd_getGPIn(unitmap, getindata);
int  pxd_setGPIn(unitmap, setindata);
int  pxd_setGPOut(unitmap, setoutdata);
int  pxd_getGPOut(unitmap, getoutdata);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 data;           // Binary value(s) to set or reset
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The general purpose input and output
signals are sensed, set, or reset.
<P>
The
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>
obtains the current value of the general purpose
input signals, if any.
The
<EM CLASS="Ep">getindata</EM>
is ignored.
<P>
The
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>
resets the current value of the general purpose
input signals, if any, as per
<EM CLASS="Ep">setindata</EM>,
for imaging boards where the
general purpose inputs are latched rather than level sensitive.
<P>
The
<A HREF="#pxd_setGPOut"CLASS="Er">pxd_setGPOut</A>
sets the current value of the general purpose
output signals, if any, to
<EM CLASS="Ep">setoutdata</EM>.
<P>
The
<A HREF="#pxd_getGPOut"CLASS="Er">pxd_getGPOut</A>
gets the current value of the general purpose
output signals, if any,
returning a value in the same format as
the
<EM CLASS="Ep">setoutdata</EM>
parameter of
<A HREF="#pxd_setGPOut"CLASS="Er">pxd_setGPOut</A>.
The
<EM CLASS="Ep">getoutdata</EM>
is ignored.
<P>
For
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>
and
<A HREF="#pxd_getGPOut"CLASS="Er">pxd_getGPOut</A>,
the
<EM CLASS="Ep">unitmap</EM>
specifies the single unit for which the general
purpose input signals are sensed or the current value of
the general purpose output signals are obtained.
For
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>
and
<A HREF="#pxd_setGPOut"CLASS="Er">pxd_setGPOut</A>,
the
<EM CLASS="Ep">unitmap</EM>
specifies the multiple units for which the general
purpose input signals are reset or the general purpose
output signals are set.
<P>
For the PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards:
The boards' four general purpose output signals, XD4, XD5, XD6, and XD7,
are set to the bits 0x01, 0x02, 0x04, and 0x08 of
<EM CLASS="Ep">setoutdata</EM>,
respectively.
The boards' four general purpose input signals, XD0, XD1, XD2, and XD3,
are sensed in bits
0x01, 0x02, 0x04, and 0x08,
respectively,
of the returned value of
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>.
The general purpose inputs are level sensitive,
the
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>
has no effect.
<P>
For the PIXCI&reg;&nbsp;D, D24, and D32 imaging boards:
The availability of general purpose inputs and outputs
depends upon the board model, revision level, and video format configuration.
The boards may have a single general purpose latched input signal,
sensed as bit 0x01 of the returned value of
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>,
and reset as bit 0x01
of the
<EM CLASS="Ep">setindata</EM>
of
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>.
The boards may have a single general purpose latched output signal,
set to bit 0x01 of
<EM CLASS="Ep">setoutdata</EM>.
<P>
For the PIXCI&reg;&nbsp;D2X, D3X, SI, CL2, E1, E4, and CL3SD imaging boards
and for each functional unit of the PIXCI&reg;&nbsp;E1DB imaging board:
The two general purpose output signals
are set to bits 0x01 and 0x02 of
<EM CLASS="Ep">setoutdata</EM>.
The two general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>.
The general purpose inputs are level sensitive,
the
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>
has no effect.
<P>
For the PIXCI&reg;&nbsp;CL1 imaging boards:
The board's one (revision 1 boards) or two (revision 2 and later boards)
general purpose output signals
are set to bits 0x01 and 0x02 of
<EM CLASS="Ep">setoutdata</EM>.
The board's one (revision 1 boards) or two (revision 2 and later boards)
general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>.
The general purpose inputs are level sensitive,
the
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>
has no effect.
<P>
Note:
The general purpose input(s) and output(s)
are those
''auxiliary''
features available on some imaging boards
where, at the hardware level, the signal has no direct effect
on video capture.
The general purpose input(s) and output(s)
are not related to, and not needed for,
camera specific, hardware supported, typically asynchronous exposure,
triggering features available on some cameras when used with
the PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, or CL3SD.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>
and
<A HREF="#pxd_getGPOut"CLASS="Er">pxd_getGPOut</A>
return values as described above, and may also return:
<DL>
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<P>
The
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>
and
<A HREF="#pxd_setGPOut"CLASS="Er">pxd_setGPOut</A>
return:
<DL>
<BR><DT>0<DD>
Function performed,
however this returned value is not proof that the
imaging board supports the general purpose input(s) and
output(s).
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_getGPTrigger NX228"CLASS="NX"></A>
<A NAME="pxd_getGPTrigger"CLASS="Sf"></A>
<A NAME="General Purpose Trigger Count: Sense NX229"CLASS="NX"></A>
<A NAME="General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger"CLASS="Sf"></A>
<A NAME="General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger"></A>
<H6 CLASS="Sf">General Purpose Trigger Count: Sense   ---   pxd_getGPTrigger</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  pxd_getGPTrigger(unitmap, which);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 which;          // Which of N triggers to sense, &gt;= 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
obtains the current count of the number of triggers
initiated by the general purpose
trigger signal(s), if any.
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit for which the general
purpose trigger count is obtained.
The
<EM CLASS="Ep">which</EM>
specifies which of several trigger(s) is to be sensed.
<P>
For the PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards:
There are no general purpose trigger signals.
<P>
For the PIXCI&reg;&nbsp;D, D24, D32, D2X, D32, CL1, CL2, E1, E4, E1DB, SI, and CL3SD imaging boards:
The availability of general purpose triggers, and whether
they are sensitive to rising edges or falling edges
depends upon the board model, revision level, and video format configuration.
<P>
Note:
The general purpose trigger(s)
are those
''auxiliary''
features available on some imaging boards
where, at the hardware level, the signal has no direct effect
on video capture.
Use of this function to obtain the general purpose
trigger count is not needed for camera specific, hardware supported,
triggering features available on
some models of the PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, or CL3SD.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above, and may also return:
<DL>
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_goSnap NX230"CLASS="NX"></A>
<A NAME="pxd_goSnap"CLASS="Sf"></A>
<A NAME="Video Snap NX231"CLASS="NX"></A>
<A NAME="Video Snap   ---   pxd_goSnap"CLASS="Sf"></A>
<A NAME="Video Snap   ---   pxd_goSnap"></A>
<H6 CLASS="Sf">Video Snap   ---   pxd_goSnap</H6>
<A NAME="pxd_goSnapPair NX232"CLASS="NX"></A>
<A NAME="pxd_goSnapPair"CLASS="Sg"></A>
<A NAME="Video Snap Pair NX233"CLASS="NX"></A>
<A NAME="Video Snap Pair   ---   pxd_goSnapPair"CLASS="Sg"></A>
<A NAME="Video Snap Pair   ---   pxd_goSnapPair"></A>
<H6 CLASS="Sg">Video Snap Pair   ---   pxd_goSnapPair</H6>
<A NAME="pxd_goLive NX234"CLASS="NX"></A>
<A NAME="pxd_goLive"CLASS="Sg"></A>
<A NAME="Video Live NX235"CLASS="NX"></A>
<A NAME="Video Live   ---   pxd_goLive"CLASS="Sg"></A>
<A NAME="Video Live   ---   pxd_goLive"></A>
<H6 CLASS="Sg">Video Live   ---   pxd_goLive</H6>
<A NAME="pxd_goLivePair NX236"CLASS="NX"></A>
<A NAME="pxd_goLivePair"CLASS="Sg"></A>
<A NAME="Video Live Pair Alternate NX237"CLASS="NX"></A>
<A NAME="Video Live Pair Alternate   ---   pxd_goLivePair"CLASS="Sg"></A>
<A NAME="Video Live Pair Alternate   ---   pxd_goLivePair"></A>
<H6 CLASS="Sg">Video Live Pair Alternate   ---   pxd_goLivePair</H6>
<A NAME="pxd_goLiveSeq NX238"CLASS="NX"></A>
<A NAME="pxd_goLiveSeq"CLASS="Sg"></A>
<A NAME="Video Live Sequence NX239"CLASS="NX"></A>
<A NAME="Video Live Sequence   ---   pxd_goLiveSeq"CLASS="Sg"></A>
<A NAME="Video Live Sequence   ---   pxd_goLiveSeq"></A>
<H6 CLASS="Sg">Video Live Sequence   ---   pxd_goLiveSeq</H6>
<A NAME="pxd_goUnLive NX240"CLASS="NX"></A>
<A NAME="pxd_goUnLive"CLASS="Sg"></A>
<A NAME="Video UnLive NX241"CLASS="NX"></A>
<A NAME="Video UnLive   ---   pxd_goUnLive"CLASS="Sg"></A>
<A NAME="Video UnLive   ---   pxd_goUnLive"></A>
<H6 CLASS="Sg">Video UnLive   ---   pxd_goUnLive</H6>
<A NAME="pxd_goAbortLive NX242"CLASS="NX"></A>
<A NAME="pxd_goAbortLive"CLASS="Sg"></A>
<A NAME="Video Abort NX243"CLASS="NX"></A>
<A NAME="Video Abort   ---   pxd_goAbortLive"CLASS="Sg"></A>
<A NAME="Video Abort   ---   pxd_goAbortLive"></A>
<H6 CLASS="Sg">Video Abort   ---   pxd_goAbortLive</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_goSnap(unitmap, buffer);
int pxd_goSnapPair(unitmap, buffer1, buffer2);
int pxd_goLive(unitmap, buffer);
int pxd_goLivePair(unitmap, buffer, buffer2);
int pxd_goLiveSeq(unitmap, startbuf, endbuf, incbuf, numbuf, videoperiod);
int pxd_goUnLive(unitmap);
int pxd_goAbortLive(unitmap);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
pxbuffer_t          buffer2;        // Second image frame buffer
pxbuffer_t          startbuf;       // Starting image frame buffer
pxbuffer_t          endbuf;         // Ending image frame buffer
pxbuffer_t          incbuf;         // Image frame buffer number increment
pxbuffer_t          numbuf;         // Number of captured images
int                 videoperiod;    // Period between captured images
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
initiates capture of a single image into the
<EM CLASS="Ep">buffer</EM>,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>
initiates continuous capture of images into the
<EM CLASS="Ep">buffer</EM>,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>
initiates continuous capture into
<A HREF="#buffer"CLASS="Er">buffer</A>
and
<A HREF="#buffer2"CLASS="Er">buffer2</A>,
alternately
(i.e.
''ping-pong''),
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>
initiates sequence capture of images into
<EM CLASS="Ep">startbuf</EM>
through
<EM CLASS="Ep">endbuf</EM>,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
The sequence capture starts into
<EM CLASS="Ep">startbuf</EM>
and continues into frame buffers
<EM CLASS="Ep">startbuf</EM>+<EM CLASS="Ep">incbuf</EM>*1,
<EM CLASS="Ep">startbuf</EM>+<EM CLASS="Ep">incbuf</EM>*2,
etc., wrapping around from the
<EM CLASS="Ep">endbuf</EM>
back to the
<EM CLASS="Ep">startbuf</EM>.
Typically
<EM CLASS="Ep">incbuf</EM>=1
for use of consecutive ascending frame buffers.
The
<EM CLASS="Ep">numbuf</EM>
specifies the number image frame buffers
to be captured.
Typically,
<EM CLASS="Ep">numbuf</EM>
is
endbuf<EM CLASS="Ep">-</EM>startbuf<EM CLASS="Ep">+1</EM>
for simple sequence capture, or 0
for continuous (i.e.
''circular'')
sequence capture.
The
<EM CLASS="Ep">videoperiod</EM>
specifies the time interval, in video fields or frames,
between captured image frame buffers.
Typically,
<EM CLASS="Ep">videoperiod</EM>=1
for video rate capture.
For non-interlaced video formats, the
<EM CLASS="Ep">videoperiod</EM>
is in fields.
For interlaced video formats, the
<EM CLASS="Ep">videoperiod</EM>
is in units of frames,
unless,
a)&nbsp;Each image frame buffer is configured to
contain only one field, and
b)&nbsp;Video
''switching''
is configured to take place after the
''next'',
rather than after an
''odd''
or an
''even''
field.
<P>
The
<A HREF="#pxd_goSnapPair"CLASS="Er">pxd_goSnapPair</A>
initiates capture of a single image into the
<EM CLASS="Ep">buffer1</EM>
and initiates capture of the following image into the
<EM CLASS="Ep">buffer2</EM>,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>;
it is intended for use only with cameras with a so-called
''Triggered Dual Exposure''
mode.
<P>
The
<A HREF="#pxd_goUnLive"CLASS="Er">pxd_goUnLive</A>
terminates a previously initiated
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>,
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>,
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>,
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>,
or
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
after the current field or frame,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#pxd_goAbortLive"CLASS="Er">pxd_goAbortLive</A>
terminates a previously initiated
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>,
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>,
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>,
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>,
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>,
or
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>,
immediately, even if in the middle
of a field, line, or pixel,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
<P>
Except for
<A HREF="#pxd_goAbortLive"CLASS="Er">pxd_goAbortLive</A>,
these functions return
''immediately''
without waiting for the beginning or conclusion
of their stated effect.<A HREF="#Footnote 16"CLASS="Ff"><SUP>[16]</SUP></A>
The
<A HREF="#pxd_goAbortLive"CLASS="Er">pxd_goAbortLive</A>
both has effect and returns
''immediately''.
<P>
For PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and CL3SD configured for triggered
capture, the
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
''arms''
the imaging board to capture the next externally triggered
frame, or both
''arms''
and initiates a software triggered frame,
according to the Video Format Configuration.
<P>
For PIXCI&reg; CL3SD, the
<A HREF="#pxd_goAbortLive"CLASS="Er">pxd_goAbortLive</A>
currently behaves the same as
<A HREF="#pxd_goUnLive"CLASS="Er">pxd_goUnLive</A>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERRESOURCEBUSY<DD>
Video is already being captured
and must be terminated before
initiating a new capture
(for
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>,
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>,
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>,
or
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>).
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
See
<A HREF="#pxd_capturedBuffer"CLASS="Er">pxd_capturedBuffer</A>,
<A HREF="#pxd_capturedSysTicks"CLASS="Er">pxd_capturedSysTicks</A>,
and
<A HREF="#pxd_capturedFieldCount"CLASS="Er">pxd_capturedFieldCount</A>
to determine when an image frame buffer has been captured,
and thereby whether the above functions have completed their
complete capture
(such as for
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>)
or have completed the next step of their captured
(such as for
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>
or
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>).
<P>
See
<A HREF="#pxd_goneLive"CLASS="Er">pxd_goneLive</A>
to determine whether any video capture is in progress.
<P>
See
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
for an alternative to
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
that also waits for completion.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
This example illustrates a typical
video rate analysis task, analyzing
one captured video frame while the next
video frame is being captured into
a different frame buffer.
<BLOCKQUOTE>
<PRE>
    pxbuffer_t  lastbuf = 0;
    //
    // Initiate live, alternate, capture
    // in frame buffers 1 and 2.
    //
    pxd_goLivePair(1, 1, 2);
    //
    for (;;) {
        //
        // If a new buffer was not yet captured, wait.
        //
        if (pxd_capturedBuffer(1) == lastbuf) {
            Sleep(5);   // optional
            continue;
        }
        lastbuf = pxd_capturedBuffer(1);
        //
        // Call user-defined processing
        // on one buffer, while video
        // is being captured into the
        // alternate buffer.
        //
        user_process(lastbuf);
    }
</PRE>
</BLOCKQUOTE>
<HR SIZE="1">
<A NAME="pxd_goLiveTrig NX244"CLASS="NX"></A>
<A NAME="pxd_goLiveTrig"CLASS="Sf"></A>
<A NAME="Video Live Trigger NX245"CLASS="NX"></A>
<A NAME="Video Live Trigger   ---   pxd_goLiveTrig"CLASS="Sf"></A>
<A NAME="Video Live Trigger   ---   pxd_goLiveTrig"></A>
<H6 CLASS="Sf">Video Live Trigger   ---   pxd_goLiveTrig</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_goLiveTrig(unitmap, buffer, gpin10mask,gpout20value,gpout20mask,gpout20when,
                                    gpin30wait,gpin30mask,gpout40value,gpout40mask,
                                    option50,field50,gpout50value,gpout50mask,delay60,
                                    gpout60value,gpout60mask,delay70,field70,capture70,
                                    gpin80mask,gpout80value,gpout80mask);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
<BR>
                                    // Phase 1: initial reset of g.p.in:
uint                gpin10mask;     // g.p.in bit mask (for latching g.p.in)
<BR>
                                    // Phase 2: initial set of g.p.out
uint                gpout20value;   // g.p.out bit values
uint                gpout20mask;    // g.p.out bit mask
uint                gpout20when;    // 0: async to VB, 1: sync to VB
<BR>
                                    // Phase 3: wait for g.p.in change:
uint                gpin30wait;     // 0: no wait
                                    // 1: wait for change as sampled at VB
                                    // 3: wait for rising edge as sampled at VB
                                    // 5: wait for falling edge as sampled at VB
uint                gpin30mask;     // bit mask
<BR>
                                    // Phase 4: notify g.p.in change:
uint                gpout40value;   // g.p.out bit values
uint                gpout40mask;    // g.p.out bit mask
<BR>
                                    // Phase 5 &amp; 6: optional trig control:
uint                option50;       // 0: ignore, 1: do
uint                field50;        //    at next PXFIELD_NXT/ODD/EVN field
uint                gpout50value;   //    .. g.p.out bit values
uint                gpout50mask;    //    .. g.p.out bit mask
uint                delay60;        //    wait N fields
uint                gpout60value;   //    .. g.p.out bit values
uint                gpout60mask;    //    .. g.p.out bit mask
<BR>
                                    // Phase 7: delay and capture:
uint                delay70;        // wait N fields
uint                field70;        // at next PXFIELD_NXT/ODD/EVN field
uint                capture70;      // 0: capture
<BR>
                                    // Phase 8: notify capture:
uint                gpin80mask;     // reset g.p.in bits (for latching bits)
uint                gpout80value;   // g.p.out bit values
uint                gpout80mask;    // g.p.out bit mask
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
initiates triggered capture of a single image into the
<EM CLASS="Ep">buffer</EM>,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>,
using the
General Purpose Input/Output signals
to sense external events, and control
external devices as described by the
<EM CLASS="Ep">gpin10mask</EM>
through
<EM CLASS="Ep">gpout80mask</EM>
parameters.
<P>
The
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
is not intended, and not needed
for PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and CL3SD imaging boards
where the PIXCI&reg; combined with the camera hardware
provides dedicated triggering, typically asynchronous exposure, and
''single-shot''
capabilities.
The
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
is intended for cameras producing continuous
(free-run)
video, and where the imaging board's
General Purpose Input signals
initiation or termination of sequence capture without involvement
of any special feature of the camera.
<P>
The
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
implements continuous capture of multiple fields or frames
(i.e. effectively a
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>)
into the same
<EM CLASS="Ep">buffer</EM>
which at the appropriate time is terminated
(i.e. effectively a
<A HREF="#pxd_goUnLive"CLASS="Er">pxd_goUnLive</A>)
leaving the last captured field or frame.
<P>
The
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
is not available for PIXCI&reg; SV2 and SV3
imaging boards.
For PIXCI&reg; D, D24, and D32 imaging boards,
the actual non-zero value of
<EM CLASS="Ep">gpin30wait</EM>
is immaterial; the imaging board's hardware determines
the edge sensitivity of the General Purpose Input.
See
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>
and
<A HREF="#pxd_getGPOut"CLASS="Er">pxd_getGPOut</A>
for discussion of how many General Purpose Inputs and Outputs
are available on various imaging boards.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERRESOURCEBUSY<DD>
Video is already being captured
and must be terminated before
initiating a new capture.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_goLiveSeqTrig NX246"CLASS="NX"></A>
<A NAME="pxd_goLiveSeqTrig"CLASS="Sf"></A>
<A NAME="Video Live Sequence Trigger NX247"CLASS="NX"></A>
<A NAME="Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig"CLASS="Sf"></A>
<A NAME="Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig"></A>
<H6 CLASS="Sf">Video Live Sequence Trigger   ---   pxd_goLiveSeqTrig</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_goLiveSeqTrig(int unitmap, startbuf, endbuf, incbuf, numbuf, videoperiod,
                      rsvd1,rsvd2,trig20wait,trig20slct,trig20delay,rsvd3,rsvd4,
                      rsvd5,rsvd6,rsvd7,rsvd8,rsvd9,trig40wait,trig40slct,
                      trig40delay,rsvd10,rsvd11,rsvd12,rsvd13,rsvd14,rsvd15);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          startbuf;       // Starting image frame buffer
pxbuffer_t          endbuf;         // Ending image frame buffer
pxbuffer_t          incbuf;         // Image frame buffer number increment
pxbuffer_t          numbuf;         // Number of captured images
int                 videoperiod;    // Period between captured images
<BR>
uint                trig20wait;     // Trigger start of sequence upon:
                                    //    bits 0x001, 0x002, ... : a g.p. input
                                    //    bits 0x100, 0x200, ... : a g.p. trigger
uint                trig20slct;     // 1: wait for change as sampled at VB
                                    // 3: wait for rising edge as sampled at VB
                                    // 5: wait for falling edge as sampled at VB
pxvbtime_t          trig20delay;    // Delay effect by .. fields.
<BR>
uint                trig40wait;     // Trigger end of sequence upon:
                                    //    bits 0x001, 0x002, ... : a g.p. input
                                    //    bits 0x100, 0x200, ... : a g.p. trigger
uint                trig40slct;     // 1: wait for change as sampled at VB
                                    // 3: wait for rising edge as sampled at VB
                                    // 5: wait for falling edge as sampled at VB
pxvbtime_t          trig40delay;    // Delay effect by .. fields.
<BR>
int                 rsvd1;          // Reserved, should be 0.
                     ...
int                 rsvd15;         // Reserved, should be 0.
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
initiates sequence capture of images into
<EM CLASS="Ep">startbuf</EM>
through
<EM CLASS="Ep">endbuf</EM>,
on each of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
The
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
is a variation of
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>;
the
<EM CLASS="Ep">startbuf</EM>,
<EM CLASS="Ep">endbuf</EM>,
<EM CLASS="Ep">incbuf</EM>,
<EM CLASS="Ep">numbuf</EM>,
and
<EM CLASS="Ep">videoperiod</EM>
parameters have the same effect as the
corresponding parameter for
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>.
<P>
Unlike
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>,
the
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
allows initiating or allows terminating
(but currently not both), the sequence capture
in response to a General Purpose Input,
or a General Purpose Trigger.
<P>
While waiting for an initiating input or trigger,
the
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
implements continuous capture of multiple fields or frames
(i.e. effectively a
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>)
into the
<EM CLASS="Ep">startbuf</EM>.
<P>
If
<EM CLASS="Ep">trig20wait</EM>&ne;0,
the sequence capture starts
in response to a General Purpose Input,
or a General Purpose Trigger.
Bit 0x01 of
<EM CLASS="Ep">trig20wait</EM>
selects the first General Purpose Input,
bit 0x02 of
<EM CLASS="Ep">trig20wait</EM>
selects the second General Purpose Input
(if any), etc.
Bit 0x0100 of
<EM CLASS="Ep">trig20wait</EM>
selects the first General Purpose Trigger,
bit 0x0200 of
<EM CLASS="Ep">trig20wait</EM>
selects the second General Purpose Trigger
(if any), etc.
Only one bit of
<EM CLASS="Ep">trig20wait</EM>
should be set.
For General Purpose Inputs, the
<EM CLASS="Ep">trig20slct</EM>
selects which transition is to be used.
The effect on the start of sequence capture is delayed by
<EM CLASS="Ep">trig20delay</EM>
fields.
<P>
If
<EM CLASS="Ep">trig40wait</EM>&ne;0,
the sequence capture terminates
in response to a General Purpose Input,
or a General Purpose Trigger.
Bit 0x01 of
<EM CLASS="Ep">trig40wait</EM>
selects the first General Purpose Input,
bit 0x02 of
<EM CLASS="Ep">trig40wait</EM>
selects the second General Purpose Input
(if any), etc.
Bit 0x0100 of
<EM CLASS="Ep">trig40wait</EM>
selects the first General Purpose Trigger,
bit 0x0200 of
<EM CLASS="Ep">trig40wait</EM>
selects the second General Purpose Trigger
(if any), etc.
Only one bit of
<EM CLASS="Ep">trig40wait</EM>
should be set.
For General Purpose Inputs, the
<EM CLASS="Ep">trig40slct</EM>
selects which transition is to be used.
The effect on the termination of sequence capture is delayed by
<EM CLASS="Ep">trig40delay</EM>
fields.
<P>
The
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
is not intended, and not needed
for PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and CL3SD imaging boards
where the PIXCI&reg; combined with the camera hardware
provides dedicated triggering, typically asynchronous exposure, and
''single-shot''
capabilities.
The
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
is intended for cameras producing continuous
(free-run)
video, and where the imaging board's
General Purpose Input or General Purpose Trigger signals
are used to sense external events and implement an
initiation or termination of sequence capture without involvement
of any special feature of the camera.
<P>
The
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
is currently available only for PIXCI&reg; D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and CL3SD
imaging boards for use with non-interlaced cameras.<A HREF="#Footnote 17"CLASS="Ff"><SUP>[17]</SUP></A>
See
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>
and
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
for discussion of how many General Purpose Inputs and
General Purpose Triggers
are available on various imaging boards.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERRESOURCEBUSY<DD>
Video is already being captured
and must be terminated before
initiating a new capture.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_goneLive NX248"CLASS="NX"></A>
<A NAME="pxd_goneLive"CLASS="Sf"></A>
<A NAME="Check if Video Initiated NX249"CLASS="NX"></A>
<A NAME="Check if Video Initiated   ---   pxd_goneLive"CLASS="Sf"></A>
<A NAME="Check if Video Initiated   ---   pxd_goneLive"></A>
<H6 CLASS="Sf">Check if Video Initiated   ---   pxd_goneLive</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_goneLive(unitmap, rsvd);
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_goneLive"CLASS="Er">pxd_goneLive</A>
returns 0 if video capture
via
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>,
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>,
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>,
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>,
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>,
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>,
or
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
on any of the multiple units specified by
<EM CLASS="Ep">unitmap</EM>
is not currently in effect.
Otherwise, a non-zero value is returned.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<HR SIZE="1">
<A NAME="pxd_imageAspectRatio NX250"CLASS="NX"></A>
<A NAME="pxd_imageAspectRatio"CLASS="Sf"></A>
<A NAME="Get Frame Buffer Image Aspect Ratio NX251"CLASS="NX"></A>
<A NAME="Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio"CLASS="Sf"></A>
<A NAME="Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio"></A>
<H6 CLASS="Sf">Get Frame Buffer Image Aspect Ratio   ---   pxd_imageAspectRatio</H6>
<A NAME="pxd_imageBdim NX252"CLASS="NX"></A>
<A NAME="pxd_imageBdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Bit Depth NX253"CLASS="NX"></A>
<A NAME="Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim"></A>
<H6 CLASS="Sg">Get Frame Buffer Image Bit Depth   ---   pxd_imageBdim</H6>
<A NAME="pxd_imageCdim NX254"CLASS="NX"></A>
<A NAME="pxd_imageCdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Color Components NX255"CLASS="NX"></A>
<A NAME="Get Frame Buffer Image Color Components   ---   pxd_imageCdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Color Components   ---   pxd_imageCdim"></A>
<H6 CLASS="Sg">Get Frame Buffer Image Color Components   ---   pxd_imageCdim</H6>
<A NAME="pxd_imageIdim NX256"CLASS="NX"></A>
<A NAME="pxd_imageIdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Field Dimension NX257"CLASS="NX"></A>
<A NAME="Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim"></A>
<H6 CLASS="Sg">Get Frame Buffer Image Field Dimension   ---   pxd_imageIdim</H6>
<A NAME="pxd_imageXdim NX258"CLASS="NX"></A>
<A NAME="pxd_imageXdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Horizontal Dimension NX259"CLASS="NX"></A>
<A NAME="Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim"></A>
<H6 CLASS="Sg">Get Frame Buffer Image Horizontal Dimension   ---   pxd_imageXdim</H6>
<A NAME="pxd_imageYdim NX260"CLASS="NX"></A>
<A NAME="pxd_imageYdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Vertical Dimension NX261"CLASS="NX"></A>
<A NAME="Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim"></A>
<H6 CLASS="Sg">Get Frame Buffer Image Vertical Dimension   ---   pxd_imageYdim</H6>
<A NAME="pxd_imageZdim NX262"CLASS="NX"></A>
<A NAME="pxd_imageZdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Count NX263"CLASS="NX"></A>
<A NAME="Get Frame Buffer Image Count   ---   pxd_imageZdim"CLASS="Sg"></A>
<A NAME="Get Frame Buffer Image Count   ---   pxd_imageZdim"></A>
<H6 CLASS="Sg">Get Frame Buffer Image Count   ---   pxd_imageZdim</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
double pxd_imageAspectRatio();
int    pxd_imageBdim();
int    pxd_imageCdim();
int    pxd_imageIdim();
int    pxd_imageXdim()
int    pxd_imageYdim();
int    pxd_imageZdim();
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The dimensions or other characteristics
of the image frame buffer(s) are returned.
<P>
The
<A HREF="#pxd_imageAspectRatio"CLASS="Er">pxd_imageAspectRatio</A>
returns the aspect ratio of a single pixel of the image;
defined as the pixel's height divided by the pixel's width.
For some cameras and/or imaging boards,
the aspect ratio may not be known - a value
of 0 is returned.
<P>
The
<A HREF="#pxd_imageBdim"CLASS="Er">pxd_imageBdim</A>
returns the number of significant bits in
each color component of a pixel,
or in the single monochrome component of a pixel.
For example, for a high quality so-called
''10 bit per pixel color camera''
which produces 30 bits of RGB for each pixel,
the
<A HREF="#pxd_imageBdim"CLASS="Er">pxd_imageBdim</A>
returns 10.<A HREF="#Footnote 18"CLASS="Ff"><SUP>[18]</SUP></A>
<P>
The
<A HREF="#pxd_imageCdim"CLASS="Er">pxd_imageCdim</A>
returns the number of component values per pixel,
often referred to as
''pixies'',
typically one for monochrome imagery or three for color imagery.
The value returned
is the number of
component colors in the
natural or common
interpretation of the image,
and not necessarily the number of components output by the
camera or imaging board.
For example, three is returned, representing the common
RGB interpretation, for each of:
a)&nbsp;An imaging board which
stores YUYV or YCrCb&nbsp;4:2:2 as two components per pixel,
b)&nbsp;An imaging board which
stores Bayer pattern color as one component per pixel,
c)&nbsp;An imaging board which
stores RGB+Pad as 4 components per pixel.
<P>
The
<A HREF="#pxd_imageIdim"CLASS="Er">pxd_imageIdim</A>
returns the number of video fields
in am image frame buffer.
The value is one for non-interlaced video formats.
For interlaced video formats the value may be
two if each frame buffer provides storage for both fields,
or one if each frame buffer provides storage for a single field.<A HREF="#Footnote 19"CLASS="Ff"><SUP>[19]</SUP></A>
<P>
The
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>
returns the number of pixels in a horizontal line.
<P>
The
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>
returns the number of pixels in a vertical column.<A HREF="#Footnote 20"CLASS="Ff"><SUP>[20]</SUP></A>
<P>
The
<A HREF="#pxd_imageZdim"CLASS="Er">pxd_imageZdim</A>
returns the number of image frame buffers.
If multiple imaging boards are in use,
the
<A HREF="#pxd_imageZdim"CLASS="Er">pxd_imageZdim</A>
returns the number of image frame buffers
assigned to each imaging board.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<P>
If the library is not open for use,
the
<A HREF="#pxd_imageAspectRatio"CLASS="Er">pxd_imageAspectRatio</A>
returns 0,
the other functions return PXERNOTOPEN.
<HR SIZE="1">
<A NAME="pxd_infoDriverId NX264"CLASS="NX"></A>
<A NAME="pxd_infoDriverId"CLASS="Sf"></A>
<A NAME="Get Imaging Board Driver ID NX265"CLASS="NX"></A>
<A NAME="Get Imaging Board Driver ID   ---   pxd_infoDriverId"CLASS="Sf"></A>
<A NAME="Get Imaging Board Driver ID   ---   pxd_infoDriverId"></A>
<H6 CLASS="Sf">Get Imaging Board Driver ID   ---   pxd_infoDriverId</H6>
<A NAME="pxd_infoIncludeId NX266"CLASS="NX"></A>
<A NAME="pxd_infoIncludeId"CLASS="Sg"></A>
<A NAME="Get Imaging Board Include Files ID NX267"CLASS="NX"></A>
<A NAME="Get Imaging Board Include Files ID   ---   pxd_infoIncludeId"CLASS="Sg"></A>
<A NAME="Get Imaging Board Include Files ID   ---   pxd_infoIncludeId"></A>
<H6 CLASS="Sg">Get Imaging Board Include Files ID   ---   pxd_infoIncludeId</H6>
<A NAME="pxd_infoLibraryId NX268"CLASS="NX"></A>
<A NAME="pxd_infoLibraryId"CLASS="Sg"></A>
<A NAME="Get Imaging Board Library ID NX269"CLASS="NX"></A>
<A NAME="Get Imaging Board Library ID   ---   pxd_infoLibraryId"CLASS="Sg"></A>
<A NAME="Get Imaging Board Library ID   ---   pxd_infoLibraryId"></A>
<H6 CLASS="Sg">Get Imaging Board Library ID   ---   pxd_infoLibraryId</H6>
<A NAME="pxd_infoMemsize NX270"CLASS="NX"></A>
<A NAME="pxd_infoMemsize"CLASS="Sg"></A>
<A NAME="Get Imaging Board's Frame Buffer Size NX271"CLASS="NX"></A>
<A NAME="Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize"CLASS="Sg"></A>
<A NAME="Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize"></A>
<H6 CLASS="Sg">Get Imaging Board's Frame Buffer Size   ---   pxd_infoMemsize</H6>
<A NAME="pxd_infoModel NX272"CLASS="NX"></A>
<A NAME="pxd_infoModel"CLASS="Sg"></A>
<A NAME="Get Imaging Board's Model NX273"CLASS="NX"></A>
<A NAME="Get Imaging Board's Model   ---   pxd_infoModel"CLASS="Sg"></A>
<A NAME="Get Imaging Board's Model   ---   pxd_infoModel"></A>
<H6 CLASS="Sg">Get Imaging Board's Model   ---   pxd_infoModel</H6>
<A NAME="pxd_infoSubmodel NX274"CLASS="NX"></A>
<A NAME="pxd_infoSubmodel"CLASS="Sg"></A>
<A NAME="Get Imaging Board's Submodel NX275"CLASS="NX"></A>
<A NAME="Get Imaging Board's Submodel   ---   pxd_infoSubmodel"CLASS="Sg"></A>
<A NAME="Get Imaging Board's Submodel   ---   pxd_infoSubmodel"></A>
<H6 CLASS="Sg">Get Imaging Board's Submodel   ---   pxd_infoSubmodel</H6>
<A NAME="pxd_infoUnits NX276"CLASS="NX"></A>
<A NAME="pxd_infoUnits"CLASS="Sg"></A>
<A NAME="Get Imaging Board Unit Count NX277"CLASS="NX"></A>
<A NAME="Get Imaging Board Unit Count   ---   pxd_infoUnits"CLASS="Sg"></A>
<A NAME="Get Imaging Board Unit Count   ---   pxd_infoUnits"></A>
<H6 CLASS="Sg">Get Imaging Board Unit Count   ---   pxd_infoUnits</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
char*  pxd_infoDriverId();
char*  pxd_infoIncludeId();
char*  pxd_infoLibraryId();
int    pxd_infoMemsize(unitmap);
int    pxd_infoModel(unitmap);
int    pxd_infoSubmodel(unitmap);
int    pxd_infoUnits();
<BR>
int             unitmap;            // Unit selection bit map (1 for single unit)
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Identification or other characteristics
of the library, driver, and imaging board(s)
are returned.
<P>
The
<A HREF="#pxd_infoDriverId"CLASS="Er">pxd_infoDriverId</A>
returns the identification string of the current
imaging board driver.
<P>
The
<A HREF="#pxd_infoIncludeId"CLASS="Er">pxd_infoIncludeId</A>
''returns''
the identification string of the current
include (i.e. the
''.h'')
files.
As
<A HREF="#pxd_infoIncludeId"CLASS="Er">pxd_infoIncludeId</A>
is intended to provide the
the identification string of the current
include files, it can't be an actual pre-compiled function.
However, it can be used as if it were, such as:
<BLOCKQUOTE>
<PRE>
    printf(&quot;%s&quot;, pxd_infoIncludeId());
</PRE>
</BLOCKQUOTE>
or
<BLOCKQUOTE>
<PRE>
    if (strcmp(pxd_infoIncludeId(), pxd_infoLibraryId))
        printf(&quot;Probable DLL mismatch\n&quot;);
</PRE>
</BLOCKQUOTE>
<P>
The
<A HREF="#pxd_infoLibraryId"CLASS="Er">pxd_infoLibraryId</A>
returns the identification string of the current
imaging board library.
<P>
The
<A HREF="#pxd_infoMemsize"CLASS="Er">pxd_infoMemsize</A>
returns the size in bytes of the frame buffer memory
associated with the single selected
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#pxd_infoModel"CLASS="Er">pxd_infoModel</A>
returns the model designation associated with the
single selected
<EM CLASS="Ep">unitmap</EM>.
Current values are:
<BLOCKQUOTE>
<PRE>
    PIXCI_SV2       // the PIXCI&reg; SV2 Imaging Board
    PIXCI_SV3       // the PIXCI&reg; SV3 Imaging Board
    PIXCI_SV4       // the PIXCI&reg; SV4 Imaging Board
    PIXCI_SV5       // the PIXCI&reg; SV5, SV5A Imaging Board
    PIXCI_D         // the PIXCI&reg; D, D24, D32 Imaging Board
    PIXCI_D24       // the PIXCI&reg; D24 Imaging Board
    PIXCI_D32       // the PIXCI&reg; D32 Imaging Board
    PIXCI_D2X       // the PIXCI&reg; D2X Imaging Board
    PIXCI_D3X       // the PIXCI&reg; D3X Imaging Board
    PIXCI_A         // the PIXCI&reg; A Imaging Board
    PIXCI_CL1       // the PIXCI&reg; CL1 Imaging Board
    PIXCI_CL2       // the PIXCI&reg; CL2 Imaging Board
    PIXCI_E1        // the PIXCI&reg; E1 Imaging Board
    PIXCI_E4        // the PIXCI&reg; E4 Imaging Board
    PIXCI_E1DB      // the PIXCI&reg; E1DB Imaging Board
    PIXCI_CL3SD     // the PIXCI&reg; CL3SD Imaging Board
    PIXCI_SI        // the PIXCI&reg; SI Imaging Board
</PRE>
</BLOCKQUOTE>
where these are constants defined by inclusion of
<CODE CLASS="Em">xcliball.h</CODE>.
Note that PIXCI&reg;&nbsp;D24, and D32 imaging boards
may be identified as a PIXCI&reg;&nbsp;D imaging board.
<P>
The
<A HREF="#pxd_infoSubmodel"CLASS="Er">pxd_infoSubmodel</A>
returns the submodel designation associated with the
single selected
<EM CLASS="Ep">unitmap</EM>.
For PIXCI&reg; SV2, SV3, SV4, and SV5 imaging boards the value is 0.
For PIXCI&reg; SV5A imaging boards the value is the predefined
constant PIXCI_SV5_SV5A.
For PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, SI, and A imaging boards
that are customized for specific cameras, the value
is a code indicating the specific camera.
<P>
The
<A HREF="#pxd_infoUnits"CLASS="Er">pxd_infoUnits</A>
returns the number of imaging boards
(i.e.
''units'')
that the library has open and available for use.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above
<P>
If the library is not open for use,
the
<A HREF="#pxd_infoLibraryId"CLASS="Er">pxd_infoLibraryId</A>
and
<A HREF="#pxd_infoDriverId"CLASS="Er">pxd_infoDriverId</A>
return NULL,
the other functions return 0.
<HR SIZE="1">
<A NAME="pxd_loadBmp NX278"CLASS="NX"></A>
<A NAME="pxd_loadBmp"CLASS="Sf"></A>
<A NAME="Load Image: BMP Format NX279"CLASS="NX"></A>
<A NAME="Load Image: BMP Format   ---   pxd_loadBmp"CLASS="Sf"></A>
<A NAME="Load Image: BMP Format   ---   pxd_loadBmp"></A>
<H6 CLASS="Sf">Load Image: BMP Format   ---   pxd_loadBmp</H6>
<A NAME="pxd_loadTiff NX280"CLASS="NX"></A>
<A NAME="pxd_loadTiff"CLASS="Sg"></A>
<A NAME="Load Image: TIFF Format NX281"CLASS="NX"></A>
<A NAME="Load Image: TIFF Format   ---   pxd_loadTiff"CLASS="Sg"></A>
<A NAME="Load Image: TIFF Format   ---   pxd_loadTiff"></A>
<H6 CLASS="Sg">Load Image: TIFF Format   ---   pxd_loadTiff</H6>
<A NAME="pxd_saveBmp NX282"CLASS="NX"></A>
<A NAME="pxd_saveBmp"CLASS="Sg"></A>
<A NAME="Save Image: BMP Format NX283"CLASS="NX"></A>
<A NAME="Save Image: BMP Format   ---   pxd_saveBmp"CLASS="Sg"></A>
<A NAME="Save Image: BMP Format   ---   pxd_saveBmp"></A>
<H6 CLASS="Sg">Save Image: BMP Format   ---   pxd_saveBmp</H6>
<A NAME="pxd_savePcx NX284"CLASS="NX"></A>
<A NAME="pxd_savePcx"CLASS="Sg"></A>
<A NAME="Save Image: PCX Format NX285"CLASS="NX"></A>
<A NAME="Save Image: PCX Format   ---   pxd_savePcx"CLASS="Sg"></A>
<A NAME="Save Image: PCX Format   ---   pxd_savePcx"></A>
<H6 CLASS="Sg">Save Image: PCX Format   ---   pxd_savePcx</H6>
<A NAME="pxd_saveTga NX286"CLASS="NX"></A>
<A NAME="pxd_saveTga"CLASS="Sg"></A>
<A NAME="Save Image: TARGA Format NX287"CLASS="NX"></A>
<A NAME="Save Image: TARGA Format   ---   pxd_saveTga"CLASS="Sg"></A>
<A NAME="Save Image: TARGA Format   ---   pxd_saveTga"></A>
<H6 CLASS="Sg">Save Image: TARGA Format   ---   pxd_saveTga</H6>
<A NAME="pxd_saveTiff NX288"CLASS="NX"></A>
<A NAME="pxd_saveTiff"CLASS="Sg"></A>
<A NAME="Save Image: TIFF Format NX289"CLASS="NX"></A>
<A NAME="Save Image: TIFF Format   ---   pxd_saveTiff"CLASS="Sg"></A>
<A NAME="Save Image: TIFF Format   ---   pxd_saveTiff"></A>
<H6 CLASS="Sg">Save Image: TIFF Format   ---   pxd_saveTiff</H6>
<BR>
<A NAME="TIFF Format NX290"CLASS="NX"></A>
<A NAME="BMP Format NX291"CLASS="NX"></A>
<A NAME="TARGA Format NX292"CLASS="NX"></A>
<A NAME="PCX Format NX293"CLASS="NX"></A>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_loadBmp (unitmap, pathname, framebuf, ulx, uly, lrx, lry, loadmode, options);
int pxd_loadTiff(unitmap, pathname, framebuf, ulx, uly, lrx, lry, loadmode, options);
int pxd_saveBmp (unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
int pxd_savePcx (unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
int pxd_saveTga (unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
int pxd_saveTiff(unitmap, pathname, framebuf, ulx, uly, lrx, lry, savemode, options);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
char                *pathname;      // File path name to load from, or save to
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
int                 loadmode;       // Resize: 'b': Bilinear, 'n': Nearest neighbor
                                    // Color Space: 0x100: convert, 0: no convert
int                 savemode;       // Reserved, should be 0
int                 options;        // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
An image frame buffer, or an area of interest within the frame buffer,
is loaded from, or saved to, a file named
<EM CLASS="Ep">pathname</EM>.
For
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>
and
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>
the image is loaded or saved in
the Windows Device Independent Bitmap File format
(i.e.
''.bmp''
or
''.dib'').
For
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>
and
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>
the image is loaded or saved in
the Tagged Image File Format (TIFF)
(i.e.
''.tif'').
For
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>
the image is saved in
the
''PCX''
graphics file format
(i.e.
''.pcx'').
For
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>
the image is saved in
the
''Targa''
file format
(i.e.
''.tga'').
<P>
The
<EM CLASS="Ep">pathname</EM>
may include a directory path,<A HREF="#Footnote 21"CLASS="Ff"><SUP>[21]</SUP></A>
and may include a file suffix
(i.e.
''.bmp'',
''.tif'',
''.tga'',
or
''.pcx'')
as desired; these functions
do not require, or force, any specific suffix.
For
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>,
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>,
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>,
and
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>
any existing file
<EM CLASS="Ep">pathname</EM>
is deleted and a new file
<EM CLASS="Ep">pathname</EM>
created.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit from which, or to which,
an image is to saved or loaded.
The
<EM CLASS="Ep">framebuf</EM>,
1&lt;=<EM CLASS="Ep">framebuf</EM>&lt;=<EM CLASS="Ep">pxd_imageZdim(),</EM>
specifies the image frame buffer from which, or to which,
an image is to be saved or loaded.
The
<EM CLASS="Ep">ulx</EM>
and
<EM CLASS="Ep">uly</EM>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>())
or the extreme bottom vertical coordinate
(i.e.
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>()),
respectively.
<P>
For
<A HREF="#pxd_bmpLoad"CLASS="Er">pxd_bmpLoad</A>
and
<A HREF="#pxd_tiffLoad"CLASS="Er">pxd_tiffLoad</A>:
The loaded image is resized, as necessary, to fit
the specified frame buffer and area of interest.
If
<EM CLASS="Ep">loadmode</EM>='b',
the image is resized by bilinear interpolation,
which is suitable for continuous tone images.
If
<EM CLASS="Ep">loadmode</EM>='n',
the image is resized by nearest neighbor interpolation,
which is particularly suitable for graphics or false colored images,
as it avoids the generation of pixel values, via interpolation, which may
not exist in the original image.
If
<EM CLASS="Ep">loadmode</EM>&amp;0x100
the loaded image's pixels are converted to the
specified frame buffer's color space.
Pixel values are converted to be most significant bit aligned;
for example a TIFF file with 1 bit per pixel loaded into an image
frame buffer with 8 bit pixels
yields pixel values of 0 and 128.
<P>
For
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>:
Color image frame buffers are saved as 24 bit RGB pixels
without compression.
Monochrome image frame buffers are saved
as 8 bit pixels with a monochrome, identity, palette
without compression.
<P>
For
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>:
Color image frame buffers are saved as RGB pixels without compression,
monochrome image frame buffers are saved as monochrome pixels without compression,
each with the same number of bits per pixel as the image frame buffer.
<P>
For
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>:
Color image frame buffers are saved as 24 bit RGB pixels.
Monochrome image frame buffers are saved
as 8 bit pixels without a palette.
<P>
For
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>:
Color image frame buffers are saved as 24 bit RGB pixels.
Monochrome image frame buffers are saved
as 8 bit pixels without a palette.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Image frame buffer loaded or saved.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERNOMODE<DD>
File format uses unsupported options
(for
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>
and
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>).
<BR><DT>PXERFILEFORM<DD>
Invalid file format
(for
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>
and
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>).
<BR><DT>PXERMALLOC<DD>
Memory allocation error.
<BR><DT>PXERDOSIO<DD>
Operating system I/O error while reading or writing file.
<BR><DT>PXERNEWFILE<DD>
Can't create
<EM CLASS="Ep">pathname</EM>
(for
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>,
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>,
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>,
and
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>).
<BR><DT>PXERNOFILE<DD>
Can't find
<EM CLASS="Ep">pathname</EM>
(for
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>
and
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>).
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
The entire AOI of all image frame buffers are
saved to a sequence of TIFF formatted files.
<BLOCKQUOTE>
<PRE>
int     framebuf;
char    name[20];
<BR>
for (framebuf = 1; framebuf &lt;= pxd_imageZdim(); framebuf++) {
    sprintf(name, &quot;abc%.5d.tif&quot;, framebuf);
    pxd_saveTiff(1, name, framebuf, 0, 0, -1, -1, 0, 0);
}
</PRE>
</BLOCKQUOTE>
<HR SIZE="1">
<A NAME="pxd_loadRawBuffers NX294"CLASS="NX"></A>
<A NAME="pxd_loadRawBuffers"CLASS="Sf"></A>
<A NAME="Load Frame Buffers NX295"CLASS="NX"></A>
<A NAME="Load Frame Buffers   ---   pxd_loadRawBuffers"CLASS="Sf"></A>
<A NAME="Load Frame Buffers   ---   pxd_loadRawBuffers"></A>
<H6 CLASS="Sf">Load Frame Buffers   ---   pxd_loadRawBuffers</H6>
<A NAME="pxd_saveRawBuffers NX296"CLASS="NX"></A>
<A NAME="pxd_saveRawBuffers"CLASS="Sg"></A>
<A NAME="Save Frame Buffers NX297"CLASS="NX"></A>
<A NAME="Save Frame Buffers   ---   pxd_saveRawBuffers"CLASS="Sg"></A>
<A NAME="Save Frame Buffers   ---   pxd_saveRawBuffers"></A>
<H6 CLASS="Sg">Save Frame Buffers   ---   pxd_saveRawBuffers</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_loadRawBuffers(unitmap, pathname, startbuf, endbuf, filehandle, fileoffset, alignment, options);
int pxd_saveRawBuffers(unitmap, pathname, startbuf, endbuf, filehandle, fileoffset, alignment, options);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
char                *pathname;      // File path name to load from, or save to
pxbuffer_t          startbuf;       // Starting image frame buffer
pxbuffer_t          endbuf;         // Ending image frame buffer, inclusive
void                *filehandle;    // Existing file handle to be read or written, or NULL
pxbuffer_t          fileoffset;     // Offset into file, in units of image frame buffers
uint32              alignsector;    // Pad image frame buffer size to multiple of ...
int                 options;        // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
A sequence of one or more consecutive image frame buffers
is saved to, for
<A HREF="#saveRawBuffers"CLASS="Er">saveRawBuffers</A>,
or loaded from, for
<A HREF="#loadRawBuffers"CLASS="Er">loadRawBuffers</A>,
a file.
<P>
If
<EM CLASS="Ep">pathname</EM>&ne;NULL,
the image frame buffers are saved to, or loaded from, the
<EM CLASS="Ep">pathname</EM>;
for
<A HREF="#saveRawBuffers"CLASS="Er">saveRawBuffers</A>
an already existing
is not deleted and recreated, but partially or fully overwritten
allowable replacement of one or more images within an existing file.<A HREF="#Footnote 22"CLASS="Ff"><SUP>[22]</SUP></A>
Alternately, a
<EM CLASS="Ep">filehandle</EM>&ne;NULL,
to a file previously opened by the application may be supplied.
Under Windows the
<EM CLASS="Ep">filehandle</EM>
is expected to be a
<CITE CLASS="Ec">HANDLE</CITE>
provided by
<CITE CLASS="Ec">CreateFile</CITE>.
Under Linux the
<EM CLASS="Ep">filehandle</EM>
is expected to be a
''file descriptor''
provided by
<CITE CLASS="Ec">_open</CITE>.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit from which, or to which,
image frame buffers are to be saved or loaded.
The
<EM CLASS="Ep">startbuf</EM>
and
<EM CLASS="Ep">endbuf</EM>,
<EM CLASS="Ep">startbuf</EM>&lt;=<EM CLASS="Ep">endbuf</EM>,
specify the first and last image frame buffers, inclusive,
to be saved or loaded.
The entire image frame buffer is loaded or saved.
<P>
Each image frame buffer is saved to, or loaded from,
the file sequentially starting at position
<EM CLASS="Ep">fileoffset</EM>,
where
<EM CLASS="Ep">fileoffset</EM>
is interpreted in units
of the size of an image frame buffer.
For example,
<EM CLASS="Ep">fileoffset</EM>=0
starts at the beginning of the file,
while
<EM CLASS="Ep">fileoffset</EM>=1
starts with the second image frame buffer in the file.
If
<EM CLASS="Ep">alignsector</EM>&ne;0,
the size of each saved image frame buffer, and thus the starting position
relative to the beginning of the file, is padded to a multiple
of
<EM CLASS="Ep">alignsector</EM>
bytes; typically so that each saved image frame buffer can
be aligned on a multiple of the file system's sector size,
or the operating system's virtual page size.
<P>
The image frame buffers are saved or loaded
with a file format which is an exact copy, byte for byte, of
the imaging board's frame buffer memory.
The file format is intended for efficient saving and loading
of image frame buffers; the actual format will vary
with different imaging boards, or different video formats
with a single imaging board.
Use of these functions, and the file format created,
is contraindicated for export to other
(i.e. non-EPIX&reg; imaging software) applications.
Use is also contraindicated for archival storage,
as reloading an image requires the presence of the same
imaging board set to the same video format.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERNOFILE<DD>
File doesn't exist (for
<A HREF="#loadRawBuffers"CLASS="Er">loadRawBuffers</A>).
<BR><DT>PXERNEWFILE<DD>
File can't be created (for
<A HREF="#saveRawBuffers"CLASS="Er">saveRawBuffers</A>).
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_mesgErrorCode NX298"CLASS="NX"></A>
<A NAME="pxd_mesgErrorCode"CLASS="Sf"></A>
<A NAME="Errors: Translate Error Code to String NX299"CLASS="NX"></A>
<A NAME="Errors: Translate Error Code to String   ---   pxd_mesgErrorCode"CLASS="Sf"></A>
<A NAME="Errors: Translate Error Code to String   ---   pxd_mesgErrorCode"></A>
<H6 CLASS="Sf">Errors: Translate Error Code to String   ---   pxd_mesgErrorCode</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
char* pxd_mesgErrorCode(errorcode);
int                 errorcode;          // Error return code
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Any of the
''PXER...''
error codes returned by various library functions,
given as the
<EM CLASS="Ep">errorcode</EM>
parameter, is translated and returned as a suitable, concise, NULL terminated
error message string.
A NULL value is returned if
<EM CLASS="Ep">errorcode</EM>
is not a recognized
''PXER...''
code.
<P>
The
''PXER...''
codes are defined in
<CODE CLASS="Em">pxerrno.h</CODE>,
included via
<CODE CLASS="Em">xcliball.h</CODE>.
Programs should never assume specific values of these error codes,
but may assume that all error codes are negative
and that 0 and positive values
are reserved for nonerror conditions.
Thus, if an arbitrary
''library_function''
is described to return
''PXER...''
codes, the assumptions utilized in:
<BLOCKQUOTE>
<PRE>
int i;
if ((i = library_function(...)) &lt; 0) {
   printf(&quot;error %s\n&quot;, pxd_mesgErrorCode(i));
   return;
}
</PRE>
</BLOCKQUOTE>
or in:
<BLOCKQUOTE>
<PRE>
char *cp;
if ((cp = pxd_mesgErrorCode(library_function(...)))) {
   printf(&quot;error %s\n&quot;, cp);
   return;
}
</PRE>
</BLOCKQUOTE>
are valid.
<P>
The
<A HREF="#pxd_mesgErrorCode"CLASS="Er">pxd_mesgErrorCode</A>
may be invoked even if the library is
not open for use.
<P>
The
<A HREF="#pxd_mesgErrorCode"CLASS="Er">pxd_mesgErrorCode</A>
is functionally identical to the
<CITE CLASS="Ec">pxerrnomesg</CITE>
mentioned in the
<CITE CLASS="Ec">PXIPL Image Processing Library Reference Manual</CITE>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
A char&nbsp;* to an error message, or NULL.
<HR SIZE="1">
<A NAME="pxd_mesgFault NX300"CLASS="NX"></A>
<A NAME="pxd_mesgFault"CLASS="Sf"></A>
<A NAME="Errors: Check &amp; Report Faults NX301"CLASS="NX"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   pxd_mesgFault"CLASS="Sf"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   pxd_mesgFault"></A>
<H6 CLASS="Sf">Errors: Check &amp; Report Faults   ---   pxd_mesgFault</H6>
<A NAME="pxd_mesgFaultText NX302"CLASS="NX"></A>
<A NAME="pxd_mesgFaultText"CLASS="Sg"></A>
<A NAME="Errors: Check &amp; Report Faults NX303"CLASS="NX"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText"CLASS="Sg"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText"></A>
<H6 CLASS="Sg">Errors: Check &amp; Report Faults   ---   pxd_mesgFaultText</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_mesgFault(unitmap);
int pxd_mesgFaultText(unitmap, buf, bufsize);
int                 unitmap;        // Unit selection bit map (1 for single unit)
char                *buf;           // 'Returned' fault text
int                 bufsize;        // Size of *buf
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
checks whether a fault has occurred since the last check,
and if so displays a description of the fault.
The
<A HREF="#pxd_mesgFaultText"CLASS="Er">pxd_mesgFaultText</A>
checks whether a fault has occurred since the last check,
and if so
''returns''
a description of the fault in
''buf''.
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit for which faults
are checked and displayed.
<P>
Under Windows, the
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
displays the description of the fault in a Windows MessageBox.
Under other environments, the
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
displays the description of the fault to
''stderr''.
<P>
Alternately, the
<A HREF="#pxd_mesgFaultText"CLASS="Er">pxd_mesgFaultText</A>
returns into
<EM CLASS="Ep">buf</EM>,
which is assumed to be of size
<EM CLASS="Ep">bufsize</EM>,
essentially the same description as would be displayed by
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
but without the
''boilerplate''
such as:
<BLOCKQUOTE>
<PRE>
    &quot;Configuration Error or Fault&quot;
        ...
        ...
    &quot;Check Configuration!&quot;
    &quot;See `Installation' and `In Case of Trouble' in ...&quot;
</PRE>
</BLOCKQUOTE>
The
<A HREF="#pxd_mesgFaultText"CLASS="Er">pxd_mesgFaultText</A>'s
return code does not indicate whether the
<EM CLASS="Ep">buf</EM>
was too small; if after calling
<A HREF="#pxd_mesgFaultText"CLASS="Er">pxd_mesgFaultText</A>
<BLOCKQUOTE>
<PRE>
    strlen(buf)==bufsize
</PRE>
</BLOCKQUOTE>
then the
<EM CLASS="Ep">buf</EM>
was too small and the remainder of the fault's
description was lost.
A
<EM CLASS="Ep">bufsize</EM>
of 1024
is sufficient for current fault descriptions and is suggested.
<P>
Faults are not related to PXER... error codes.
Rather, faults are typically asynchronous events,
such as reporting that the video signal
has been interrupted or corrupted.
Faults are not the error description,
if any, of the last called library function,
with the exception that after
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
fails, the
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
or
<A HREF="#pxd_mesgFaultText"CLASS="Er">pxd_mesgFaultText</A>
may show additional information about the cause of failure.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>1<DD>
Fault occurred and was displayed.
<BR><DT>0<DD>
No fault occurred.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_PIXCIopen NX304"CLASS="NX"></A>
<A NAME="pxd_PIXCIopen"CLASS="Sf"></A>
<A NAME="PIXCI&reg; Imaging Board: Open and Set Video Format Configuration NX305"CLASS="NX"></A>
<A NAME="PIXCI&reg; Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen"CLASS="Sf"></A>
<A NAME="PIXCI&reg; Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen"></A>
<H6 CLASS="Sf">PIXCI&reg; Imaging Board: Open and Set Video Format Configuration   ---   pxd_PIXCIopen</H6>
<A NAME="pxd_PIXCIclose NX306"CLASS="NX"></A>
<A NAME="pxd_PIXCIclose"CLASS="Sg"></A>
<A NAME="PIXCI&reg; Imaging Board: Close NX307"CLASS="NX"></A>
<A NAME="PIXCI&reg; Imaging Board: Close   ---   pxd_PIXCIclose"CLASS="Sg"></A>
<A NAME="PIXCI&reg; Imaging Board: Close   ---   pxd_PIXCIclose"></A>
<H6 CLASS="Sg">PIXCI&reg; Imaging Board: Close   ---   pxd_PIXCIclose</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_PIXCIopen(driverparms, formatname, formatfile);
int pxd_PIXCIclose();
<BR>
char                *driverparms;   // Driver configuration parms, or NULL or &quot;&quot;
char                *formatname;    // Video format configuration name, or NULL or &quot;&quot;
char                *formatfile;    // Video format configuration file name, or NULL or &quot;&quot;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The PIXCI&reg; XCLIB Library and Driver is opened
using driver configuration parameters specified by
<EM CLASS="Ep">driverparms</EM>
and either the name of a predefined video format specified by
<EM CLASS="Ep">formatname</EM>
or the file name of a saved video format specified by
<EM CLASS="Ep">formatfile</EM>.<A HREF="#Footnote 23"CLASS="Ff"><SUP>[23]</SUP></A>
The library and driver must be opened before any other library function
is invoked, except for those functions that explicitly note otherwise.
Once open, the PIXCI&reg; library and driver
should be closed by
<A HREF="#pxd_PIXCIclose"CLASS="Er">pxd_PIXCIclose</A>
before the program exits.
<P>
The
<EM CLASS="Ep">driverparms</EM>
should be a Driver Configuration Parameter string
as described in
<A HREF="#Installation and Configuration &mdash; Run Time"CLASS="Er">Installation and Configuration &mdash; Run Time</A>.
When building an application program whose end-users
would need to select the hardware configuration parameters, the
<EM CLASS="Ep">driverparms</EM>
might be obtained from the ``C'' function
<CITE CLASS="Ec">getenv</CITE>
(use of the environment name
''PIXCI''
is suggested),
or via the Windows function
<CITE CLASS="Ec">GetProfileString</CITE>
(use of the environment name
''[EPIX_XC]''
and entry
''PIXCI''
is suggested).
<P>
The
<EM CLASS="Ep">formatname</EM>
or
<EM CLASS="Ep">formatfile</EM>
allows setting the initial video format configuration.
One and only one of
<EM CLASS="Ep">formatname</EM>
or
<EM CLASS="Ep">formatfile</EM>
must be specified, the
other must be NULL or the empty string &quot;&quot;.
<P>
For PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards:
The following predefined
<EM CLASS="Ep">formatname</EM>'s
allow setting for standard video format configurations:
<DL>
<BR><DT><CODE>&quot;RS-170&quot;</CODE><DD>
The video format is initially set for RS-170 composite video,
capturing 752 pixels per line, 480 lines,
monochrome grey level pixels,
using video input channel 2.
This specification is supported on PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A.
<BR><DT><CODE>&quot;NTSC&quot;</CODE><DD>
The video format is initially set for NTSC composite video,
capturing 752 pixels per line, 480 lines,
color YCrCb pixels,
using video input channel 2.
This specification is supported on PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A.
<BR><DT><CODE>&quot;NTSC/YC&quot;</CODE><DD>
The video format is initially set for NTSC S-VIDEO (Super VHS),
capturing 752 pixels per line, 480 lines,
color YCrCb pixels,
using video input channel 1.
This specification is supported on PIXCI&reg;&nbsp;SV2, SV3, SV4, and SV5.
<BR><DT><CODE>&quot;CCIR&quot;</CODE><DD>
The video format is initially set for CCIR composite video,
capturing 920 pixels per line, 580 lines,
monochrome grey level pixels,
using video input channel 2.
This specification is supported on PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A.
<BR><DT><CODE>&quot;PAL&quot;</CODE><DD>
The video format is initially set for PAL (B,D,G,H,I) composite video,
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 2.
This specification is supported on PIXCI&reg;&nbsp;SV2, SV4, SV4, SV5, and SV5A.
<BR><DT><CODE>&quot;PAL/YC&quot;</CODE><DD>
The video format is initially set for PAL (B,D,G,H,I) S-VIDEO (Super VHS),
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 1.
This specification is supported on PIXCI&reg;&nbsp;SV2, SV3, SV4, and SV5.
<BR><DT><CODE>&quot;PAL(M)&quot;</CODE><DD>
The video format is initially set for PAL(M) composite video,
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 2.
This specification is supported on PIXCI&reg;&nbsp;SV3, SV4, SV5, and SV5A.
<BR><DT><CODE>&quot;PAL(M)/YC&quot;</CODE><DD>
The video format is initially set for PAL(M) S-VIDEO (Super VHS),
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 1.
This specification is supported on PIXCI&reg;&nbsp;SV3, SV4, and SV5.
<BR><DT><CODE>&quot;PAL(N)&quot;</CODE><DD>
The video format is initially set for PAL(N) composite video,
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 2.
This specification is supported on PIXCI&reg;&nbsp;SV3, SV4, SV5, and SV5A.
<BR><DT><CODE>&quot;PAL(N)/YC&quot;</CODE><DD>
The video format is initially set for PAL(N) S-VIDEO (Super VHS),
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 1.
This specification is supported on PIXCI&reg;&nbsp;SV3, SV4, and SV5.
<BR><DT><CODE>&quot;SECAM&quot;</CODE><DD>
The video format is initially set for SECAM composite video,
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 2.
This specification is supported on PIXCI&reg;&nbsp;SV3, SV4, SV5, and SV5A.
<BR><DT><CODE>&quot;SECAM/YC&quot;</CODE><DD>
The video format is initially set for SECAM S-VIDEO (Super VHS),
capturing 920 pixels per line, 580 lines,
color YCrCb pixels,
using video input channel 1.
This specification is supported on PIXCI&reg;&nbsp;SV3, SV4, and SV5.
<BR><DT><CODE>&quot;DEFAULT&quot;</CODE><DD>
For PIXCI&reg;&nbsp;SV2, SV3, SV4, and SV5: Same as <CODE>&quot;NTSC/YC&quot;</CODE>.
For PIXCI&reg;&nbsp;SV5A: Same as <CODE>&quot;NTSC&quot;</CODE>.
</DL>
<P>
For PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, SI, and A imaging boards:
The following predefined
<EM CLASS="Ep">formatname</EM>'s
allow setting for standard video format configurations:
<DL>
<BR><DT><CODE>&quot;DEFAULT&quot;</CODE><DD>
As appropriate for the camera for which the
current PIXCI&reg; imaging board is intended, with maximum resolution.
</DL>
<P>
Alternately, the
<EM CLASS="Ep">formatfile</EM>
is taken to be the name of a file
containing a video format configuration
(also referred to as a video state) previously exported by the XCAP program
or the XCLIB library.
Video capture parameters, such as the video format, video resolution,
pixel color space, video input channel, and white balancing,
(as appropriate for the imaging board in use)
are all imported from
<EM CLASS="Ep">formatfile</EM>.
<P>
Note: When the XCLIB DLL is called from Visual Basic, LabView,
or many other non C/C++ environments, the alternative empty string (&quot;&quot;)
should be used, not NULL, for
<EM CLASS="Ep">driverparms</EM>,
<EM CLASS="Ep">formatname</EM>,
or
<EM CLASS="Ep">formatfile</EM>
as required.
A Visual Basic or LabView NULL isn't the same as a C/C++ NULL.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
The PIXCI&reg; XCLIB  Library and Driver is open
and ready for use.
<BR><DT>PXERROR<DD>
The PIXCI&reg; imaging board could not be accessed;
either the PIXCI&reg; driver or hardware is not installed correctly.
The
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>
may provide more information.
<BR><DT>PXERMALLOC<DD>
Memory allocation error.
<BR><DT>PXERNOFILE<DD>
No file named
<EM CLASS="Ep">formatfile</EM>
found.
<BR><DT>PXERDOSIO<DD>
Can't read file named
<EM CLASS="Ep">formatfile</EM>.
<BR><DT>PXERSEARCH<DD>
The
<EM CLASS="Ep">formatname</EM>
was invalid.
<BR><DT>PXERVIDFORM<DD>
The
<EM CLASS="Ep">formatname</EM>
was one of the strings described above,
but the specified format is not supported on the current imaging board.
<BR><DT>PXERBADPARM<DD>
The parameters in
<EM CLASS="Ep">driverparms</EM>
are invalid.
<BR><DT>PXERFILEFORM<DD>
The file format of
<EM CLASS="Ep">formatfile</EM>
is invalid.
<BR><DT>PXERISOPEN<DD>
The library and driver are already open for use.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
See the
<CITE CLASS="Ec">PIXCI&reg; USER'S MANUAL</CITE>
for discussion of configuration options and settings.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
A PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, or SV5A imaging board is opened for use using RS-170
and video input channel 1.
<BLOCKQUOTE>
<PRE>
int i;
if ((i = pxd_PIXCIopen(&quot;&quot;, &quot;RS-170&quot;, &quot;&quot;)) &lt; 0) {
    printf(&quot;Open Error\n&quot;);
    pxd_mesgFault(1);
    exit(1);
}
printf(&quot;Open OK\n&quot;);
</PRE>
</BLOCKQUOTE>
<P>
Any PIXCI&reg; imaging board is opened for use with default format
and resolution.
<BLOCKQUOTE>
<PRE>
int i;
if ((i = pxd_PIXCIopen(&quot;&quot;, &quot;default&quot;, NULL)) &lt; 0) {
    printf(&quot;Open Error\n&quot;);
    pxd_mesgFault(1);
    exit(1);
}
printf(&quot;Open OK\n&quot;);
</PRE>
</BLOCKQUOTE>
<HR SIZE="1">
<A NAME="pxd_readuchar NX308"CLASS="NX"></A>
<A NAME="pxd_readuchar"CLASS="Sf"></A>
<A NAME="Read Pixel Values as Unsigned Char NX309"CLASS="NX"></A>
<A NAME="Read Pixel Values as Unsigned Char   ---   pxd_readuchar"CLASS="Sf"></A>
<A NAME="Read Pixel Values as Unsigned Char   ---   pxd_readuchar"></A>
<H6 CLASS="Sf">Read Pixel Values as Unsigned Char   ---   pxd_readuchar</H6>
<A NAME="pxd_readushort NX310"CLASS="NX"></A>
<A NAME="pxd_readushort"CLASS="Sg"></A>
<A NAME="Read Pixel Values as Unsigned Short NX311"CLASS="NX"></A>
<A NAME="Read Pixel Values as Unsigned Short   ---   pxd_readushort"CLASS="Sg"></A>
<A NAME="Read Pixel Values as Unsigned Short   ---   pxd_readushort"></A>
<H6 CLASS="Sg">Read Pixel Values as Unsigned Short   ---   pxd_readushort</H6>
<A NAME="pxd_writeuchar NX312"CLASS="NX"></A>
<A NAME="pxd_writeuchar"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Char NX313"CLASS="NX"></A>
<A NAME="Write Pixel Values as Unsigned Char   ---   pxd_writeuchar"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Char   ---   pxd_writeuchar"></A>
<H6 CLASS="Sg">Write Pixel Values as Unsigned Char   ---   pxd_writeuchar</H6>
<A NAME="pxd_writeushort NX314"CLASS="NX"></A>
<A NAME="pxd_writeushort"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Short NX315"CLASS="NX"></A>
<A NAME="Write Pixel Values as Unsigned Short   ---   pxd_writeushort"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Short   ---   pxd_writeushort"></A>
<H6 CLASS="Sg">Write Pixel Values as Unsigned Short   ---   pxd_writeushort</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_readuchar  (unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
int pxd_readushort (unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
int pxd_writeuchar (unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
int pxd_writeushort(unitmap, framebuf, ulx, uly, lrx, lry, membuf, cnt, colorspace);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
uchar               membuf[];       // Program's buffer to receive (readuchar) or
                                    // originate (writeuchar) unsigned char values
ushort              membuf[];       // Program's buffer to receive (readushort) or
                                    // originate (writeushort) unsigned short values
int                 cnt;            // Size of program's buffer referenced by membuf
                                    // in unsigned char's or unsigned short's
char                *colorspace;    // Name of requested color representation
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Pixel values from an image frame buffer and area of interest
are copied into, or copied from, an array
or other memory buffer provided by the application program.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit from which, or to which,
pixel values are to be read or written.
The
<EM CLASS="Ep">framebuf</EM>,
1&lt;=<EM CLASS="Ep">framebuf</EM>&lt;=<EM CLASS="Ep">pxd_imageZdim(),</EM>
specifies the image frame buffer from which, or to which,
pixel values are to be read or written.
The
<EM CLASS="Ep">ulx</EM>
and
<EM CLASS="Ep">uly</EM>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>())
or the extreme bottom vertical coordinate
(i.e.
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>()),
respectively.
<P>
The
<EM CLASS="Ep">membuf</EM>
specifies a program provided array or buffer which pixel
values are to be copied into, or copied from.
The
<EM CLASS="Ep">cnt</EM>
specifies the
number of unsigned chars
(for
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>
and
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>)
or unsigned shorts
(for
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>),
in the array or buffer referenced by
<EM CLASS="Ep">membuf</EM>.
The
<EM CLASS="Ep">membuf</EM>
and
<EM CLASS="Ep">cnt</EM>
must be large enough to contain all of the pixel
values implied by
<EM CLASS="Ep">ulx</EM>,
<EM CLASS="Ep">uly</EM>,
<EM CLASS="Ep">lrx</EM>,
<EM CLASS="Ep">lry</EM>,
and
<EM CLASS="Ep">colorspace</EM>;
the
<EM CLASS="Ep">cnt</EM>
is not intended to be used to limit the number of pixel values
transferred, but is rather intended to assert the maximum
allowable transfer size and inducing an error
if the
<EM CLASS="Ep">membuf</EM>
and
<EM CLASS="Ep">cnt</EM>
is too small.
<P>
The
<EM CLASS="Ep">colorspace</EM>
specifies the color space and color component(s)
in which pixel values are to be read into, or written from,
the program provided array or buffer.
Valid choices are:
<BLOCKQUOTE>
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
colorspace  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Number of Components 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Color Representation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RGB&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofRGB&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofRGB&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofRGB&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BGR&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red (RGB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofBGR&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofBGR&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofBGR&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BSH&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness, Saturation, Hue (HSB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofBSH&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;SofBSH&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Saturation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;HofBSH&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Hue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RGBx&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofRGBx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofRGBx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofRGBx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BGRx&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red, Pad (RGB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofBGRx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GofBGRx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofBGRx&quot;   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Grey&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GREY&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale (alternate spelling for &quot;Grey&quot;)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Gray&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale (alternate spelling for &quot;Grey&quot;)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;GRAY&quot;      
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale (alternate spelling for &quot;Grey&quot;)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YCrCb&quot;     
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity, Red Chroma, Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YofYCrCb&quot;  
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofYCrCb&quot;  
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofYCrCb&quot;  
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YCrCbX&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity, Red Chroma, Blue Chroma, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YofYCrCbX&quot; 
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;RofYCrCbX&quot; 
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;BofYCrCbX&quot; 
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;Bayer&quot;     
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Raw Bayer Pattern Values
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;CbYCrY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 2 
</TD>
<TD ALIGN="left" COLSPAN="1">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;CMY&quot;       
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cyan, Magenta, Yellow
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;CofCMY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cyan
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;MofCMY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Magenta
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
&quot;YofCMY&quot;    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Yellow
</TD>
</TR>
</TABLE>
</PRE>
</BLOCKQUOTE>
<P>
The
''BGRx''
selection, when used with a
''uchar''
<EM CLASS="Ep">membuf</EM>,
on Intel machines with little-endian architecture
(i.e. least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, results in pixels that are compatible with Windows' RGB() data type.
<P>
The
''Bayer''
selection is available only in conjunction with cameras
that actually output raw Bayer pattern values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
<P>
The
''CbYCrY''
selection is available only in conjunction with imaging boards
that actually capture CbYCrY (UYVY) values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x), BGR(x), or YCrCb.
<P>
While these functions could be used to read or write
a single pixel value with each invocation,
they are intended, and more efficient, for reading
or writing lines, columns, or entire images of pixel values.
<P>
Any data type,
''uchar''
or
''ushort'',
and any
<EM CLASS="Ep">colorspace</EM>
can be chosen regardless of the image frame buffer's
actual format.
However, data type and color conversions
may require additional computational overhead.
<P>
Each pixel value component is copied from, or copied into,
a single
''uchar''
or
''ushort'';
pixel values are not
''packed''.
If the data type
has fewer bits that the pixel value component,
the most significant bits of the pixel value component
are copied into the data type, or are copied from the data type
with lower order bits set to 0;
e.g. a 10 bit per pixel component value of 1023 is
stored in an 8 bit
''uchar''
as value 255.
If the data type has more bits than the pixel value
component, the pixel value component is copied into, or copied from,
the data type's least significant bits;
e.g. a 10 bit per pixel component value of 1023
is stored in an 16 bit
''ushort''
as value 1023.
<P>
The XCLIB-Lite only supports the
''RGB'',
''BGR'',
''RGBx'',
''BGRx'',
''Grey'',
''Gray'',
''GREY'',
and
''GRAY''
selections.
The XCLIB-Lite does not provide data conversions;
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>
and
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>
must be used with 1 through 8 bit component values,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>
must be used with 9 through 16 bit values.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>&ge;0<DD>
Returns the number of pixel value components copied into,
or copied from, the
<EM CLASS="Ep">membuf</EM>.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERTOOSMALL<DD>
The
<EM CLASS="Ep">membuf</EM>
and
<EM CLASS="Ep">cnt</EM>
is too small to contain the number of pixel value components
specified by
<EM CLASS="Ep">ulx</EM>,
<EM CLASS="Ep">uly</EM>,
<EM CLASS="Ep">lrx</EM>,
<EM CLASS="Ep">lry</EM>,
and
<EM CLASS="Ep">colorspace</EM>.
<BR><DT>PXERBADMNEMONIC<DD>
The
<EM CLASS="Ep">colorspace</EM>
is invalid.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
The center pixel in each
image frame buffer of each imaging board
is read and displayed numerically as both RGB and monochrome.
For convenience, the example uses
''ushort''
data types regardless of the image frame buffer's
pixel bit-depth, letting the library perform conversions as needed.
<BLOCKQUOTE>
<PRE>
ushort  membuf[3];  // room for 1 pixel with three components
int     unit, buf;
<BR>
for (unit = 0; unit &lt; pxd_infoUnits(); units++) {
    for (buf = 1; buf &lt; pxd_imageZdim(); buf++) {
        pxd_readushort(1&lt;&lt;unit, buf,
                       pxd_imageXdim()/2,     pxd_imageYdim()/2,
                       1+(pxd_imageXdim()/2), 1+(pxd_imageYdim()/2),
                       membuf, 3, &quot;Grey&quot;);
        printf(&quot;Unit: %d, Buffer: %d, Grey Value: %u\n&quot;, unit, buf, membuf[0]);
        pxd_readushort(1&lt;&lt;unit, buf,
                       pxd_imageXdim()/2,     pxd_imageYdim()/2,
                       1+(pxd_imageXdim()/2), 1+(pxd_imageYdim()/2),
                       membuf, 3, &quot;RGB&quot;);
        printf(&quot;Unit: %d, Buffer: %d, RGB Value: %u/%u/%u\n&quot;, unit, buf,
               membuf[0], membuf[1], membuf[2]);
    }
}
</PRE>
</BLOCKQUOTE>
<HR SIZE="1">
<A NAME="pxd_renderDIBCreate NX316"CLASS="NX"></A>
<A NAME="pxd_renderDIBCreate"CLASS="Sf"></A>
<A NAME="Windows: Create Device Independent Bitmap (DIB) NX317"CLASS="NX"></A>
<A NAME="Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate"CLASS="Sf"></A>
<A NAME="Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate"></A>
<H6 CLASS="Sf">Windows: Create Device Independent Bitmap (DIB)   ---   pxd_renderDIBCreate</H6>
<A NAME="pxd_renderDIBFree NX318"CLASS="NX"></A>
<A NAME="pxd_renderDIBFree"CLASS="Sg"></A>
<A NAME="Windows: Release Device Independent Bitmap (DIB) NX319"CLASS="NX"></A>
<A NAME="Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree"CLASS="Sg"></A>
<A NAME="Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree"></A>
<H6 CLASS="Sg">Windows: Release Device Independent Bitmap (DIB)   ---   pxd_renderDIBFree</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
HGLOBAL pxd_renderDIBCreate(unitmap, framebuf, ulx, uly, lrx, lry, mode, options);
int     pxd_renderDIBFree(hDIB);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
int                 mode;           // Reserved, should be 0
int                 options;        // Reserved, should be 0
<BR>
HGLOBAL             hDIB;           // Previously created bitmap
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
An image frame buffer, or an area of interest within the image frame buffer,
is copied to a newly created Windows Device Independent Bitmap (DIB)
in global memory (e.g. using the Windows'
<CITE CLASS="Ec">GlobalAlloc</CITE>)
and the handle to the DIB returned by
<A HREF="#pxd_renderDIBCreate"CLASS="Er">pxd_renderDIBCreate</A>.
The bitmap created must be freed by
<A HREF="#pxd_renderDIBFree"CLASS="Er">pxd_renderDIBFree</A>
when no longer needed.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit from which the image frame buffer
is to be copied.
The
<EM CLASS="Ep">framebuf</EM>,
1&lt;=<EM CLASS="Ep">framebuf</EM>&lt;=<EM CLASS="Ep">pxd_imageZdim(),</EM>
specifies the image frame buffer to be copied.
The
<EM CLASS="Ep">ulx</EM>
and
<EM CLASS="Ep">uly</EM>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>())
or the extreme bottom vertical coordinate
(i.e.
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>()),
respectively.
<P>
Color image frame buffers are copied as 24 bit RGB pixels
without compression.
Monochrome image frame buffers are copied
as 8 bit pixels with a monochrome, identity, palette
without compression.
<P>
The number of pixels per line, i.e.
<EM CLASS="Ep">lrx</EM>-<EM CLASS="Ep">ulx,</EM>
should be a multiple of four;
as some Windows drivers do not properly support
Device Independent Bitmaps which violate this condition.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_renderDIBCreate"CLASS="Er">pxd_renderDIBCreate</A>
returns a handle to
<CITE CLASS="Ec">GlobalAlloc</CITE>
memory, or 0 if the library is not open for use,
or a parameter is invalid.
<P>
The
<A HREF="#pxd_renderDIBFree"CLASS="Er">pxd_renderDIBFree</A>
returns 0 if successful
or a PXER... code
as appropriate.
<HR SIZE="1">
<A NAME="pxd_renderDirectVideoInit NX320"CLASS="NX"></A>
<A NAME="pxd_renderDirectVideoInit"CLASS="Sf"></A>
<A NAME="Windows: Direct Video Display, Init NX321"CLASS="NX"></A>
<A NAME="Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit"CLASS="Sf"></A>
<A NAME="Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit"></A>
<H6 CLASS="Sf">Windows: Direct Video Display, Init   ---   pxd_renderDirectVideoInit</H6>
<A NAME="pxd_renderDirectVideoDone NX322"CLASS="NX"></A>
<A NAME="pxd_renderDirectVideoDone"CLASS="Sg"></A>
<A NAME="Windows: Direct Video Display, Done NX323"CLASS="NX"></A>
<A NAME="Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone"CLASS="Sg"></A>
<A NAME="Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone"></A>
<H6 CLASS="Sg">Windows: Direct Video Display, Done   ---   pxd_renderDirectVideoDone</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_renderDirectVideoInit(unitmap, hWnd);
int pxd_renderDirectVideoDone(unitmap, hWnd);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
HWND                hWnd;           // Handle to window
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="Windows NX324"CLASS="NX"></A>
A connection to the DirectX/DirectDraw feature of Windows
is created in preparation for
displaying live video on the graphics display (S/VGA).
The
<EM CLASS="Ep">hWnd</EM>
specifies the window to which
DirectX/DirectDraw access is requested
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>.<A HREF="#Footnote 24"CLASS="Ff"><SUP>[24]</SUP></A>
<P>
Since initial connection to DirectX/DirectDraw may require
200 msec or more, the
<A HREF="#pxd_renderDirectVideoInit"CLASS="Er">pxd_renderDirectVideoInit</A>
may be initialized once, after which
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
may be used multiple times without repeating the connection delay.
When done,
<A HREF="#pxd_renderDirectVideoDone"CLASS="Er">pxd_renderDirectVideoDone</A>
should be called to release the connection.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Connection established.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERMALLOC<DD>
Memory allocation error.
<BR><DT>PXERNOMODE<DD>
The current imaging board does not provide
live video to the graphics display (S/VGA).
<BR><DT>PXERNOFEATURE<DD>
A connection could not be established to DirectX/DirectDraw;
that feature may not be installed in the current Windows.
<BR><DT>PXERNOTNOW<DD>
Another application has exclusive DirectX/DirectDraw
use of the graphics display (S/VGA).
<BR><DT>PXERNOTOPEN<DD>
A connection to DirectX/DirectDraw was not created via
<A HREF="#pxd_renderDirectVideoInit"CLASS="Er">pxd_renderDirectVideoInit</A>.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_renderDirectVideoLive NX325"CLASS="NX"></A>
<A NAME="pxd_renderDirectVideoLive"CLASS="Sf"></A>
<A NAME="Windows: Direct Video Display, Start NX326"CLASS="NX"></A>
<A NAME="Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive"CLASS="Sf"></A>
<A NAME="Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive"></A>
<H6 CLASS="Sf">Windows: Direct Video Display, Start   ---   pxd_renderDirectVideoLive</H6>
<A NAME="pxd_renderDirectVideoUnLive NX327"CLASS="NX"></A>
<A NAME="pxd_renderDirectVideoUnLive"CLASS="Sg"></A>
<A NAME="Windows: Direct Video Display, Stop NX328"CLASS="NX"></A>
<A NAME="Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive"CLASS="Sg"></A>
<A NAME="Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive"></A>
<H6 CLASS="Sg">Windows: Direct Video Display, Stop   ---   pxd_renderDirectVideoUnLive</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_renderDirectVideoLive(unitmap, hWnd, nX, nY, nWidth, nHeight, ClrKey1, ClrKey2);
int pxd_renderDirectVideoUnLive(unitmap, hWnd);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
HWND                hWnd;           // Handle to window
uint                nX;             // X position in Window
uint                nY;             // Y position in Window
uint                nWidth;         // Display width in Window, or UINT_MAX
uint                nHeight;        // Display height in Window, or UINT_MAX
COLORREF            ClrKey1;        // Color key, a RGB(,,) or CLR_INVALID
COLORREF            ClrKey2;        // Color key, a RGB(,,) or CLR_INVALID
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="Windows NX329"CLASS="NX"></A>
The
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
initiates displaying of live video directly to the graphics display (S/VGA),
using the Windows' DirectX/DirectDraw feature.
The
<A HREF="#pxd_renderDirectVideoUnLive"CLASS="Er">pxd_renderDirectVideoUnLive</A>
terminates displaying of live video directly to the graphics display (S/VGA).
The
<A HREF="#pxd_renderDirectVideoInit"CLASS="Er">pxd_renderDirectVideoInit</A>
must have been used previously to create a connection to the
DirectX/DirectDraw feature.
The
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
and related functions handle the entire DirectX/DirectDraw interface;
the user need not be familiar with the DirectX/DirectDraw API,
nor use the DirectX/DirectDraw SDK.
Familiarity with the standard Windows API is, of course, helpful.
<P>
The
<EM CLASS="Ep">hWnd</EM>
specifies the window upon which
live video is displayed, from
the single unit specified by
<EM CLASS="Ep">unitmap</EM>.<A HREF="#Footnote 25"CLASS="Ff"><SUP>[25]</SUP></A>
Live video is displayed
at an upper left coordinate of
<EM CLASS="Ep">nX</EM>
and
<EM CLASS="Ep">nY</EM>
relative to the
<EM CLASS="Ep">hWnd</EM>
window,
with a maximum width and height of
<EM CLASS="Ep">nWidth</EM>
and
<EM CLASS="Ep">nHeight</EM>.
The
<EM CLASS="Ep">nWidth</EM>
and
<EM CLASS="Ep">nHeight</EM>
are reduced so as to not exceed the window's size;
use of
<EM CLASS="Ep">nX</EM>=0,
<EM CLASS="Ep">nY</EM>=0,
<EM CLASS="Ep">nWidth</EM>=UINT_MAX,
and
<EM CLASS="Ep">nHeight</EM>=UINT_MAX
fills as much of the window as possible.
The displayed video may be smaller than the requested size,
as limited by the current video resolution
(see
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>
and
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>).
The video resolution will be decreased, as needed, to fit within
the display area, but will not be automatically enlarged.
<P>
If
<EM CLASS="Ep">ClrKey1</EM>&ne;CLR_INVALID,
the color key (chroma key)
feature of the graphics display (S/VGA) is enabled,
so as to allow presenting live video only where the graphics display (S/VGA) screen
has the color of
<EM CLASS="Ep">ClrKey1</EM>.
This allows presentation of graphics over live video,
through the use of Windows GDI,
so long as the intended graphics are a color different than
<EM CLASS="Ep">ClrKey1</EM>.
If
<EM CLASS="Ep">ClrKey2</EM>&ne;CLR_INVALID,
the color
<EM CLASS="Ep">ClrKey2</EM>
is drawn on the window prior to activating live video.
Typically,
<EM CLASS="Ep">ClrKey2</EM>
is the same value as
<EM CLASS="Ep">ClrKey1</EM>;
but setting
<EM CLASS="Ep">ClrKey1</EM>&ne;CLR_INVALID
and
<EM CLASS="Ep">ClrKey2</EM>=CLR_INVALID,
allows the user to assume responsibility for filling
the window with the
<EM CLASS="Ep">ClrKey1</EM>
color wherever live video is to appear.
<P>
After use of
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>,
it is the application's responsibility to monitor Windows'
WM_MOVE, WM_SIZE, WM_WINDOWPOSCHANGED, and WM_WINDOWPOSCHANGING,
messages, and upon receipt, invoke
<A HREF="#pxd_renderDirectVideoUnLive"CLASS="Er">pxd_renderDirectVideoUnLive</A>
to stop displaying live video in the old size or window location,
and invoke
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
again to resume displaying live in the new size or location.
<P>
Graphics display systems (S/VGA cards), and their drivers, differ widely in their support of live video.
The minimal requirements are:
<OL TYPE="1">
<P>
<LI>
Graphics display system (S/VGA) drivers supporting DirectDraw.
<P>
<LI>
Hardware overlay feature.
<P>
<LI>
For PIXCI&reg;&nbsp;SV2 and SV3 imaging boards:
Overlay surface that accepts UYVY format video.
For PIXCI&reg;&nbsp;SV4, SV5, and SV5A imaging boards:
Overlay surface that accepts UYVY, VYUY, YUY2, or YVYU format video.
<P>
<LI>
Hardware cursor/sprite/icon support.
<P>
<LI>
Hardware chroma key support (optional).
</OL>
In addition, the DirectX/DirectDraw feature must be installed in Windows.
<P>
Each graphics display system (S/VGA card) differs in whether it supports the necessary features
in all modes (i.e. 8 bits per pixel, 24 bits per pixel, etc.)
and resolution (i.e. 640x480, 1024x768, etc.).
The
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
tries to provide live video using the graphics display system's (S/VGA card's) current mode
and resolution.
<P>
For PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and A:
No known graphics display system (S/VGA card) supports the data formats produced
by these imaging boards.
<P>
For PIXCI&reg;&nbsp;CL3SD: The imaging board can't
directly display live video to the graphics display (S/VGA).
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation successful.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERNOTOPEN<DD>
A connection to DirectX/DirectDraw was not created via
<A HREF="#pxd_renderDirectVideoInit"CLASS="Er">pxd_renderDirectVideoInit</A>.
<BR><DT>PXERNOMODE<DD>
The current graphics display (S/VGA) card can't accept live video,
at least not in a form compatible with the imaging board's current video format.
<BR><DT>PXERNODEVMEM<DD>
Insufficient memory on the graphics display system (S/VGA card) for the specified video resolution.
<BR><DT>PXERNOFEATURE<DD>
The current graphics display system (S/VGA card) doesn't provide color keying,
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
can only be used with
<EM CLASS="Ep">ClrKey1</EM>=CLR_INVALID.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
The
<CODE CLASS="Em">xclibex2.cpp</CODE>
example program demonstrates use of
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
and
<A HREF="#pxd_renderDirectVideoUnLive"CLASS="Er">pxd_renderDirectVideoUnLive</A>,
including the use of chroma keying
and use of
WM_MOVE, WM_SIZE, WM_WINDOWPOSCHANGED, and WM_WINDOWPOSCHANGING,
to track changes to the window's position.
<P>
The
<CODE CLASS="Em">xclibex2.cpp</CODE>
also demonstrates other techniques for displaying live
video, which may be regardless of whether the graphics display (S/VGA)
and/or imaging board features support
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>.
<HR SIZE="1">
<A NAME="pxd_renderStretchDIBits NX330"CLASS="NX"></A>
<A NAME="pxd_renderStretchDIBits"CLASS="Sf"></A>
<A NAME="Windows: Display Image Frame Buffer On Device Context NX331"CLASS="NX"></A>
<A NAME="Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits"CLASS="Sf"></A>
<A NAME="Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits"></A>
<H6 CLASS="Sf">Windows: Display Image Frame Buffer On Device Context   ---   pxd_renderStretchDIBits</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_renderStretchDIBits(unitmap,buffer,ulx,uly,lrx,lry,options,hDC,nX,nY,nWidth,nHeight,winoptions);
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
int                 options;        // Reserved, should be 0
HDC                 hDC;            // Device context
uint                nX;             // Display x position in hDC
uint                nY;             // Display y position in hDC
uint                nWidth;         // Display width in hDC
uint                nHeight;        // Display height in hDC
int                 winoptions;     // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="Windows NX332"CLASS="NX"></A>
An image frame buffer, or an area of interest within the image frame buffer,
is copied/rendered/displayed to a Windows device context,
typically a display window or a printer context.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit from which the image frame buffer
is to be copied.
The
<EM CLASS="Ep">framebuf</EM>,
1&lt;=<EM CLASS="Ep">framebuf</EM>&lt;=<EM CLASS="Ep">pxd_imageZdim(),</EM>
specifies the image frame buffer to be copied.
The
<EM CLASS="Ep">ulx</EM>
and
<EM CLASS="Ep">uly</EM>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>())
or the extreme bottom vertical coordinate
(i.e.
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>()),
respectively.
<P>
The image is rendered on the device context defined by
<EM CLASS="Ep">hDC</EM>,
starting at the
<EM CLASS="Ep">nX</EM>
and
<EM CLASS="Ep">nY</EM>
coordinate,
with a width and height of
<EM CLASS="Ep">nWidth</EM>
and
<EM CLASS="Ep">nHeight</EM>.
<P>
As may be inferred from the name,
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>
uses the Windows GDI
<CITE CLASS="Ec">StretchDIBits</CITE>
function;
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>
builds a Device Independent Bitmap
of the specified image frame buffer and area of interest,
and invokes:
<BLOCKQUOTE>
<PRE>
StretchDIBits(hDC,nX,nY,nWidth,nHeight,0,0,lrx-ulx,lry-uly,*,*,DIB_RGB_COLORS,SRCCOPY);
</PRE>
</BLOCKQUOTE>
or
<BLOCKQUOTE>
<PRE>
StretchDIBits(hDC,nX,nY+nHeight-1,nWidth,-nHeight,0,0,lrx-ulx,lry-uly,*,*,DIB_RGB_COLORS,SRCCOPY);
</PRE>
</BLOCKQUOTE>
The
<CITE CLASS="Ec">StretchDIBits</CITE>
documentation provides additional discussion regarding the
<EM CLASS="Ep">nX</EM>,
<EM CLASS="Ep">nY</EM>,
<EM CLASS="Ep">nWidth</EM>,
and
<EM CLASS="Ep">nHeight</EM>
parameters.<A HREF="#Footnote 26"CLASS="Ff"><SUP>[26]</SUP></A>
<P>
The number of pixels per line, i.e.
<EM CLASS="Ep">lrx</EM>-<EM CLASS="Ep">ulx</EM>,
should be a multiple of four,
as some Windows display drivers do not properly support
Device Independent Bitmaps which violate this condition.
The number of pixels displayed per line, i.e.
<EM CLASS="Ep">nWidth</EM>
should also be a multiple of four,
as some Windows display drivers do not properly support
resizing into a display area which violates this condition.
<P>
For some graphics display (S/VGA) drivers, the quality of the rendered image can
be significantly improved by using:
<BLOCKQUOTE>
<PRE>
SetStretchBltMode(hDC, STRETCH_DELETESCANS);
</PRE>
</BLOCKQUOTE>
before
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>.
<P>
<A NAME="S/VGA Adapter NX333"CLASS="NX"></A>
<A NAME="Graphics Display System NX334"CLASS="NX"></A>
Because
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>
relies upon the Windows
<CITE CLASS="Ec">StretchDIBits</CITE>
for rendering and resizing, the
visual result and rendering speed
is completely dependent upon the graphics display adapter (e.g. S/VGA adapter)
and its driver.
For example, in 16 color (4 bit per pixel) S/VGA mode, monochrome images
might be rendered using only 3 grey levels, with significant
''banding''.
Good results will be obtained
with S/VGA adapters providing at least 16 bits per pixel
for monochrome images, or at least 24 bits per pixel for color images.<A HREF="#Footnote 27"CLASS="Ff"><SUP>[27]</SUP></A>
<P>
Alternately, the
<A HREF="#pxd_renderDIBCreate"CLASS="Er">pxd_renderDIBCreate</A>
can be used to create a standard Windows Device Independent Bitmap
(DIB) which can then be rendered via DrawDibDraw
or via the Video for Windows (MultiMedia) API.
The
visual result and rendering speed is still
completely dependent upon the graphics display adapter (e.g. S/VGA adapter)
and its driver; however, the Windows MultiMedia API, being newer,
tends to perform better than the older Windows
<CITE CLASS="Ec">StretchDIBits</CITE>.
<P>
Finally, the alternate
<CITE CLASS="Ec">pxio8_GDIDisplay</CITE>,
<CITE CLASS="Ec">pxio8_DirectXDisplay</CITE>,
or
<CITE CLASS="Ec">pxio8_DrawDibDisplay</CITE>
functions provided with the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>,
allows pseudo-grey level generation (useful in 16 color S/VGA modes),
selectable methods of image resizing,
provides for integrated drawing of a cross-hair or other image cursor,
performs resizing within the PXIPL function,
avoids the overhead of copying the image into a DIB format
and allows applying a look-up table (palette) as the image is being
rendered.
<P>
<A NAME="Printing NX335"CLASS="NX"></A>
Because
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>
uses
<EM CLASS="Ep">hDC</EM>,
a handle to a device context rather than a handle to a window,
it may also be used to print images, given a handle to a printer's device context.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Image frame buffer copied/rendered/displayed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERMALLOC<DD>
Memory allocation error.
</DL>
<HR SIZE="1">
<A NAME="pxd_serialConfigure NX336"CLASS="NX"></A>
<A NAME="pxd_serialConfigure"CLASS="Sf"></A>
<A NAME="Serial Port: Set Configuration NX337"CLASS="NX"></A>
<A NAME="Serial Port: Set Configuration   ---   pxd_serialConfigure"CLASS="Sf"></A>
<A NAME="Serial Port: Set Configuration   ---   pxd_serialConfigure"></A>
<H6 CLASS="Sf">Serial Port: Set Configuration   ---   pxd_serialConfigure</H6>
<A NAME="pxd_serialRead NX338"CLASS="NX"></A>
<A NAME="pxd_serialRead"CLASS="Sg"></A>
<A NAME="Serial Port: Read NX339"CLASS="NX"></A>
<A NAME="Serial Port: Read   ---   pxd_serialRead"CLASS="Sg"></A>
<A NAME="Serial Port: Read   ---   pxd_serialRead"></A>
<H6 CLASS="Sg">Serial Port: Read   ---   pxd_serialRead</H6>
<A NAME="pxd_serialWrite NX340"CLASS="NX"></A>
<A NAME="pxd_serialWrite"CLASS="Sg"></A>
<A NAME="Serial Port: Write NX341"CLASS="NX"></A>
<A NAME="Serial Port: Write   ---   pxd_serialWrite"CLASS="Sg"></A>
<A NAME="Serial Port: Write   ---   pxd_serialWrite"></A>
<H6 CLASS="Sg">Serial Port: Write   ---   pxd_serialWrite</H6>
<A NAME="clSerialInit NX342"CLASS="NX"></A>
<A NAME="clSerialInit"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Initialize NX343"CLASS="NX"></A>
<A NAME="Camera Link Serial: Initialize   ---   clSerialInit"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Initialize   ---   clSerialInit"></A>
<H6 CLASS="Sg">Camera Link Serial: Initialize   ---   clSerialInit</H6>
<A NAME="clSerialClose NX344"CLASS="NX"></A>
<A NAME="clSerialClose"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Close NX345"CLASS="NX"></A>
<A NAME="Camera Link Serial: Close   ---   clSerialClose"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Close   ---   clSerialClose"></A>
<H6 CLASS="Sg">Camera Link Serial: Close   ---   clSerialClose</H6>
<A NAME="clSerialRead NX346"CLASS="NX"></A>
<A NAME="clSerialRead"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Read NX347"CLASS="NX"></A>
<A NAME="Camera Link Serial: Read   ---   clSerialRead"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Read   ---   clSerialRead"></A>
<H6 CLASS="Sg">Camera Link Serial: Read   ---   clSerialRead</H6>
<A NAME="clSerialWrite NX348"CLASS="NX"></A>
<A NAME="clSerialWrite"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Write NX349"CLASS="NX"></A>
<A NAME="Camera Link Serial: Write   ---   clSerialWrite"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Write   ---   clSerialWrite"></A>
<H6 CLASS="Sg">Camera Link Serial: Write   ---   clSerialWrite</H6>
<A NAME="clGetNumBytesAvail NX350"CLASS="NX"></A>
<A NAME="clGetNumBytesAvail"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Read Available NX351"CLASS="NX"></A>
<A NAME="Camera Link Serial: Read Available   ---   clGetNumBytesAvail"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Read Available   ---   clGetNumBytesAvail"></A>
<H6 CLASS="Sg">Camera Link Serial: Read Available   ---   clGetNumBytesAvail</H6>
<A NAME="clFlushPort NX352"CLASS="NX"></A>
<A NAME="clFlushPort"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Read Flush NX353"CLASS="NX"></A>
<A NAME="Camera Link Serial: Read Flush   ---   clFlushPort"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Read Flush   ---   clFlushPort"></A>
<H6 CLASS="Sg">Camera Link Serial: Read Flush   ---   clFlushPort</H6>
<A NAME="clGetErrorText NX354"CLASS="NX"></A>
<A NAME="clGetErrorText"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Error Text NX355"CLASS="NX"></A>
<A NAME="Camera Link Serial: Error Text   ---   clGetErrorText"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Error Text   ---   clGetErrorText"></A>
<H6 CLASS="Sg">Camera Link Serial: Error Text   ---   clGetErrorText</H6>
<A NAME="clGetNumSerialPorts NX356"CLASS="NX"></A>
<A NAME="clGetNumSerialPorts"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Ports NX357"CLASS="NX"></A>
<A NAME="Camera Link Serial: Ports   ---   clGetNumSerialPorts"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Ports   ---   clGetNumSerialPorts"></A>
<H6 CLASS="Sg">Camera Link Serial: Ports   ---   clGetNumSerialPorts</H6>
<A NAME="clGetSerialPortIdentifier NX358"CLASS="NX"></A>
<A NAME="clGetSerialPortIdentifier"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Ports ID NX359"CLASS="NX"></A>
<A NAME="Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier"></A>
<H6 CLASS="Sg">Camera Link Serial: Ports ID   ---   clGetSerialPortIdentifier</H6>
<A NAME="clGetManufacturerInfo NX360"CLASS="NX"></A>
<A NAME="clGetManufacturerInfo"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Manufacturer ID NX361"CLASS="NX"></A>
<A NAME="Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo"></A>
<H6 CLASS="Sg">Camera Link Serial: Manufacturer ID   ---   clGetManufacturerInfo</H6>
<A NAME="clGetSupportedBaudRates NX362"CLASS="NX"></A>
<A NAME="clGetSupportedBaudRates"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Get Baud Rates NX363"CLASS="NX"></A>
<A NAME="Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates"></A>
<H6 CLASS="Sg">Camera Link Serial: Get Baud Rates   ---   clGetSupportedBaudRates</H6>
<A NAME="clSetBaudRate NX364"CLASS="NX"></A>
<A NAME="clSetBaudRate"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Set Baud Rate NX365"CLASS="NX"></A>
<A NAME="Camera Link Serial: Set Baud Rate   ---   clSetBaudRate"CLASS="Sg"></A>
<A NAME="Camera Link Serial: Set Baud Rate   ---   clSetBaudRate"></A>
<H6 CLASS="Sg">Camera Link Serial: Set Baud Rate   ---   clSetBaudRate</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_serialConfigure(unitmap, rsvd0, baud, bits, parity, stopbits, rsvd1, rsvd2, rsvd3);
int pxd_serialRead(unitmap, rsvd0, data, cnt);
int pxd_serialWrite(unitmap, rsvd0, data, cnt);
int clSerialInit(...);
int clSerialClose(...);
int clSerialRead(...);
int clSerialWrite(...);
int clGetNumBytesAvail(...);
int clFlushPort(...);
int clGetErrorText(...);
int clGetNumSerialPorts(...);
int clGetSerialPortIdentifier(...);
int clGetManufacturerInfo(...);
int clGetSupportedBaudRates(...);
int clSetBaudRate(...);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
double              baud;               // Serial baud rate, or 0
int                 bits;               // Bits per character
int                 stopbits;           // Stop bits per character, times 10
int                 parity;             // 0: None
int                 rsvd0;              // Reserved, should be 0
int                 rsvd1;              // Reserved, should be 0
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
char                data[];             // Program's buffer to receive or originate data
int                 cnt;                // Size of data[]
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_serialConfigure"CLASS="Er">pxd_serialConfigure</A>,
<A HREF="#pxd_serialRead"CLASS="Er">pxd_serialRead</A>,
and
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
allow use of the serial port on
PIXCI&reg; CL1, CL2, E1, E4, E1DB, and CL3SD imaging boards.
<P>
The
<A HREF="#pxd_serialConfigure"CLASS="Er">pxd_serialConfigure</A>
sets the serial port's parameters
on the single unit selected by
<EM CLASS="Ep">unitmap</EM>.
The
<EM CLASS="Ep">baud</EM>
specifies the baud rate,
the
<EM CLASS="Ep">bits</EM>
specifies the number of bits per character,
the
<EM CLASS="Ep">stopbits</EM>
specifies the number of stop bits per character multiplied by 10,
and
<EM CLASS="Ep">parity</EM>
specifies the type of parity bit.
For the PIXCI&reg; CL1 before Rev. 3 and the PIXCI&reg; CL3SD,
the baud rate may be any value between
95.4 and 6,250,000.0 baud,
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<EM CLASS="Ep">stopbits</EM>=1)
and parity must be none
(i.e.
<EM CLASS="Ep">parity</EM>=0).
For the PIXCI&reg; CL2, and the PIXCI&reg; CL1 Rev. 3 and later
the baud rate may be any value between
192.0 and 12,500,000.0 baud,
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<EM CLASS="Ep">stopbits</EM>=1)
and parity must be none
(i.e.
<EM CLASS="Ep">parity</EM>=0).
For the PIXCI&reg; E1 and E4
the baud rate may be any value between
512.4 and 12,500,000.0 baud,
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<EM CLASS="Ep">stopbits</EM>=1)
and parity must be none
(i.e.
<EM CLASS="Ep">parity</EM>=0).
For the PIXCI&reg; E1DB
the baud rate may be any of the values
9600, 19200, 38400, 57600, 115200, 230400, 460800, or 921600 baud
(the Camera Link V2.0 Specification baud rates),
the number of bits must be 8,
the number of stop bits must be 1
(i.e.
<EM CLASS="Ep">stopbits</EM>=1)
and parity must be none
(i.e.
<EM CLASS="Ep">parity</EM>=0).
The
<EM CLASS="Ep">baud</EM>
may also be 0, disabling the serial port;
other serial port parameters are ignored.
<P>
The
<A HREF="#pxd_serialRead"CLASS="Er">pxd_serialRead</A>
reads any previously received but unread data
into the
''char''
array or buffer provided by the application
on the single unit selected by
<EM CLASS="Ep">unitmap</EM>.
The
<EM CLASS="Ep">cnt</EM>
specifies the size of the
array or buffer referenced by
<EM CLASS="Ep">data</EM>,
and the maximum amount of data to be read.
The
<A HREF="#pxd_serialRead"CLASS="Er">pxd_serialRead</A>
never waits for data to be received,
reading only previously received data,
and returns the number of char's read.
If
<EM CLASS="Ep">data</EM>=NULL
or
<EM CLASS="Ep">cnt</EM>=0<EM CLASS="Ep">,</EM>
the
<A HREF="#pxd_serialRead"CLASS="Er">pxd_serialRead</A>
returns the number of char's available to
be read without reading or removing the unread data.
<P>
The
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
writes data from the
''char''
array or buffer provided by the application
on the single unit selected by
<EM CLASS="Ep">unitmap</EM>.
The
<EM CLASS="Ep">cnt</EM>
specifies the size of the
array or buffer referenced by
<EM CLASS="Ep">data</EM>,
and the amount of data to be written.
The
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
may wait for the
<EM CLASS="Ep">data</EM>
to be queued for transmission
(i.e. until all the data can be copied into the
internal transmit buffers)
but does not wait until the
<EM CLASS="Ep">data</EM>
is actually transmitted.
If
<EM CLASS="Ep">buf</EM>=0
or
<EM CLASS="Ep">cnt</EM>=0<EM CLASS="Ep">,</EM>
the
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
returns the amount of available space in the
internal transmit buffers, and thus the amount of
data that can be
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>'n
without having to wait.
<P>
The size of the transmit and received buffers
are currently each 1024 bytes and may not be changed.
<P>
Note: The Visual Basic declarations for
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
and
<A HREF="#pxd_serialRead"CLASS="Er">pxd_serialRead</A>
are written to expect that the
<EM CLASS="Ep">data</EM>
will be passed as a VB dimensioned array,
not as a VB double-quoted string.
This allows easier use with cameras whose
serial commands are binary rather than ASCII.
For cameras with ASCII style commands, the ASCII
characters can be inserted into a dimensioned array,
or the VB declaration manually changed.
<P>
Under Windows,
the
<A HREF="#clSerialInit"CLASS="Er">clSerialInit</A>,
<A HREF="#clSerialClose"CLASS="Er">clSerialClose</A>,
<A HREF="#clSerialRead"CLASS="Er">clSerialRead</A>,
<A HREF="#clSerialWrite"CLASS="Er">clSerialWrite</A>,
<A HREF="#clGetNumBytesAvail"CLASS="Er">clGetNumBytesAvail</A>,
<A HREF="#clFlushPort"CLASS="Er">clFlushPort</A>,
<A HREF="#clGetErrorText"CLASS="Er">clGetErrorText</A>,
<A HREF="#clGetNumSerialPorts"CLASS="Er">clGetNumSerialPorts</A>,
<A HREF="#clGetSerialPortIdentifier"CLASS="Er">clGetSerialPortIdentifier</A>,
<A HREF="#clGetManufacturerInfo"CLASS="Er">clGetManufacturerInfo</A>,
<A HREF="#clGetSupportedBaudRates"CLASS="Er">clGetSupportedBaudRates</A>,
and
<A HREF="#clSetBaudRate"CLASS="Er">clSetBaudRate</A>
provide alternate functions to access the serial port,
obeying the Camera Link V1.1 Serial API<A HREF="#Footnote 28"CLASS="Ff"><SUP>[28]</SUP></A>
except that the instantiation of these functions which are within the XCLIB
DLL only provide access after XCLIB has been
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>'ed;
the
''serialIndex''
(a Camera Link API parameter)
is the index of a logical board opened by
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
(i.e. log<SUB><SMALL>2</SMALL></SUB>
<EM CLASS="Ep">unitmap</EM>).
<P>
A separate DLL,
<CODE CLASS="Em">clserEPX.dll</CODE>,
which offers only the Camera Link Serial API
and can be distributed w/out XCLIB's licensing
restrictions, can be used to access the serial port
PIXCI&reg; imaging boards without the XCLIB DLL
and without explicitly opening XCLIB.
Under Windows NT, 2000, and XP the
<CODE CLASS="Em">clserEPX.dll</CODE>
can be used at the same time as XCLIB and can
share access to the
PIXCI&reg; imaging board(s).
Under Windows 95, 98, and ME
the
<CODE CLASS="Em">clserEPX.dll</CODE>
and XCLIB cannot share access to the
PIXCI&reg; imaging board(s).
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete
(<A HREF="#pxd_serialConfigure"CLASS="Er">pxd_serialConfigure</A>).
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
An example of sending a camera one command
and waiting for a response.
Each camera's commands and responses differ;
the example command and response are for a hypothetical
camera using ASCII style commands.
<BLOCKQUOTE>
<PRE>
    char    databuffer[50];   // buffer large enough for command and response
    int     dataread;
    int     r;
    char    c;
    DWORD   time;
    //
    // Init serial port if not done already
    //
    r = pxd_serialConfigure(0x1, 0,  9600, 8, 0, 1, 0, 0, 0);
    if (r &lt; 0)
        return; // error
    //
    // Format command and send.
    // Here we use an example of an ASCII style, \n terminated, command.
    // If the camera used binary commands, we would likely construct the
    // databuffer byte by byte instead of using sprintf, and we
    // would know the length instead of using strlen().
    //
    sprintf(databuffer, &quot;Set Gain=%f\n&quot;, 12.345);
    r = pxd_serialWrite(0x1, 0, databuffer, strlen(databuffer));
    if (r &lt; 0)
        return; // error
    //
    // Wait for and read response. Don't wait forever.
    //
    dataread = 0;
    time = GetTickCount();  // Windows: current time in milliseconds
    for (;;) {
        //
        // Another character arrived?
        //
        r = pxd_serialRead(0x1, 0, &amp;c, 1);
        if (r &lt; 0)
            return;     // error
        if (r == 0) {
            Sleep(1);   // be nice to multitasking OS
            continue;   // nothing arrived since last check
        }
        //
        // Store next character, building up response
        //
        databuffer[dataread++] = c;
        //
        // Have we read a complete response? The test is camera dependent!
        // Here we assume an ASCII response, terminated with a \n .
        //
        if (c == '\n')
            break;
        //
        // If not, have we filled the buffer?
        //
        if (dataread == sizeof(databuffer))
            return;     // error: can't interpret response
        //
        // Have we waited long enough to give up?
        //
        if (GetTickCount()-time &gt; 1000)
            return;     // error: timeout
    }
    //
    // Check the response. This test is camera dependent!
    //
    if (!strstr(databuffer, &quot;ACK&quot;))
        return;     // positive acknowledge seen
    if (!strstr(databuffer, &quot;NAK&quot;))
        return;     // negative acknowledge seen
    return;         // error: can't interpret response
</PRE>
</BLOCKQUOTE>
The above example reads the response one character at a time
for sake of clarity, not necessity.
The first half of the
''for''
loop can be replaced with:
<BLOCKQUOTE>
<PRE>
    for (;;) {
        //
        // Read up to as many characters as will fit in the remainder
        // of the data buffer.
        //
        r = pxd_serialRead(0x1, 0, &amp;databuffer[dataread], sizeof(databuffer)-dataread);
        if (r &lt; 0)
            return;     // error
        if (r == 0) {
            Sleep(1);   // be nice to multitasking OS
            continue;   // nothing arrived since last check
        }
        dataread += r;
        //
        // Have we read a complete response?
        //
        if (databuffer[dataread-1] == '\n')
            break;
        ...
    }
</PRE>
</BLOCKQUOTE>
<HR SIZE="1">
<A NAME="pxd_setExsyncPrin NX366"CLASS="NX"></A>
<A NAME="pxd_setExsyncPrin"CLASS="Sf"></A>
<A NAME="Set EXSYNC and PRIN Values NX367"CLASS="NX"></A>
<A NAME="Set EXSYNC and PRIN Values   ---   pxd_setExsyncPrin"CLASS="Sf"></A>
<A NAME="Set EXSYNC and PRIN Values   ---   pxd_setExsyncPrin"></A>
<H6 CLASS="Sf">Set EXSYNC and PRIN Values   ---   pxd_setExsyncPrin</H6>
<A NAME="pxd_getExsync NX368"CLASS="NX"></A>
<A NAME="pxd_getExsync"CLASS="Sg"></A>
<A NAME="Get EXSYNC Value NX369"CLASS="NX"></A>
<A NAME="Get EXSYNC Value   ---   pxd_getExsync"CLASS="Sg"></A>
<A NAME="Get EXSYNC Value   ---   pxd_getExsync"></A>
<H6 CLASS="Sg">Get EXSYNC Value   ---   pxd_getExsync</H6>
<A NAME="pxd_getPrin NX370"CLASS="NX"></A>
<A NAME="pxd_getPrin"CLASS="Sg"></A>
<A NAME="Get PRIN Value NX371"CLASS="NX"></A>
<A NAME="Get PRIN Value   ---   pxd_getPrin"CLASS="Sg"></A>
<A NAME="Get PRIN Value   ---   pxd_getPrin"></A>
<H6 CLASS="Sg">Get PRIN Value   ---   pxd_getPrin</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  pxd_setExsyncPrin(unitmap, exsync, prin);
uint pxd_getExsync(unitmap);
uint pxd_getPrin(unitmap);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint                exsync;         // The EXSYNC value
uint                prin;           // The PRIN value
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
EXSYNC and PRIN values for
PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, SI and A imaging boards,
are set, or the current values obtained.
Depending upon camera and video format configuration,
these values typically control the camera
integration time and frame period.
The allowable range and units of time of these values
is camera and video format configuration specific,
and discussed in the
<CITE CLASS="Ec">PIXCI&reg; User's Manual</CITE>.
<P>
The
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
sets the EXSYNC value to
<EM CLASS="Ep">exsync</EM>
and the PRIN value to
<EM CLASS="Ep">prin</EM>
on the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
The
<A HREF="#pxd_getExsync"CLASS="Er">pxd_getExsync</A>
returns the current EXSYNC value
on the single unit selected by
<EM CLASS="Ep">unitmap</EM>.
The
<A HREF="#pxd_getPrin"CLASS="Er">pxd_getPrin</A>
returns the current PRIN value
on the single unit selected by
<EM CLASS="Ep">unitmap</EM>.
<P>
Currently, the library does not actually
remember distinct values for various units.
The
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
can be used to set different units to different
values, but the
<A HREF="#pxd_getExsync"CLASS="Er">pxd_getExsync</A>
and
<A HREF="#pxd_getPrin"CLASS="Er">pxd_getPrin</A>
always return the last value set on any unit.
<P>
The XCLIB-Lite does not support this feature.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_getExsync"CLASS="Er">pxd_getExsync</A>
and
<A HREF="#pxd_getPrin"CLASS="Er">pxd_getPrin</A>
returns values as described above, or 0
if the library is not open for use,
XCLIB-Lite is being used,
or the wrong imaging board is in use.
<P>
The
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
returns:
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERNOOPTION<DD>
Wrong imaging board.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_setExsyncPrincMode NX372"CLASS="NX"></A>
<A NAME="pxd_setExsyncPrincMode"CLASS="Sf"></A>
<A NAME="Set EXSYNC and PRINC Modes NX373"CLASS="NX"></A>
<A NAME="Set EXSYNC and PRINC Modes   ---   pxd_setExsyncPrincMode"CLASS="Sf"></A>
<A NAME="Set EXSYNC and PRINC Modes   ---   pxd_setExsyncPrincMode"></A>
<H6 CLASS="Sf">Set EXSYNC and PRINC Modes   ---   pxd_setExsyncPrincMode</H6>
<A NAME="pxd_getExsyncMode NX374"CLASS="NX"></A>
<A NAME="pxd_getExsyncMode"CLASS="Sg"></A>
<A NAME="Get EXSYNC Mode NX375"CLASS="NX"></A>
<A NAME="Get EXSYNC Mode   ---   pxd_getExsyncMode"CLASS="Sg"></A>
<A NAME="Get EXSYNC Mode   ---   pxd_getExsyncMode"></A>
<H6 CLASS="Sg">Get EXSYNC Mode   ---   pxd_getExsyncMode</H6>
<A NAME="pxd_getPrincMode NX376"CLASS="NX"></A>
<A NAME="pxd_getPrincMode"CLASS="Sg"></A>
<A NAME="Get PRINC Mode NX377"CLASS="NX"></A>
<A NAME="Get PRINC Mode   ---   pxd_getPrincMode"CLASS="Sg"></A>
<A NAME="Get PRINC Mode   ---   pxd_getPrincMode"></A>
<H6 CLASS="Sg">Get PRINC Mode   ---   pxd_getPrincMode</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  pxd_setExsyncPrincMode(unitmap, exsyncbits, princbits);
uint pxd_getExsyncMode(unitmap);
uint pxd_getPrincMode(unitmap);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint                exsyncbits;     // The EXSYNC mode bits
uint                princbits;      // The PRINC mode bits
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
EXSYNC and PRIN mode bits for
PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, SI and A imaging boards,
are set, or the current values obtained.
Depending upon camera,
these values typically control the camera's
operating mode, such as pixel clock, binning,
resolution, trigger mode, synchronization, and scaling of the
EXSYNC and/or PRIN values used by
<A HREF="#pxd_setExsyncPrinc"CLASS="Er">pxd_setExsyncPrinc</A>.
The allowable bits and their meaning
are camera specific,
and discussed in the
<CITE CLASS="Ec">PIXCI&reg; User's Manual</CITE>.
<P>
Only those bits which control the
camera's pixel clock frequency, scaling of
EXSYNC and/or PRIN values, or similar
features should be changed by using
<A HREF="#pxd_setExsyncPrincMode"CLASS="Er">pxd_setExsyncPrincMode</A>.
Other features, such as a change to
binning, resolution, or trigger mode
also require a change to the video format configuration,
which this function does not automatically perform.
Use of
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
or
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
with a video format configuration exported by XCAP
should be used to effect change to all EXSYNC and PRINC
values and bits.
<P>
The
<A HREF="#pxd_setExsyncPrinMode"CLASS="Er">pxd_setExsyncPrinMode</A>
sets the EXSYNC bits to
<EM CLASS="Ep">exsyncbits</EM>
and the PRINC bits to
<EM CLASS="Ep">princbits</EM>
on the multiple units specified by
<EM CLASS="Ep">unitmap</EM>.
The
<A HREF="#pxd_getExsyncMode"CLASS="Er">pxd_getExsyncMode</A>
returns the current EXSYNC bits
on the single unit selected by
<EM CLASS="Ep">unitmap</EM>.
The
<A HREF="#pxd_getPrincMode"CLASS="Er">pxd_getPrincMode</A>
returns the current PRIN bits
on the single unit selected by
<EM CLASS="Ep">unitmap</EM>.
<P>
Currently, the library does not actually
remember distinct values for various units.
The
<A HREF="#pxd_setExsyncPrincMode"CLASS="Er">pxd_setExsyncPrincMode</A>
can be used to set different units to different
values, but the
<A HREF="#pxd_getExsyncMode"CLASS="Er">pxd_getExsyncMode</A>
and
<A HREF="#pxd_getPrinMode"CLASS="Er">pxd_getPrinMode</A>
always return the last value set on any unit.
<P>
Some versions of the
<CITE CLASS="Ec">PIXCI&reg; User's Manual</CITE>
may discuss the EXSYNC value, the PRIN value,
the EXSYNC mode bits, and the PRINC mode bits
in conjunction with the XCOBJ library functions named
<CITE CLASS="Ec">pxd_setDalsa01</CITE>
<CITE CLASS="Ec">pxd_setHitachi01</CITE>
or
<CITE CLASS="Ec">pxd_setBasler01</CITE>.
Each of these XCOBJ functions is actually identical, and they are
equivalent to:
<BLOCKQUOTE>
<PRE>
    #define pxd_setDalsa01(p,e) { \
                pxd_setExsyncPrin(1,e&gt;&gt;16,p&gt;&gt;16); \
                pxd_setExsyncPrincMode(1,e&amp;0xFFFF,p&amp;0xFFFF); \
                                }
</PRE>
</BLOCKQUOTE>
<P>
The XCLIB-Lite does not support this feature.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_getExsyncMode"CLASS="Er">pxd_getExsyncMode</A>
and
<A HREF="#pxd_getPrincMode"CLASS="Er">pxd_getPrincMode</A>
returns values as described above, or 0
if the library is not open for use,
XCLIB-Lite is being used,
or the wrong imaging board is in use.
<P>
The
<A HREF="#pxd_setExsyncPrinMode"CLASS="Er">pxd_setExsyncPrinMode</A>
returns:
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERNOOPTION<DD>
Wrong imaging board.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_setVidMux NX378"CLASS="NX"></A>
<A NAME="pxd_setVidMux"CLASS="Sf"></A>
<A NAME="Set Video Input Multiplexer NX379"CLASS="NX"></A>
<A NAME="Set Video Input Multiplexer   ---   pxd_setVidMux"CLASS="Sf"></A>
<A NAME="Set Video Input Multiplexer   ---   pxd_setVidMux"></A>
<H6 CLASS="Sf">Set Video Input Multiplexer   ---   pxd_setVidMux</H6>
<A NAME="pxd_setContrastBrightness NX380"CLASS="NX"></A>
<A NAME="pxd_setContrastBrightness"CLASS="Sg"></A>
<A NAME="Set Video Contrast and Brightness NX381"CLASS="NX"></A>
<A NAME="Set Video Contrast and Brightness   ---   pxd_setContrastBrightness"CLASS="Sg"></A>
<A NAME="Set Video Contrast and Brightness   ---   pxd_setContrastBrightness"></A>
<H6 CLASS="Sg">Set Video Contrast and Brightness   ---   pxd_setContrastBrightness</H6>
<A NAME="pxd_setHueSaturation NX382"CLASS="NX"></A>
<A NAME="pxd_setHueSaturation"CLASS="Sg"></A>
<A NAME="Set Video Hue and Saturation NX383"CLASS="NX"></A>
<A NAME="Set Video Hue and Saturation   ---   pxd_setHueSaturation"CLASS="Sg"></A>
<A NAME="Set Video Hue and Saturation   ---   pxd_setHueSaturation"></A>
<H6 CLASS="Sg">Set Video Hue and Saturation   ---   pxd_setHueSaturation</H6>
<A NAME="pxd_getVidMux NX384"CLASS="NX"></A>
<A NAME="pxd_getVidMux"CLASS="Sg"></A>
<A NAME="Get Video Input Multiplexer NX385"CLASS="NX"></A>
<A NAME="Get Video Input Multiplexer   ---   pxd_getVidMux"CLASS="Sg"></A>
<A NAME="Get Video Input Multiplexer   ---   pxd_getVidMux"></A>
<H6 CLASS="Sg">Get Video Input Multiplexer   ---   pxd_getVidMux</H6>
<A NAME="pxd_getContrast NX386"CLASS="NX"></A>
<A NAME="pxd_getContrast"CLASS="Sg"></A>
<A NAME="Get Video Contrast NX387"CLASS="NX"></A>
<A NAME="Get Video Contrast   ---   pxd_getContrast"CLASS="Sg"></A>
<A NAME="Get Video Contrast   ---   pxd_getContrast"></A>
<H6 CLASS="Sg">Get Video Contrast   ---   pxd_getContrast</H6>
<A NAME="pxd_getBrightness NX388"CLASS="NX"></A>
<A NAME="pxd_getBrightness"CLASS="Sg"></A>
<A NAME="Get Video Brightness NX389"CLASS="NX"></A>
<A NAME="Get Video Brightness   ---   pxd_getBrightness"CLASS="Sg"></A>
<A NAME="Get Video Brightness   ---   pxd_getBrightness"></A>
<H6 CLASS="Sg">Get Video Brightness   ---   pxd_getBrightness</H6>
<A NAME="pxd_getHue NX390"CLASS="NX"></A>
<A NAME="pxd_getHue"CLASS="Sg"></A>
<A NAME="Get Video Hue NX391"CLASS="NX"></A>
<A NAME="Get Video Hue   ---   pxd_getHue"CLASS="Sg"></A>
<A NAME="Get Video Hue   ---   pxd_getHue"></A>
<H6 CLASS="Sg">Get Video Hue   ---   pxd_getHue</H6>
<A NAME="pxd_getUGain NX392"CLASS="NX"></A>
<A NAME="pxd_getUGain"CLASS="Sg"></A>
<A NAME="Get Video U Saturation NX393"CLASS="NX"></A>
<A NAME="Get Video U Saturation   ---   pxd_getUGain"CLASS="Sg"></A>
<A NAME="Get Video U Saturation   ---   pxd_getUGain"></A>
<H6 CLASS="Sg">Get Video U Saturation   ---   pxd_getUGain</H6>
<A NAME="pxd_getVGain NX394"CLASS="NX"></A>
<A NAME="pxd_getVGain"CLASS="Sg"></A>
<A NAME="Get Video V Saturation NX395"CLASS="NX"></A>
<A NAME="Get Video V Saturation   ---   pxd_getVGain"CLASS="Sg"></A>
<A NAME="Get Video V Saturation   ---   pxd_getVGain"></A>
<H6 CLASS="Sg">Get Video V Saturation   ---   pxd_getVGain</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int     pxd_setVidMux(unitmap, inmux);
int     pxd_setContrastBrightness(unitmap, contrast, brightness);
int     pxd_setHueSaturation(unitmap, hue, Ugain, Vgain);
int     pxd_getVidMux(unitmap);
double  pxd_getContrast(unitmap);
double  pxd_getBrightness(unitmap);
double  pxd_getHue(unitmap);
double  pxd_getUGain(unitmap);
double  pxd_getVGain(unitmap);
<BR>
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 mux;            // Multiplexer selection
double              contrast;       // Percent change of contrast, default=100
double              brightness;     // Percent change of brightness, default=0
double              hue;            // Percent change of hue, default=100
double              Ugain;          // Percent change of U Gain, default=100
double              Vgain;          // Percent change of V Gain, default=100
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
multiplexer selection, contrast, brightness,
and other A/D characteristics of
PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards,
are set, or the current value obtained.
<P>
For the PIXCI&reg;&nbsp;SV2, SV3, SV4, or SV5,
the
<A HREF="#pxd_setVidMux"CLASS="Er">pxd_setVidMux</A>
sets the current multiplexer setting,
on the multiple units specified by
<EM CLASS="Ep">unitmap</EM>,
with
<EM CLASS="Ep">inmux</EM>=1
selecting the S-Video connector,
<EM CLASS="Ep">inmux</EM>=2
selecting the BNC connector nearest the S-Video
connector, and
<EM CLASS="Ep">inmux</EM>=3
selecting the last BNC connector
(on SV3, SV4, and SV5 only).
<P>
For the PIXCI&reg;&nbsp;SV5A,
the
<A HREF="#pxd_setVidMux"CLASS="Er">pxd_setVidMux</A>
sets the current multiplexer setting,
on the multiple units specified by
<EM CLASS="Ep">unitmap</EM>,
with
<EM CLASS="Ep">inmux</EM>=1
selecting top BNC connector,
<EM CLASS="Ep">inmux</EM>=2
selecting the middle BNC connector,
and
<EM CLASS="Ep">inmux</EM>=3
selecting the bottom BNC connector
(nearest the DB-15 connector).
<P>
The
<A HREF="#pxd_getVidMux"CLASS="Er">pxd_getVidMux</A>
returns the current multiplexer setting,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>,
with the same interpretation as used for the
<EM CLASS="Ep">inmux</EM>
parameter of
<A HREF="#pxd_setVidMux"CLASS="Er">pxd_setVidMux</A>.
<P>
The
<A HREF="#pxd_setContrastBrightness"CLASS="Er">pxd_setContrastBrightness</A>
sets the A/D contrast and brightness,
on the multiple units specified by
<EM CLASS="Ep">unitmap</EM>,
to
<EM CLASS="Ep">contrast</EM>
percent of the default contrast (gain)
and
<EM CLASS="Ep">brightness</EM>
percent of the default brightness.
<P>
The
<A HREF="#pxd_getContrast"CLASS="Er">pxd_getContrast</A>
and
<A HREF="#pxd_getBrightness"CLASS="Er">pxd_getBrightness</A>
return the current contrast and brightness setting,
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>,
with the same interpretation as used for the
<EM CLASS="Ep">contrast</EM>
and
<EM CLASS="Ep">brightness</EM>
parameters of
<A HREF="#pxd_setContrastBrightness"CLASS="Er">pxd_setContrastBrightness</A>.
<P>
The
<A HREF="#pxd_setHueSaturation"CLASS="Er">pxd_setHueSaturation</A>
sets the A/D hue and saturation,
on the multiple units specified by
<EM CLASS="Ep">unitmap</EM>,
to
<EM CLASS="Ep">hue</EM>
percent of the default hue,
<EM CLASS="Ep">Ugain</EM>
percent of the default U&nbsp;gain,
and
<EM CLASS="Ep">Vgain</EM>
percent of the default V&nbsp;gain.
<P>
The
<A HREF="#pxd_getHue"CLASS="Er">pxd_getHue</A>,
<A HREF="#pxd_getUgain"CLASS="Er">pxd_getUgain</A>,
and
<A HREF="#pxd_getVgain"CLASS="Er">pxd_getVgain</A>
return the current hue, U&nbsp;gain, and V&nbsp;gain
on the single unit specified by
<EM CLASS="Ep">unitmap</EM>,
with the same interpretation as used for the
<EM CLASS="Ep">hue</EM>,
<EM CLASS="Ep">Ugain</EM>,
and
<EM CLASS="Ep">Vgain</EM>
parameters of
<A HREF="#pxd_setHueSaturation"CLASS="Er">pxd_setHueSaturation</A>.
<P>
Currently, the library does not actually
remember distinct values for various units.
The
<A HREF="#pxd_setContrastBrightness"CLASS="Er">pxd_setContrastBrightness</A>,
<A HREF="#pxd_setVidMux"CLASS="Er">pxd_setVidMux</A>,
and
<A HREF="#pxd_setHueSaturation"CLASS="Er">pxd_setHueSaturation</A>
can be used to set different units to different
values, but the
<A HREF="#pxd_getVidMux"CLASS="Er">pxd_getVidMux</A>,
<A HREF="#pxd_getContrast"CLASS="Er">pxd_getContrast</A>,
<A HREF="#pxd_getBrightness"CLASS="Er">pxd_getBrightness</A>,
<A HREF="#pxd_getHue"CLASS="Er">pxd_getHue</A>,
<A HREF="#pxd_getUGain"CLASS="Er">pxd_getUGain</A>,
and
<A HREF="#pxd_getVGain"CLASS="Er">pxd_getVGain</A>
always return the last value set on any unit.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_getVidMux"CLASS="Er">pxd_getVidMux</A>,
<A HREF="#pxd_getContrast"CLASS="Er">pxd_getContrast</A>,
<A HREF="#pxd_getBrightness"CLASS="Er">pxd_getBrightness</A>,
<A HREF="#pxd_getHue"CLASS="Er">pxd_getHue</A>,
<A HREF="#pxd_getUGain"CLASS="Er">pxd_getUGain</A>,
and
<A HREF="#pxd_getVGain"CLASS="Er">pxd_getVGain</A>
returns values as described above, or 0
if the library is not open for use or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_setVidMux"CLASS="Er">pxd_setVidMux</A>,
<A HREF="#pxd_setContrastBrightness"CLASS="Er">pxd_setContrastBrightness</A>,
and
<A HREF="#pxd_setHueSaturation"CLASS="Er">pxd_setHueSaturation</A>
return:
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERNOOPTION<DD>
Wrong imaging board.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_setImageBrightBalance NX396"CLASS="NX"></A>
<A NAME="pxd_setImageBrightBalance"CLASS="Sf"></A>
<A NAME="Set Bright White Balance NX397"CLASS="NX"></A>
<A NAME="Set Bright White Balance   ---   pxd_setImageBrightBalance"CLASS="Sf"></A>
<A NAME="Set Bright White Balance   ---   pxd_setImageBrightBalance"></A>
<H6 CLASS="Sf">Set Bright White Balance   ---   pxd_setImageBrightBalance</H6>
<A NAME="pxd_setImageDarkBalance NX398"CLASS="NX"></A>
<A NAME="pxd_setImageDarkBalance"CLASS="Sg"></A>
<A NAME="Set Dark White Balance NX399"CLASS="NX"></A>
<A NAME="Set Dark White Balance   ---   pxd_setImageDarkBalance"CLASS="Sg"></A>
<A NAME="Set Dark White Balance   ---   pxd_setImageDarkBalance"></A>
<H6 CLASS="Sg">Set Dark White Balance   ---   pxd_setImageDarkBalance</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_setImageDarkBalance(unitmap, referenceRGB[3], targetRGB[3], gamma);
int pxd_setImageBrightBalance(unitmap, referenceRGB[3], targetRGB[3], gamma);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
uint                referenceRGB[3];    // Observed pixel values, R/G/B
uint                targetRGB[3];       // Target pixel values, R/G/B
double              gamma;              // Gamma correction, or 0 to disable balancing
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_setImageDarkBalance"CLASS="Er">pxd_setImageDarkBalance</A>
sets the dark balance subtractive correction so that pixel values of
<EM CLASS="Ep">referenceRGB</EM>[0],
<EM CLASS="Ep">referenceRGB</EM>[1],
and
<EM CLASS="Ep">referenceRGB</EM>[2]
map to
<EM CLASS="Ep">targetRGB</EM>[0],
<EM CLASS="Ep">targetRGB</EM>[1],
and
<EM CLASS="Ep">targetRGB</EM>[2],
respectively.
The
<A HREF="#pxd_setImageBrightBalance"CLASS="Er">pxd_setImageBrightBalance</A>
sets the bright (white) balance multiplicative correction
so that pixel values of
<EM CLASS="Ep">referenceRGB</EM>[0],
<EM CLASS="Ep">referenceRGB</EM>[1],
and
<EM CLASS="Ep">referenceRGB</EM>[2]
map to
<EM CLASS="Ep">targetRGB</EM>[0],
<EM CLASS="Ep">targetRGB</EM>[1],
and
<EM CLASS="Ep">targetRGB</EM>[2],
respectively.
The
<EM CLASS="Ep">referenceRGB</EM>
and
<EM CLASS="Ep">targetRGB</EM>
should range between 0 and the maximum pixel value
(255 for 8 bit pixels).
<P>
The
<EM CLASS="Ep">gamma</EM>
sets the non-linear gamma correction.
There is only a single gamma correction, which can be specified
with either
<A HREF="#pxd_setImageDarkBalance"CLASS="Er">pxd_setImageDarkBalance</A>
or
<A HREF="#pxd_setImageBrightBalance"CLASS="Er">pxd_setImageBrightBalance</A>.
A
<EM CLASS="Ep">gamma</EM>=0
disables dark balancing, bright balancing, and gamma correction.
<P>
For PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, SV5A, and A imaging boards:
The
<A HREF="#pxd_setImageDarkBalance"CLASS="Er">pxd_setImageDarkBalance</A>
and
<A HREF="#pxd_setImageBrightBalance"CLASS="Er">pxd_setImageBrightBalance</A>
are not used.
<P>
For PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and CL3SD imaging boards:
The
<A HREF="#pxd_setImageDarkBalance"CLASS="Er">pxd_setImageDarkBalance</A>
and
<A HREF="#pxd_setImageBrightBalance"CLASS="Er">pxd_setImageBrightBalance</A>
are intended for use only
with Bayer output color cameras.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_videoFieldCount NX400"CLASS="NX"></A>
<A NAME="pxd_videoFieldCount"CLASS="Sf"></A>
<A NAME="Get Video Field Count NX401"CLASS="NX"></A>
<A NAME="Get Video Field Count   ---   pxd_videoFieldCount"CLASS="Sf"></A>
<A NAME="Get Video Field Count   ---   pxd_videoFieldCount"></A>
<H6 CLASS="Sf">Get Video Field Count   ---   pxd_videoFieldCount</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
ulong pxd_videoFieldCount(unitmap);
int                 unitmap;        // Unit selection bit map (1 for single unit)
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The number of elapsed vertical blanking intervals,
i.e. video fields, is returned.
Video fields are counted regardless of whether or not
the field is captured, such as with
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
or
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>.
The counter's frequency is dependent upon the video format
and/or external video sources;
for NTSC or RS-170 the frequency is 60&nbsp;Hz
for CCIR or PAL the frequency is 50&nbsp;Hz.
<P>
For PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards:
The count increments even when no video source is
connected to the imaging board.
For PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, SI, and A imaging boards:
The count increments only when a video source is connected to the imaging board.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<HR SIZE="1">
<A NAME="pxd_videoFieldsPerFrame NX402"CLASS="NX"></A>
<A NAME="pxd_videoFieldsPerFrame"CLASS="Sf"></A>
<A NAME="Get Video Field Characteristic NX403"CLASS="NX"></A>
<A NAME="Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame"CLASS="Sf"></A>
<A NAME="Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame"></A>
<H6 CLASS="Sf">Get Video Field Characteristic   ---   pxd_videoFieldsPerFrame</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int pxd_videoFieldsPerFrame();
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The number of video fields in each video frame,
for the current video format, is returned.
This does not return a measured characteristic
of the current video signal, but an expectation
defined by the current video format.
<P>
The similar
<A HREF="#pxd_imageIdim"CLASS="Er">pxd_imageIdim</A>
returns the number of stored fields within a frame buffer,
while
<A HREF="#pxd_videoFieldsPerFrame"CLASS="Er">pxd_videoFieldsPerFrame</A>
returns the number of video fields within a video frame.
The former may be 1 even if the latter is 2,
such as when capturing in a
''field''
mode with each new captured field replacing the former
within the
''field buffer''.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<HR SIZE="1">
<A NAME="pxd_videoFormatAsIncluded NX404"CLASS="NX"></A>
<A NAME="pxd_videoFormatAsIncluded"CLASS="Sf"></A>
<A NAME="Set Video Configuration as per Compiled Include NX405"CLASS="NX"></A>
<A NAME="Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded"CLASS="Sf"></A>
<A NAME="Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded"></A>
<H6 CLASS="Sf">Set Video Configuration as per Compiled Include   ---   pxd_videoFormatAsIncluded</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  pxd_videoFormatAsIncluded(rsvd);
<BR>
int                 rsvd;           // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
is a macro that allows configuring XCLIB as per a
video format configuration
(also referred to as a video state) previously exported by the XCAP program
or the XCLIB library.
Unlike use of
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
which loads a video format configuration
from a file at run-time, the
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
changes the video format configuration
without closing the XCLIB library,
and allows use of a video format configuration
which has been compiled into the application.
<P>
The expected use of
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
is:
<BLOCKQUOTE>
<PRE>
    {
        #include &quot;format.fmt&quot;
        pxd_videoFormatAsIncluded(0);
    }
</PRE>
</BLOCKQUOTE>
where the
''format.fmt''
is a video format configuration file
(also referred to as a video state) previously exported by the XCAP program
or the XCLIB library.
<P>
The
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
terminates any video capture currently in progress,
and may result in a change to the values reported by
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>(),
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>(),
<A HREF="#pxd_imageCdim"CLASS="Er">pxd_imageCdim</A>(),
<A HREF="#pxd_imageBdim"CLASS="Er">pxd_imageBdim</A>(),
<A HREF="#pxd_imageZdim"CLASS="Er">pxd_imageZdim</A>(),
<A HREF="#pxd_imageIdim"CLASS="Er">pxd_imageIdim</A>(),
<A HREF="#pxd_imageAspectRatio"CLASS="Er">pxd_imageAspectRatio</A>()
and similar functions.
<P>
The XCLIB-Lite does not support this feature.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Function performed.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV2112_setExposureAndGain NX406"CLASS="NX"></A>
<A NAME="pxd_SV2112_setExposureAndGain"CLASS="Sf"></A>
<A NAME="Set SV2112 Exposure and Gain NX407"CLASS="NX"></A>
<A NAME="Set SV2112 Exposure and Gain   ---   pxd_SV2112_setExposureAndGain"CLASS="Sf"></A>
<A NAME="Set SV2112 Exposure and Gain   ---   pxd_SV2112_setExposureAndGain"></A>
<H6 CLASS="Sf">Set SV2112 Exposure and Gain   ---   pxd_SV2112_setExposureAndGain</H6>
<A NAME="pxd_SV2112_getExposure NX408"CLASS="NX"></A>
<A NAME="pxd_SV2112_getExposure"CLASS="Sg"></A>
<A NAME="Get SV2112 Exposure NX409"CLASS="NX"></A>
<A NAME="Get SV2112 Exposure   ---   pxd_SV2112_getExposure"CLASS="Sg"></A>
<A NAME="Get SV2112 Exposure   ---   pxd_SV2112_getExposure"></A>
<H6 CLASS="Sg">Get SV2112 Exposure   ---   pxd_SV2112_getExposure</H6>
<A NAME="pxd_SV2112_getGain NX410"CLASS="NX"></A>
<A NAME="pxd_SV2112_getGain"CLASS="Sg"></A>
<A NAME="Get SV2112 Gain NX411"CLASS="NX"></A>
<A NAME="Get SV2112 Gain   ---   pxd_SV2112_getGain"CLASS="Sg"></A>
<A NAME="Get SV2112 Gain   ---   pxd_SV2112_getGain"></A>
<H6 CLASS="Sg">Get SV2112 Gain   ---   pxd_SV2112_getGain</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV2112_setExposureAndGain(unitmap, rsvd, exposure, redgain, grngain, blugain);
double pxd_SV2112_getExposure(unitmap);
double pxd_SV2112_getGain(unitmap, color);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
double              exposure;           // Exposure period, in milliseconds
double              redgain;            // Gain of red pixels, in dB.
double              grngain;            // Gain of green pixels, in dB.
double              blugain;            // Gain of blue pixels, in dB.
int                 color;              // Color selection: 'R', 'G', or 'B'
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO&reg; NX412"CLASS="NX"></A>
The
<A HREF="#pxd_SV2112_setExposureAndGain"CLASS="Er">pxd_SV2112_setExposureAndGain</A>
sets the exposure period and gain of
SILICON VIDEO&reg; 2112 and
SILICON VIDEO&reg; 2112C
cameras connected to PIXCI&reg; D2X imaging boards.
<P>
The camera's exposure period
is set to
<EM CLASS="Ep">exposure</EM>
milliseconds.
The allowable values are dependent on the camera's
current operating mode - specifically the pixel clock frequency,
AOI height, and decimation.
Any invalid value is corrected to the nearest valid value.
<P>
The camera's gain of red, green, and blue
pixels is set to
<EM CLASS="Ep">redgain</EM>,
<EM CLASS="Ep">grngain</EM>,
and
<EM CLASS="Ep">blugain</EM>,
respectively,
each in the range of 0.0 to 14.0 dB.
Different gains per
''color''
can be set for the SILICON VIDEO&reg; 2112
(i.e. monochrome) camera; the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, for monochrome cameras the gains are identical.
<P>
The
<A HREF="#pxd_SV2112_getExposure"CLASS="Er">pxd_SV2112_getExposure</A>
returns the current exposure setting,
in milliseconds.
<P>
The
<A HREF="#pxd_SV2112_getGain"CLASS="Er">pxd_SV2112_getGain</A>
returns one of the current gain settings, in dB.
If
<EM CLASS="Ep">color</EM>='R',
the red gain is returned,
if
<EM CLASS="Ep">color</EM>='G',
the green gain is returned.
if
<EM CLASS="Ep">color</EM>='B',
the blue gain is returned.
<P>
Note: The
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
performs partial, quick initialization of XCLIB;
initialization for the
<CITE CLASS="Ec">pxd_SV2112_</CITE>
functions is delayed until the first such function is called.
Time sensitive applications should call
any
<CITE CLASS="Ec">pxd_SV2112_</CITE>
function once
before entering the application's time critical phase.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV2112_getExposure"CLASS="Er">pxd_SV2112_getExposure</A>
and
<A HREF="#pxd_SV2112_getGain"CLASS="Er">pxd_SV2112_getGain</A>
returns values as described above, or 0
if the library is not open for use, the
wrong imaging board is in use, or an invalid
value of
<EM CLASS="Ep">color</EM>
is used.
<P>
The
<A HREF="#pxd_SV2112_setExposureAndGain"CLASS="Er">pxd_SV2112_setExposureAndGain</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV2112_setResolutionAndTiming NX413"CLASS="NX"></A>
<A NAME="pxd_SV2112_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV2112 Resolution and Timing NX414"CLASS="NX"></A>
<A NAME="Set SV2112 Resolution and Timing   ---   pxd_SV2112_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV2112 Resolution and Timing   ---   pxd_SV2112_setResolutionAndTiming"></A>
<H6 CLASS="Sf">Set SV2112 Resolution and Timing   ---   pxd_SV2112_setResolutionAndTiming</H6>
<A NAME="pxd_SV2112_getDecimation NX415"CLASS="NX"></A>
<A NAME="pxd_SV2112_getDecimation"CLASS="Sg"></A>
<A NAME="Get SV2112 Decimation NX416"CLASS="NX"></A>
<A NAME="Get SV2112 Decimation   ---   pxd_SV2112_getDecimation"CLASS="Sg"></A>
<A NAME="Get SV2112 Decimation   ---   pxd_SV2112_getDecimation"></A>
<H6 CLASS="Sg">Get SV2112 Decimation   ---   pxd_SV2112_getDecimation</H6>
<A NAME="pxd_SV2112_getAoiTop NX417"CLASS="NX"></A>
<A NAME="pxd_SV2112_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV2112 Aoi Top Edge NX418"CLASS="NX"></A>
<A NAME="Get SV2112 Aoi Top Edge   ---   pxd_SV2112_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV2112 Aoi Top Edge   ---   pxd_SV2112_getAoiTop"></A>
<H6 CLASS="Sg">Get SV2112 Aoi Top Edge   ---   pxd_SV2112_getAoiTop</H6>
<A NAME="pxd_SV2112_getAoiLeft NX419"CLASS="NX"></A>
<A NAME="pxd_SV2112_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV2112 Aoi Left Edge NX420"CLASS="NX"></A>
<A NAME="Get SV2112 Aoi Left Edge   ---   pxd_SV2112_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV2112 Aoi Left Edge   ---   pxd_SV2112_getAoiLeft"></A>
<H6 CLASS="Sg">Get SV2112 Aoi Left Edge   ---   pxd_SV2112_getAoiLeft</H6>
<A NAME="pxd_SV2112_getPixelClock NX421"CLASS="NX"></A>
<A NAME="pxd_SV2112_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV2112 Pixel Clock Frequency NX422"CLASS="NX"></A>
<A NAME="Get SV2112 Pixel Clock Frequency   ---   pxd_SV2112_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV2112 Pixel Clock Frequency   ---   pxd_SV2112_getPixelClock"></A>
<H6 CLASS="Sg">Get SV2112 Pixel Clock Frequency   ---   pxd_SV2112_getPixelClock</H6>
<A NAME="pxd_SV2112_getScanDirection NX423"CLASS="NX"></A>
<A NAME="pxd_SV2112_getScanDirection"CLASS="Sg"></A>
<A NAME="Get SV2112 Scan Direction NX424"CLASS="NX"></A>
<A NAME="Get SV2112 Scan Direction   ---   pxd_SV2112_getScanDirection"CLASS="Sg"></A>
<A NAME="Get SV2112 Scan Direction   ---   pxd_SV2112_getScanDirection"></A>
<H6 CLASS="Sg">Get SV2112 Scan Direction   ---   pxd_SV2112_getScanDirection</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV2112_setResolutionAndTiming(unitmap, rsvd, decimation, aoileft, aoitop, aoiwidth,
                                     aoiheight, scandirection, pixelClkFreq, rsvd2, rsvd3);
int    pxd_SV2112_getDecimation(unitmap);
int    pxd_SV2112_getAoiTop(unitmap);
int    pxd_SV2112_getAoiLeft(unitmap);
int    pxd_SV2112_getScanDirection(unitmap);
double pxd_SV2112_getPixelClock(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 decimation;         // Decimation: 0x0101 for none
                                        //             0x0202 for 2x2
                                        //             0x0404 for 4x4
int                 aoileft;            // Left edge of partial scan AOI
int                 aoitop;             // Top edge of partial scan AOI
int                 aoiwidth;           // Width of partial scan AOI
int                 aoiheight;          // Height of partial scan AOI
int                 scandirection;      // Scan direction:
                                        //   ('L'&lt;&lt;8)|'T': Left-Right/Top-Bottom
                                        //   ('R'&lt;&lt;8)|'T': Right-Left/Top-Bottom
                                        //   ('L'&lt;&lt;8)|'B': Left-Right/Bottom-Top
                                        //   ('R'&lt;&lt;8)|'B': Right-Left/Bottom-Top
double              pixelClkFreq;       // Pixel clock frequency, in MHz.
double              rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV2112_setResolutionAndTiming"CLASS="Er">pxd_SV2112_setResolutionAndTiming</A>
sets the resolution, scan direction, and pixel clock frequency of
SILICON VIDEO&reg; 2112 and
SILICON VIDEO&reg; 2112C
cameras connected to PIXCI&reg; D2X imaging boards.
<P>
The
<EM CLASS="Ep">decimation</EM>
selects readout subsampling of the sensor.
If
<EM CLASS="Ep">decimation</EM>=0x0101,
subsampling is disabled.
If
<EM CLASS="Ep">decimation</EM>=0x0202,
the readout and captured image consists of every 2'nd pixel,
both horizontally and vertically.
If
<EM CLASS="Ep">decimation</EM>=0x0404,
the readout and captured image consists of every 4'th pixel,
both horizontally and vertically.
<P>
The
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
and
<EM CLASS="Ep">aoiheight</EM>
select partial scan readout of the sensor, selecting
the coordinates of the left edge and top edge of the readout AOI,
and width and height of the readout AOI.
These parameters are always relative to the sensor's full resolution,
namely 1288 by 1032, and are not to be scaled due to use of
<EM CLASS="Ep">decimation</EM>.
<P>
The
<EM CLASS="Ep">scandirection</EM>
selects readout scan direction.
If
<EM CLASS="Ep">scandirection</EM>=('L'&lt;&lt;8)|'T',
the readout is left to right, top to bottom.
If
<EM CLASS="Ep">scandirection</EM>=('R'&lt;&lt;8)|'T',
the readout is the default right to left, top to bottom.
If
<EM CLASS="Ep">scandirection</EM>=('L'&lt;&lt;8)|'B',
the readout is left to right, bottom to top.
If
<EM CLASS="Ep">scandirection</EM>=('R'&lt;&lt;8)|'B'
the readout is right to left, bottom to top.
<P>
The
<EM CLASS="Ep">pixelClkFreq</EM>
specifies the sensor's pixel clock frequency, in MHz.
Lower frequencies provide for longer exposures, but slower
frame rates.
Higher frequencies provide higher frame rates, but shorter
exposures and more fixed pattern noise.
<P>
Use of
<A HREF="#pxd_SV2112_setResolutionAndTiming"CLASS="Er">pxd_SV2112_setResolutionAndTiming</A>
may change the captured image's resolution,
and thus affect the return values of
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>
and
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>.
Use of
<A HREF="#pxd_SV2112_setResolutionAndTiming"CLASS="Er">pxd_SV2112_setResolutionAndTiming</A>
will terminate any capture in progress,
such as that initiated by
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
or
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>.
<P>
The
<A HREF="#pxd_SV2112_getDecimation"CLASS="Er">pxd_SV2112_getDecimation</A>
returns the current decimation setting, coded as described above.
The
<A HREF="#pxd_SV2112_getAoiTop"CLASS="Er">pxd_SV2112_getAoiTop</A>
and
<A HREF="#pxd_SV2112_getAoiLeft"CLASS="Er">pxd_SV2112_getAoiLeft</A>
return the current AOI left and top edges, respectively.
The
<A HREF="#pxd_SV2112_getScanDirection"CLASS="Er">pxd_SV2112_getScanDirection</A>
returns the current scan direction setting, coded as described above.
The
<A HREF="#pxd_SV2112_getPixelClock"CLASS="Er">pxd_SV2112_getPixelClock</A>
returns the current pixel clock frequency, as described above.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV2112_getDecimation"CLASS="Er">pxd_SV2112_getDecimation</A>,
<A HREF="#pxd_SV2112_getAoiTop"CLASS="Er">pxd_SV2112_getAoiTop</A>,
<A HREF="#pxd_SV2112_getAoiLeft"CLASS="Er">pxd_SV2112_getAoiLeft</A>,
<A HREF="#pxd_SV2112_getScanDirection"CLASS="Er">pxd_SV2112_getScanDirection</A>,
and
<A HREF="#pxd_SV2112_getPixelClock"CLASS="Er">pxd_SV2112_getPixelClock</A>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV2112_setResolutionAndTiming"CLASS="Er">pxd_SV2112_setResolutionAndTiming</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV2112_setVideoAndTriggerMode NX425"CLASS="NX"></A>
<A NAME="pxd_SV2112_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV2112 Video And Trigger Modes NX426"CLASS="NX"></A>
<A NAME="Set SV2112 Video And Trigger Modes   ---   pxd_SV2112_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV2112 Video And Trigger Modes   ---   pxd_SV2112_setVideoAndTriggerMode"></A>
<H6 CLASS="Sf">Set SV2112 Video And Trigger Modes   ---   pxd_SV2112_setVideoAndTriggerMode</H6>
<A NAME="pxd_SV2112_setCtrlExposureAndRate NX427"CLASS="NX"></A>
<A NAME="pxd_SV2112_setCtrlExposureAndRate"CLASS="Sg"></A>
<A NAME="Set SV2112 Controlled Exposure And Frame Rate NX428"CLASS="NX"></A>
<A NAME="Set SV2112 Controlled Exposure And Frame Rate   ---   pxd_SV2112_setCtrlExposureAndRate"CLASS="Sg"></A>
<A NAME="Set SV2112 Controlled Exposure And Frame Rate   ---   pxd_SV2112_setCtrlExposureAndRate"></A>
<H6 CLASS="Sg">Set SV2112 Controlled Exposure And Frame Rate   ---   pxd_SV2112_setCtrlExposureAndRate</H6>
<A NAME="pxd_SV2112_getVideoMode NX429"CLASS="NX"></A>
<A NAME="pxd_SV2112_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV2112 Video Mode NX430"CLASS="NX"></A>
<A NAME="Get SV2112 Video Mode   ---   pxd_SV2112_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV2112 Video Mode   ---   pxd_SV2112_getVideoMode"></A>
<H6 CLASS="Sg">Get SV2112 Video Mode   ---   pxd_SV2112_getVideoMode</H6>
<A NAME="pxd_SV2112_getCtrlVideoMode NX431"CLASS="NX"></A>
<A NAME="pxd_SV2112_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Video Mode NX432"CLASS="NX"></A>
<A NAME="Get SV2112 Controlled Video Mode   ---   pxd_SV2112_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Video Mode   ---   pxd_SV2112_getCtrlVideoMode"></A>
<H6 CLASS="Sg">Get SV2112 Controlled Video Mode   ---   pxd_SV2112_getCtrlVideoMode</H6>
<A NAME="pxd_SV2112_getCtrlTriggerMode NX433"CLASS="NX"></A>
<A NAME="pxd_SV2112_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Trigger Mode NX434"CLASS="NX"></A>
<A NAME="Get SV2112 Controlled Trigger Mode   ---   pxd_SV2112_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Trigger Mode   ---   pxd_SV2112_getCtrlTriggerMode"></A>
<H6 CLASS="Sg">Get SV2112 Controlled Trigger Mode   ---   pxd_SV2112_getCtrlTriggerMode</H6>
<A NAME="pxd_SV2112_getCtrlFrameRate NX435"CLASS="NX"></A>
<A NAME="pxd_SV2112_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Frame Rate NX436"CLASS="NX"></A>
<A NAME="Get SV2112 Controlled Frame Rate   ---   pxd_SV2112_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Frame Rate   ---   pxd_SV2112_getCtrlFrameRate"></A>
<H6 CLASS="Sg">Get SV2112 Controlled Frame Rate   ---   pxd_SV2112_getCtrlFrameRate</H6>
<A NAME="pxd_SV2112_getCtrlExposure NX437"CLASS="NX"></A>
<A NAME="pxd_SV2112_getCtrlExposure"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Exposure NX438"CLASS="NX"></A>
<A NAME="Get SV2112 Controlled Exposure   ---   pxd_SV2112_getCtrlExposure"CLASS="Sg"></A>
<A NAME="Get SV2112 Controlled Exposure   ---   pxd_SV2112_getCtrlExposure"></A>
<H6 CLASS="Sg">Get SV2112 Controlled Exposure   ---   pxd_SV2112_getCtrlExposure</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV2112_setVideoAndTriggerMode(unitmap, rsvd, videomode, controlledmode, triggermode);
int    pxd_SV2112_setCtrlExposureAndRate(unitmap, rsvd, exposure, framerate);
int    pxd_SV2112_getVideoMode(unitmap);
int    pxd_SV2112_getCtrlVideoMode(unitmap);
int    pxd_SV2112_getCtrlTriggerMode(unitmap);
double pxd_SV2112_getCtrlFrameRate(unitmap);
double pxd_SV2112_getCtrlExposure(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 videomode;          // Camera video mode: 'f': free-run, 'c': controlled
int                 controlledmode;     // Controlled mode: 'c': continuous, 's': singleshot
int                 triggermode;        // Controlled trigger: 'n': none, '+': rising, '-': falling
double              exposure;           // Controlled exposure, msec.
double              framerate;          // Controlled frame rate, Hz.
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV2112_setVideoAndTriggerMode"CLASS="Er">pxd_SV2112_setVideoAndTriggerMode</A>
sets the video and trigger modes of the
SILICON VIDEO&reg; 2112 and
SILICON VIDEO&reg; 2112C
cameras connected to PIXCI&reg; D2X imaging boards.
If
<EM CLASS="Ep">videomode</EM>='f',
the camera is free-running with exposure controlled by the camera
and set via
<A HREF="#pxd_SV2112_setExposureAndGain"CLASS="Er">pxd_SV2112_setExposureAndGain</A>;
other parameters to
<A HREF="#pxd_SV2112_setVideoAndTriggerMode"CLASS="Er">pxd_SV2112_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV2112_setCtrlExposureAndRate"CLASS="Er">pxd_SV2112_setCtrlExposureAndRate</A>
have no effect.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and the
<EM CLASS="Ep">triggermode</EM>='n'
video fields are continuously and automatically triggered.
The
<EM CLASS="Ep">framerate</EM>
specifies the field repetition rate.
The exposure is still controlled by the camera via
<A HREF="#pxd_SV2112_setExposureAndGain"CLASS="Er">pxd_SV2112_setExposureAndGain</A>.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='s'
and
<EM CLASS="Ep">triggermode</EM>='n',
video fields are triggered only upon demand;
no hardware trigger is used and video fields
are triggered by
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and
<EM CLASS="Ep">triggermode</EM>='+'
or
<EM CLASS="Ep">triggermode</EM>='-',
video fields are triggered only upon demand;
video fields are triggered by a rising or falling,
respectively, edge of the trigger signal;
the
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
must be invoked before the hardware trigger
so as to
''arm''
the imaging board.
The exposure
is set via
<A HREF="#pxd_SV2112_setCtrlExposureAndRate"CLASS="Er">pxd_SV2112_setCtrlExposureAndRate</A>.
<P>
The
<A HREF="#pxd_SV2112_getVideoMode"CLASS="Er">pxd_SV2112_getVideoMode</A>,
<A HREF="#pxd_SV2112_getCtrlVideoMode"CLASS="Er">pxd_SV2112_getCtrlVideoMode</A>,
and
<A HREF="#pxd_SV2112_getCtrlTriggerMode"CLASS="Er">pxd_SV2112_getCtrlTriggerMode</A>,
returns the camera's video mode, the controlled video mode,
and the controlled trigger mode, respectively, coded as described above.
The
<A HREF="#pxd_SV2112_getCtrlFrameRate"CLASS="Er">pxd_SV2112_getCtrlFrameRate</A>
and
<A HREF="#pxd_SV2112_getCtrlExposure"CLASS="Er">pxd_SV2112_getCtrlExposure</A>
return the controlled frame rate and controlled exposure, respectively.
<P>
The
<A HREF="#pxd_SV2112_setVideoAndTriggerMode"CLASS="Er">pxd_SV2112_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV2112_setCtrlExposureAndRate"CLASS="Er">pxd_SV2112_setCtrlExposureAndRate</A>
eliminate having to use
''raw''
values via
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
to set the controlled exposure and/or frame rate.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV2112_getVideoMode"CLASS="Er">pxd_SV2112_getVideoMode</A>,
<A HREF="#pxd_SV2112_getCtrlVideoMode"CLASS="Er">pxd_SV2112_getCtrlVideoMode</A>,
<A HREF="#pxd_SV2112_getCtrlTriggerMode"CLASS="Er">pxd_SV2112_getCtrlTriggerMode</A>,
<A HREF="#pxd_SV2112_getCtrlFrameRate"CLASS="Er">pxd_SV2112_getCtrlFrameRate</A>,
and
<A HREF="#pxd_SV2112_getCtrlExposure"CLASS="Er">pxd_SV2112_getCtrlExposure</A>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV2112_setVideoAndTriggerMode"CLASS="Er">pxd_SV2112_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV2112_setCtrlExposureAndRate"CLASS="Er">pxd_SV2112_setCtrlExposureAndRate</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV1310_setExposureGainOffset NX439"CLASS="NX"></A>
<A NAME="pxd_SV1310_setExposureGainOffset"CLASS="Sf"></A>
<A NAME="Set SV1310 Exposure, Gain, and Offset NX440"CLASS="NX"></A>
<A NAME="Set SV1310 Exposure, Gain, and Offset   ---   pxd_SV1310_setExposureGainOffset"CLASS="Sf"></A>
<A NAME="Set SV1310 Exposure, Gain, and Offset   ---   pxd_SV1310_setExposureGainOffset"></A>
<H6 CLASS="Sf">Set SV1310 Exposure, Gain, and Offset   ---   pxd_SV1310_setExposureGainOffset</H6>
<A NAME="pxd_SV1310_getExposure NX441"CLASS="NX"></A>
<A NAME="pxd_SV1310_getExposure"CLASS="Sg"></A>
<A NAME="Get SV1310 Exposure NX442"CLASS="NX"></A>
<A NAME="Get SV1310 Exposure   ---   pxd_SV1310_getExposure"CLASS="Sg"></A>
<A NAME="Get SV1310 Exposure   ---   pxd_SV1310_getExposure"></A>
<H6 CLASS="Sg">Get SV1310 Exposure   ---   pxd_SV1310_getExposure</H6>
<A NAME="pxd_SV1310_getGain NX443"CLASS="NX"></A>
<A NAME="pxd_SV1310_getGain"CLASS="Sg"></A>
<A NAME="Get SV1310 Gain NX444"CLASS="NX"></A>
<A NAME="Get SV1310 Gain   ---   pxd_SV1310_getGain"CLASS="Sg"></A>
<A NAME="Get SV1310 Gain   ---   pxd_SV1310_getGain"></A>
<H6 CLASS="Sg">Get SV1310 Gain   ---   pxd_SV1310_getGain</H6>
<A NAME="pxd_SV1310_getOffset NX445"CLASS="NX"></A>
<A NAME="pxd_SV1310_getOffset"CLASS="Sg"></A>
<A NAME="Get SV1310 Offset NX446"CLASS="NX"></A>
<A NAME="Get SV1310 Offset   ---   pxd_SV1310_getOffset"CLASS="Sg"></A>
<A NAME="Get SV1310 Offset   ---   pxd_SV1310_getOffset"></A>
<H6 CLASS="Sg">Get SV1310 Offset   ---   pxd_SV1310_getOffset</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV1310_setExposureGainOffset(unitmap, rsvd, exposure, gain, offset, rsvd2, rsvd3);
double pxd_SV1310_getExposure(unitmap);
double pxd_SV1310_getGain(unitmap);
double pxd_SV1310_getOffset(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
double              exposure;           // Exposure period, in milliseconds
double              gain;               // Gain, from 0.695 to 7.505
double              offset;             // Offset, from -372 to +372 mV
double              rsvd2;              // Reserved, should be 0
double              rsvd3;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO&reg; NX447"CLASS="NX"></A>
The
<A HREF="#pxd_SV1310_setExposureGainOffset"CLASS="Er">pxd_SV1310_setExposureGainOffset</A>
sets the exposure period, gain, and offset of
SILICON VIDEO&reg; 1310 and
SILICON VIDEO&reg; 1310C
cameras connected to PIXCI&reg; D2X1 imaging boards.
<P>
The camera's exposure period
is set to
<EM CLASS="Ep">exposure</EM>
milliseconds.
The allowable values are dependent on the camera's
current operating mode - specifically the pixel clock frequency,
AOI height, subsample, and frame period.
Any invalid value is corrected to the nearest valid value.
<P>
The camera's gain
is set to
<EM CLASS="Ep">gain</EM>,
in the range of &times;0.695 to &times;7.505.
<P>
The camera's offset
is set to
<EM CLASS="Ep">offset</EM>,
in the range of -372 to +372&nbsp;mV.
<P>
The
<A HREF="#pxd_SV1310_getExposure"CLASS="Er">pxd_SV1310_getExposure</A>,
<A HREF="#pxd_SV1310_getGain"CLASS="Er">pxd_SV1310_getGain</A>,
and
<A HREF="#pxd_SV1310_getOffset"CLASS="Er">pxd_SV1310_getOffset</A>
returns the current exposure setting,
the current gain setting, and
the current offset setting, respectively,
each in the same units as used
for
<A HREF="#pxd_SV1310_setExposureGainOffset"CLASS="Er">pxd_SV1310_setExposureGainOffset</A>.
<P>
Other, related, camera parameters which are rarely changed,
such as A-D reference voltages and individual column
digital offsets can be set by use of
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
with a video format configuration file
previously exported by the XCAP program.
<P>
Note: The
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
performs partial, quick initialization of XCLIB;
initialization for the
<CITE CLASS="Ec">pxd_SV1310_</CITE>
functions is delayed until the first such function is called.
Time sensitive applications should call
any
<CITE CLASS="Ec">pxd_SV1310_</CITE>
function once
before entering the application's time critical phase.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV1310_getExposure"CLASS="Er">pxd_SV1310_getExposure</A>,
<A HREF="#pxd_SV1310_getGain"CLASS="Er">pxd_SV1310_getGain</A>,
<A HREF="#pxd_SV1310_getOffset"CLASS="Er">pxd_SV1310_getOffset</A>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV1310_setExposureGainOffset"CLASS="Er">pxd_SV1310_setExposureGainOffset</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV1310_setColorGain NX448"CLASS="NX"></A>
<A NAME="pxd_SV1310_setColorGain"CLASS="Sf"></A>
<A NAME="Set SV1310 Color Specific Gain NX449"CLASS="NX"></A>
<A NAME="Set SV1310 Color Specific Gain   ---   pxd_SV1310_setColorGain"CLASS="Sf"></A>
<A NAME="Set SV1310 Color Specific Gain   ---   pxd_SV1310_setColorGain"></A>
<H6 CLASS="Sf">Set SV1310 Color Specific Gain   ---   pxd_SV1310_setColorGain</H6>
<A NAME="pxd_SV1310_getColorGain NX450"CLASS="NX"></A>
<A NAME="pxd_SV1310_getColorGain"CLASS="Sg"></A>
<A NAME="Get SV1310 Color Specific Gain NX451"CLASS="NX"></A>
<A NAME="Get SV1310 Color Specific Gain   ---   pxd_SV1310_getColorGain"CLASS="Sg"></A>
<A NAME="Get SV1310 Color Specific Gain   ---   pxd_SV1310_getColorGain"></A>
<H6 CLASS="Sg">Get SV1310 Color Specific Gain   ---   pxd_SV1310_getColorGain</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV1310_setColorGain(unitmap, rsvd, greenR, red, blue, greenB);
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
double              greenR;             // gain for green-red pixels
double              red;                // gain for red pixels
double              blue;               // gain for blue pixels
double              greenB;             // gain for green-blue pixels
int                 color;              // Color selection: 'G'^'R', 'R', 'B', or 'G'^'B'
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV1310_setColorGain"CLASS="Er">pxd_SV1310_setColorGain</A>
sets the individual gains of each of the 4 different
colors of the Bayer pattern,
each in the range of &times;0.695 to &times;2.7395.
The
<EM CLASS="Ep">greenR</EM>
sets the gain of the green pixels on green-red lines,
the
<EM CLASS="Ep">red</EM>
sets the gain of red pixels,
the
<EM CLASS="Ep">blue</EM>
sets the gain of blue pixels,
and the
<EM CLASS="Ep">greenB</EM>
sets the gain of the green pixels on green-blue lines.
<P>
The
<A HREF="#pxd_SV1310_setColorGain"CLASS="Er">pxd_SV1310_setColorGain</A>
can be used instead of, or in addition to,
<A HREF="#pxd_setImageBrightBalance"CLASS="Er">pxd_setImageBrightBalance</A>
for white balancing;
use of
<A HREF="#pxd_SV1310_setColorGain"CLASS="Er">pxd_SV1310_setColorGain</A>
may improve the signal to noise ratio slightly
as compared to letting
<A HREF="#pxd_setImageBrightBalance"CLASS="Er">pxd_setImageBrightBalance</A>
perform the entire correction.
<P>
The
<A HREF="#pxd_SV1310_getColorGain"CLASS="Er">pxd_SV1310_getColorGain</A>
returns one of the current color gain settings, in
the same units as set by
<A HREF="#pxd_SV1310_setColorGain"CLASS="Er">pxd_SV1310_setColorGain</A>.
If
<EM CLASS="Ep">color</EM>='G'^'R',
the green gain on green-red lines is returned,
if
<EM CLASS="Ep">color</EM>='R',
the red gain is returned.
if
<EM CLASS="Ep">color</EM>='B',
the blue gain is returned,
if
<EM CLASS="Ep">color</EM>='G'^'B',
the green gain on green-blue lines is returned,
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV1310_getColorGain"CLASS="Er">pxd_SV1310_getColorGain</A>
returns values as described above, or 0
if the library is not open for use, the
wrong imaging board is in use, or an invalid
value of
<EM CLASS="Ep">color</EM>
is used.
<P>
The
<A HREF="#pxd_SV1310_setColorGain"CLASS="Er">pxd_SV1310_setColorGain</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV1310_setResolutionAndTiming NX452"CLASS="NX"></A>
<A NAME="pxd_SV1310_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV1310 Resolution and Timing NX453"CLASS="NX"></A>
<A NAME="Set SV1310 Resolution and Timing   ---   pxd_SV1310_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV1310 Resolution and Timing   ---   pxd_SV1310_setResolutionAndTiming"></A>
<H6 CLASS="Sf">Set SV1310 Resolution and Timing   ---   pxd_SV1310_setResolutionAndTiming</H6>
<A NAME="pxd_SV1310_getSubsample NX454"CLASS="NX"></A>
<A NAME="pxd_SV1310_getSubsample"CLASS="Sg"></A>
<A NAME="Get SV1310 Subsample NX455"CLASS="NX"></A>
<A NAME="Get SV1310 Subsample   ---   pxd_SV1310_getSubsample"CLASS="Sg"></A>
<A NAME="Get SV1310 Subsample   ---   pxd_SV1310_getSubsample"></A>
<H6 CLASS="Sg">Get SV1310 Subsample   ---   pxd_SV1310_getSubsample</H6>
<A NAME="pxd_SV1310_getAoiTop NX456"CLASS="NX"></A>
<A NAME="pxd_SV1310_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV1310 Aoi Top Edge NX457"CLASS="NX"></A>
<A NAME="Get SV1310 Aoi Top Edge   ---   pxd_SV1310_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV1310 Aoi Top Edge   ---   pxd_SV1310_getAoiTop"></A>
<H6 CLASS="Sg">Get SV1310 Aoi Top Edge   ---   pxd_SV1310_getAoiTop</H6>
<A NAME="pxd_SV1310_getAoiLeft NX458"CLASS="NX"></A>
<A NAME="pxd_SV1310_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV1310 Aoi Left Edge NX459"CLASS="NX"></A>
<A NAME="Get SV1310 Aoi Left Edge   ---   pxd_SV1310_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV1310 Aoi Left Edge   ---   pxd_SV1310_getAoiLeft"></A>
<H6 CLASS="Sg">Get SV1310 Aoi Left Edge   ---   pxd_SV1310_getAoiLeft</H6>
<A NAME="pxd_SV1310_getPixelClock NX460"CLASS="NX"></A>
<A NAME="pxd_SV1310_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV1310 Pixel Clock Frequency NX461"CLASS="NX"></A>
<A NAME="Get SV1310 Pixel Clock Frequency   ---   pxd_SV1310_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV1310 Pixel Clock Frequency   ---   pxd_SV1310_getPixelClock"></A>
<H6 CLASS="Sg">Get SV1310 Pixel Clock Frequency   ---   pxd_SV1310_getPixelClock</H6>
<A NAME="pxd_SV1310_getReadoutDirection NX462"CLASS="NX"></A>
<A NAME="pxd_SV1310_getReadoutDirection"CLASS="Sg"></A>
<A NAME="Get SV1310 Readout Direction NX463"CLASS="NX"></A>
<A NAME="Get SV1310 Readout Direction   ---   pxd_SV1310_getReadoutDirection"CLASS="Sg"></A>
<A NAME="Get SV1310 Readout Direction   ---   pxd_SV1310_getReadoutDirection"></A>
<H6 CLASS="Sg">Get SV1310 Readout Direction   ---   pxd_SV1310_getReadoutDirection</H6>
<A NAME="pxd_SV1310_getFramePeriod NX464"CLASS="NX"></A>
<A NAME="pxd_SV1310_getFramePeriod"CLASS="Sg"></A>
<A NAME="Get SV1310 Frame Period NX465"CLASS="NX"></A>
<A NAME="Get SV1310 Frame Period   ---   pxd_SV1310_getFramePeriod"CLASS="Sg"></A>
<A NAME="Get SV1310 Frame Period   ---   pxd_SV1310_getFramePeriod"></A>
<H6 CLASS="Sg">Get SV1310 Frame Period   ---   pxd_SV1310_getFramePeriod</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV1310_setResolutionAndTiming(unitmap, rsvd, subsample, aoileft, aoitop, aoiwidth,
                                     aoiheight, readoutdirection, pixelClkFreq, frameperiod, rsvd2);
int    pxd_SV1310_getSubsample(unitmap);
int    pxd_SV1310_getAoiTop(unitmap);
int    pxd_SV1310_getAoiLeft(unitmap);
int    pxd_SV1310_getReadoutDirection(unitmap);
double pxd_SV1310_getPixelClock(unitmap);
double pxd_SV1310_getFramePeriod(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 subsample;          // Decimation: 0x0101 for none
                                        //             0x0202 for 2x2
                                        //             0x0404 for 4x4
                                        //             0x0808 for 8x8
                                        //             0x0H0W for WxH (W,H: 1,2,4,8)
int                 aoileft;            // Left edge of partial scan AOI
int                 aoitop;             // Top edge of partial scan AOI
int                 aoiwidth;           // Width of partial scan AOI
int                 aoiheight;          // Height of partial scan AOI
int                 readoutdirection;   // Readout direction:
                                        //   ('L'&lt;&lt;8)|'T': Left-Right/Top-Bottom
                                        //   ('R'&lt;&lt;8)|'T': Right-Left/Top-Bottom
                                        //   ('L'&lt;&lt;8)|'B': Left-Right/Bottom-Top
                                        //   ('R'&lt;&lt;8)|'B': Right-Left/Bottom-Top
double              pixelClkFreq;       // Pixel clock frequency, in MHz.
double              framePeriod;        // Frame period, in msec.
double              rsvd2;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV1310_setResolutionAndTiming"CLASS="Er">pxd_SV1310_setResolutionAndTiming</A>
sets the resolution, readout direction, pixel clock frequency,
and frame period (or frame rate) of
SILICON VIDEO&reg; 1310 and
SILICON VIDEO&reg; 1310C
cameras connected to PIXCI&reg; D2X1 imaging boards.
<P>
The
<EM CLASS="Ep">subsample</EM>
selects readout subsampling of the sensor.
If
<EM CLASS="Ep">subsample</EM>=0x0101,
subsampling is disabled.
If
<EM CLASS="Ep">subsample</EM>=0x0202,
the readout and captured image consists of every 2'nd pixel
horizontally and vertically.
If
<EM CLASS="Ep">subsample</EM>=0x0404,
the readout and captured image consists of every 4'th pixel
horizontally and vertically.
If
<EM CLASS="Ep">subsample</EM>=0x0808,
the readout and captured image consists of every 8'th pixel
horizontally and vertically.
If
<EM CLASS="Ep">subsample</EM>=W+H*256,
where W and H are each 1, 2, 4, or 8,
the readout and captured image consists of every W'th pixel
horizontally and H'th pixel vertically.
<P>
The
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
and
<EM CLASS="Ep">aoiheight</EM>
select partial scan readout of the sensor, selecting
the coordinates of the left edge and top edge of the readout AOI,
and width and height of the readout AOI.
These parameters are always relative to the sensor's full resolution,
namely 1280 by 1024, and are not to be scaled due to use of
<EM CLASS="Ep">subsample</EM>.
<P>
The
<EM CLASS="Ep">readoutdirection</EM>
selects readout scan direction.
If
<EM CLASS="Ep">scandirection</EM>=('L'&lt;&lt;8)|'T',
the readout is left to right, top to bottom.
If
<EM CLASS="Ep">scandirection</EM>=('R'&lt;&lt;8)|'T',
the readout is the default right to left, top to bottom.
If
<EM CLASS="Ep">scandirection</EM>=('L'&lt;&lt;8)|'B',
the readout is left to right, bottom to top.
If
<EM CLASS="Ep">scandirection</EM>=('R'&lt;&lt;8)|'B'
the readout is right to left, bottom to top.
<P>
The
<EM CLASS="Ep">pixelClkFreq</EM>
specifies the sensor's pixel clock frequency, in MHz.
Lower frequencies provide for longer exposures, but slower
frame rates.
Higher frequencies provide higher frame rates, but shorter
exposures and more fixed pattern noise.
Any invalid value is corrected to the nearest valid value.
<P>
The
<EM CLASS="Ep">framePeriod</EM>
specifies the sensor's frame period, or inverse of frame rate,
in millseconds.
A longer frame period allows for longer exposures.
Any invalid value is corrected to the nearest valid value.
Thus,
<EM CLASS="Ep">framePeriod</EM>=0
can be used to specify the minimum frame period (maximum frame
rate) obtainable with the specified
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
<EM CLASS="Ep">aoiheight</EM>,
and
<EM CLASS="Ep">subsample</EM>.
<P>
Use of
<A HREF="#pxd_SV1310_setResolutionAndTiming"CLASS="Er">pxd_SV1310_setResolutionAndTiming</A>
may change the captured image's resolution,
and thus affect the return values of
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>
and
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>.
Use of
<A HREF="#pxd_SV1310_setResolutionAndTiming"CLASS="Er">pxd_SV1310_setResolutionAndTiming</A>
will terminate any capture in progress,
such as that initiated by
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
or
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>.
<P>
The
<A HREF="#pxd_SV1310_getSubsample"CLASS="Er">pxd_SV1310_getSubsample</A>
returns the current subsample setting, coded as described above.
The
<A HREF="#pxd_SV1310_getAoiTop"CLASS="Er">pxd_SV1310_getAoiTop</A>
and
<A HREF="#pxd_SV1310_getAoiLeft"CLASS="Er">pxd_SV1310_getAoiLeft</A>
return the current AOI left and top edges, respectively.
The
<A HREF="#pxd_SV1310_getReadoutDirection"CLASS="Er">pxd_SV1310_getReadoutDirection</A>
returns the current readout scan direction setting, coded as described above.
The
<A HREF="#pxd_SV1310_getPixelClock"CLASS="Er">pxd_SV1310_getPixelClock</A>
returns the current pixel clock frequency, as described above.
The
<A HREF="#pxd_SV1310_getFramePeriod"CLASS="Er">pxd_SV1310_getFramePeriod</A>
returns the current frame period, or frame rate, as described above.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV1310_getSubsample"CLASS="Er">pxd_SV1310_getSubsample</A>,
<A HREF="#pxd_SV1310_getAoiTop"CLASS="Er">pxd_SV1310_getAoiTop</A>,
<A HREF="#pxd_SV1310_getAoiLeft"CLASS="Er">pxd_SV1310_getAoiLeft</A>,
<A HREF="#pxd_SV1310_getReadoutDirection"CLASS="Er">pxd_SV1310_getReadoutDirection</A>,
<A HREF="#pxd_SV1310_getPixelClock"CLASS="Er">pxd_SV1310_getPixelClock</A>
and
<A HREF="#pxd_SV1310_getFramePeriod"CLASS="Er">pxd_SV1310_getFramePeriod</A>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV1310_setResolutionAndTiming"CLASS="Er">pxd_SV1310_setResolutionAndTiming</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV1310_setVideoAndTriggerMode NX466"CLASS="NX"></A>
<A NAME="pxd_SV1310_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV1310 Video And Trigger Modes NX467"CLASS="NX"></A>
<A NAME="Set SV1310 Video And Trigger Modes   ---   pxd_SV1310_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV1310 Video And Trigger Modes   ---   pxd_SV1310_setVideoAndTriggerMode"></A>
<H6 CLASS="Sf">Set SV1310 Video And Trigger Modes   ---   pxd_SV1310_setVideoAndTriggerMode</H6>
<A NAME="pxd_SV1310_setCtrlRate NX468"CLASS="NX"></A>
<A NAME="pxd_SV1310_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV1310 Controlled Frame Rate NX469"CLASS="NX"></A>
<A NAME="Set SV1310 Controlled Frame Rate   ---   pxd_SV1310_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV1310 Controlled Frame Rate   ---   pxd_SV1310_setCtrlRate"></A>
<H6 CLASS="Sg">Set SV1310 Controlled Frame Rate   ---   pxd_SV1310_setCtrlRate</H6>
<A NAME="pxd_SV1310_getVideoMode NX470"CLASS="NX"></A>
<A NAME="pxd_SV1310_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1310 Video Mode NX471"CLASS="NX"></A>
<A NAME="Get SV1310 Video Mode   ---   pxd_SV1310_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1310 Video Mode   ---   pxd_SV1310_getVideoMode"></A>
<H6 CLASS="Sg">Get SV1310 Video Mode   ---   pxd_SV1310_getVideoMode</H6>
<A NAME="pxd_SV1310_getCtrlVideoMode NX472"CLASS="NX"></A>
<A NAME="pxd_SV1310_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Video Mode NX473"CLASS="NX"></A>
<A NAME="Get SV1310 Controlled Video Mode   ---   pxd_SV1310_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Video Mode   ---   pxd_SV1310_getCtrlVideoMode"></A>
<H6 CLASS="Sg">Get SV1310 Controlled Video Mode   ---   pxd_SV1310_getCtrlVideoMode</H6>
<A NAME="pxd_SV1310_getCtrlTriggerMode NX474"CLASS="NX"></A>
<A NAME="pxd_SV1310_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Trigger Mode NX475"CLASS="NX"></A>
<A NAME="Get SV1310 Controlled Trigger Mode   ---   pxd_SV1310_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Trigger Mode   ---   pxd_SV1310_getCtrlTriggerMode"></A>
<H6 CLASS="Sg">Get SV1310 Controlled Trigger Mode   ---   pxd_SV1310_getCtrlTriggerMode</H6>
<A NAME="pxd_SV1310_getCtrlFrameRate NX476"CLASS="NX"></A>
<A NAME="pxd_SV1310_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Frame Rate NX477"CLASS="NX"></A>
<A NAME="Get SV1310 Controlled Frame Rate   ---   pxd_SV1310_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Frame Rate   ---   pxd_SV1310_getCtrlFrameRate"></A>
<H6 CLASS="Sg">Get SV1310 Controlled Frame Rate   ---   pxd_SV1310_getCtrlFrameRate</H6>
<A NAME="pxd_SV1310_getCtrlExposure NX478"CLASS="NX"></A>
<A NAME="pxd_SV1310_getCtrlExposure"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Exposure NX479"CLASS="NX"></A>
<A NAME="Get SV1310 Controlled Exposure   ---   pxd_SV1310_getCtrlExposure"CLASS="Sg"></A>
<A NAME="Get SV1310 Controlled Exposure   ---   pxd_SV1310_getCtrlExposure"></A>
<H6 CLASS="Sg">Get SV1310 Controlled Exposure   ---   pxd_SV1310_getCtrlExposure</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV1310_setVideoAndTriggerMode(unitmap, rsvd, videomode, controlledmode, triggermode,
                                         strobemode, rsvd2, rsvd3);
int    pxd_SV1310_setCtrlFrameRate(unitmap, rsvd, rsvd4, framerate, rsvd5);
int    pxd_SV1310_getVideoMode(unitmap);
int    pxd_SV1310_getCtrlVideoMode(unitmap);
int    pxd_SV1310_getCtrlTriggerMode(unitmap);
double pxd_SV1310_getCtrlFrameRate(unitmap);
int    pxd_SV1310_getStrobeMode(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 videomode;          // Camera video mode: 'f': free-run, 'c': controlled
int                 controlledmode;     // Controlled mode: 'c': continuous, 's': singleshot
int                 triggermode;        // Controlled trigger: '+': rising, '-': falling,
                                        //                     'n': none, 'b': snap function
int                 strobemode;         // strobe mode: 0: none, '1': 1 line, 'e': exposure
double              framerate;          // Controlled frame rate, Hz.
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
double              rsvd4;              // Reserved, should be 0
double              rsvd5;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV1310_setVideoAndTriggerMode"CLASS="Er">pxd_SV1310_setVideoAndTriggerMode</A>
sets the video and trigger modes of the
SILICON VIDEO&reg; 1310 and
SILICON VIDEO&reg; 1310C
cameras connected to PIXCI&reg; D2X1 imaging boards.
If
<EM CLASS="Ep">videomode</EM>='f',
the camera is free-running with frame period
(frame rate) controlled by the camera
and set via
<A HREF="#pxd_SV1310_setResolutionAndTiming"CLASS="Er">pxd_SV1310_setResolutionAndTiming</A>;
other parameters to
<A HREF="#pxd_SV1310_setVideoAndTriggerMode"CLASS="Er">pxd_SV1310_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV1310_setCtrlRate"CLASS="Er">pxd_SV1310_setCtrlRate</A>
have no effect.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and the
<EM CLASS="Ep">triggermode</EM>='n'
video fields are continuously and automatically triggered.
The
<EM CLASS="Ep">framerate</EM>
specifies the field repetition rate.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='s'
and
<EM CLASS="Ep">triggermode</EM>='b',
video fields are triggered only upon demand;
no hardware trigger is used and video fields
are triggered by
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and
<EM CLASS="Ep">triggermode</EM>='+'
or
<EM CLASS="Ep">triggermode</EM>='-',
video fields are triggered only upon demand;
video fields are triggered by a rising or falling,
respectively, edge of the trigger signal;
the
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
must be invoked before the hardware trigger
so as to
''arm''
the imaging board.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
the
<EM CLASS="Ep">strobemode</EM>
selects the type of strobe output.
If
<EM CLASS="Ep">strobemode</EM>=0,
the strobe output is disabled.
If
<EM CLASS="Ep">strobemode</EM>='1',
the strobe output is active for one line.
If
<EM CLASS="Ep">strobemode</EM>='e',
the strobe output is active for the entire exposure,
however use of this options limits the allowable
exposure values.
<P>
The
<A HREF="#pxd_SV1310_getVideoMode"CLASS="Er">pxd_SV1310_getVideoMode</A>,
<A HREF="#pxd_SV1310_getCtrlVideoMode"CLASS="Er">pxd_SV1310_getCtrlVideoMode</A>,
<A HREF="#pxd_SV1310_getCtrlTriggerMode"CLASS="Er">pxd_SV1310_getCtrlTriggerMode</A>,
and
<A HREF="#pxd_SV1310_getStrobeMode"CLASS="Er">pxd_SV1310_getStrobeMode</A>,
returns the camera's video mode, the controlled video mode,
the controlled trigger mode, and the strobe mode,
respectively, coded as described above.
The
<A HREF="#pxd_SV1310_getCtrlFrameRate"CLASS="Er">pxd_SV1310_getCtrlFrameRate</A>
returns the controlled frame rate.
<P>
The
<A HREF="#pxd_SV1310_setVideoAndTriggerMode"CLASS="Er">pxd_SV1310_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV1310_setCtrlRate"CLASS="Er">pxd_SV1310_setCtrlRate</A>
eliminate having to use
''raw''
values via
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
to set the controlled exposure and/or frame rate.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV1310_getVideoMode"CLASS="Er">pxd_SV1310_getVideoMode</A>,
<A HREF="#pxd_SV1310_getCtrlVideoMode"CLASS="Er">pxd_SV1310_getCtrlVideoMode</A>,
<A HREF="#pxd_SV1310_getCtrlTriggerMode"CLASS="Er">pxd_SV1310_getCtrlTriggerMode</A>,
<A HREF="#pxd_SV1310_getCtrlFrameRate"CLASS="Er">pxd_SV1310_getCtrlFrameRate</A>,
<A HREF="#pxd_SV1310_getCtrlExposure"CLASS="Er">pxd_SV1310_getCtrlExposure</A>,
and
<A HREF="#pxd_SV1310_getStrobeMode"CLASS="Er">pxd_SV1310_getStrobeMode</A>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV1310_setVideoAndTriggerMode"CLASS="Er">pxd_SV1310_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV1310_setCtrlRate"CLASS="Er">pxd_SV1310_setCtrlRate</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV1281_setExposureGainOffset NX480"CLASS="NX"></A>
<A NAME="pxd_SV1281_setExposureGainOffset"CLASS="Sf"></A>
<A NAME="Set SV1281 Exposure, Gain, and Offset NX481"CLASS="NX"></A>
<A NAME="Set SV1281 Exposure, Gain, and Offset   ---   pxd_SV1281_setExposureGainOffset"CLASS="Sf"></A>
<A NAME="Set SV1281 Exposure, Gain, and Offset   ---   pxd_SV1281_setExposureGainOffset"></A>
<H6 CLASS="Sf">Set SV1281 Exposure, Gain, and Offset   ---   pxd_SV1281_setExposureGainOffset</H6>
<A NAME="pxd_SV1281_getExposure NX482"CLASS="NX"></A>
<A NAME="pxd_SV1281_getExposure"CLASS="Sg"></A>
<A NAME="Get SV1281 Exposure NX483"CLASS="NX"></A>
<A NAME="Get SV1281 Exposure   ---   pxd_SV1281_getExposure"CLASS="Sg"></A>
<A NAME="Get SV1281 Exposure   ---   pxd_SV1281_getExposure"></A>
<H6 CLASS="Sg">Get SV1281 Exposure   ---   pxd_SV1281_getExposure</H6>
<A NAME="pxd_SV1281_getGain NX484"CLASS="NX"></A>
<A NAME="pxd_SV1281_getGain"CLASS="Sg"></A>
<A NAME="Get SV1281 Gain NX485"CLASS="NX"></A>
<A NAME="Get SV1281 Gain   ---   pxd_SV1281_getGain"CLASS="Sg"></A>
<A NAME="Get SV1281 Gain   ---   pxd_SV1281_getGain"></A>
<H6 CLASS="Sg">Get SV1281 Gain   ---   pxd_SV1281_getGain</H6>
<A NAME="pxd_SV1281_getOffset NX486"CLASS="NX"></A>
<A NAME="pxd_SV1281_getOffset"CLASS="Sg"></A>
<A NAME="Get SV1281 Offset NX487"CLASS="NX"></A>
<A NAME="Get SV1281 Offset   ---   pxd_SV1281_getOffset"CLASS="Sg"></A>
<A NAME="Get SV1281 Offset   ---   pxd_SV1281_getOffset"></A>
<H6 CLASS="Sg">Get SV1281 Offset   ---   pxd_SV1281_getOffset</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV1281_setExposureGainOffset(unitmap, rsvd, exposure, gain, offset, rsvd2, rsvd3);
double pxd_SV1281_getExposure(unitmap);
double pxd_SV1281_getGain(unitmap);
double pxd_SV1281_getOffset(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
double              exposure;           // Exposure period, in milliseconds
double              gain;               // Gain, from log(1.5) to log(39.375)
double              offset;             // Offset, from 0 to 62
double              rsvd2;              // Reserved, should be 0
double              rsvd3;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO&reg; NX488"CLASS="NX"></A>
The
<A HREF="#pxd_SV1281_setExposureGainOffset"CLASS="Er">pxd_SV1281_setExposureGainOffset</A>
sets the exposure period, gain, and offset of
SILICON VIDEO&reg; 1281M and
SILICON VIDEO&reg; 1281C
cameras connected to PIXCI&reg; D2X1 imaging boards.
<P>
The camera's exposure period
is set to
<EM CLASS="Ep">exposure</EM>
milliseconds.
The allowable values are dependent on the camera's
current operating mode - specifically the pixel clock frequency,
AOI height, subsample, and frame period.
Any invalid value is corrected to the nearest valid value.
<P>
The camera's gain
is set to
<EM CLASS="Ep">gain</EM>,
in the range of log(1.5) to log(39.375).
<P>
The camera's offset,
or black level,
is set to
<EM CLASS="Ep">offset</EM>,
in the range of 0 to 62.
<P>
The
<A HREF="#pxd_SV1281_getExposure"CLASS="Er">pxd_SV1281_getExposure</A>,
<A HREF="#pxd_SV1281_getGain"CLASS="Er">pxd_SV1281_getGain</A>,
and
<A HREF="#pxd_SV1281_getOffset"CLASS="Er">pxd_SV1281_getOffset</A>
returns the current exposure setting,
the current gain setting, and
the current offset setting, respectively,
each in the same units as used
for
<A HREF="#pxd_SV1281_setExposureGainOffset"CLASS="Er">pxd_SV1281_setExposureGainOffset</A>.
<P>
Note: The
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
performs partial, quick initialization of XCLIB;
initialization for the
<CITE CLASS="Ec">pxd_SV1281_</CITE>
functions is delayed until the first such function is called.
Time sensitive applications should call
any
<CITE CLASS="Ec">pxd_SV1281_</CITE>
function once
before entering the application's time critical phase.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV1281_getExposure"CLASS="Er">pxd_SV1281_getExposure</A>,
<A HREF="#pxd_SV1281_getGain"CLASS="Er">pxd_SV1281_getGain</A>,
<A HREF="#pxd_SV1281_getOffset"CLASS="Er">pxd_SV1281_getOffset</A>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV1281_setExposureGainOffset"CLASS="Er">pxd_SV1281_setExposureGainOffset</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV1281_setResolutionAndTiming NX489"CLASS="NX"></A>
<A NAME="pxd_SV1281_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV1281 Resolution and Timing NX490"CLASS="NX"></A>
<A NAME="Set SV1281 Resolution and Timing   ---   pxd_SV1281_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV1281 Resolution and Timing   ---   pxd_SV1281_setResolutionAndTiming"></A>
<H6 CLASS="Sf">Set SV1281 Resolution and Timing   ---   pxd_SV1281_setResolutionAndTiming</H6>
<A NAME="pxd_SV1281_getAoiTop NX491"CLASS="NX"></A>
<A NAME="pxd_SV1281_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV1281 Aoi Top Edge NX492"CLASS="NX"></A>
<A NAME="Get SV1281 Aoi Top Edge   ---   pxd_SV1281_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV1281 Aoi Top Edge   ---   pxd_SV1281_getAoiTop"></A>
<H6 CLASS="Sg">Get SV1281 Aoi Top Edge   ---   pxd_SV1281_getAoiTop</H6>
<A NAME="pxd_SV1281_getAoiLeft NX493"CLASS="NX"></A>
<A NAME="pxd_SV1281_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV1281 Aoi Left Edge NX494"CLASS="NX"></A>
<A NAME="Get SV1281 Aoi Left Edge   ---   pxd_SV1281_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV1281 Aoi Left Edge   ---   pxd_SV1281_getAoiLeft"></A>
<H6 CLASS="Sg">Get SV1281 Aoi Left Edge   ---   pxd_SV1281_getAoiLeft</H6>
<A NAME="pxd_SV1281_getPixelClock NX495"CLASS="NX"></A>
<A NAME="pxd_SV1281_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV1281 Pixel Clock Frequency NX496"CLASS="NX"></A>
<A NAME="Get SV1281 Pixel Clock Frequency   ---   pxd_SV1281_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV1281 Pixel Clock Frequency   ---   pxd_SV1281_getPixelClock"></A>
<H6 CLASS="Sg">Get SV1281 Pixel Clock Frequency   ---   pxd_SV1281_getPixelClock</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV1281_setResolutionAndTiming(unitmap, rsvd, rsvd1, aoileft, aoitop, aoiwidth,
                                     aoiheight, rsvd4, pixelClkFreq, rsvd2, rsvd3);
int    pxd_SV1281_getAoiTop(unitmap);
int    pxd_SV1281_getAoiLeft(unitmap);
double pxd_SV1281_getPixelClock(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 rsvd1;              // Reserved, should be 0
int                 rsvd4;              // Reserved, should be 0
int                 aoileft;            // Left edge of partial scan AOI
int                 aoitop;             // Top edge of partial scan AOI
int                 aoiwidth;           // Width of partial scan AOI
int                 aoiheight;          // Height of partial scan AOI
double              pixelClkFreq;       // Pixel clock frequency, in MHz.
double              rsvd2;              // Reserved, should be 0
double              rsvd3;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV1281_setResolutionAndTiming"CLASS="Er">pxd_SV1281_setResolutionAndTiming</A>
sets the resolution and pixel clock frequency
of
SILICON VIDEO&reg; 1281M and
SILICON VIDEO&reg; 1281C
cameras connected to PIXCI&reg; D2X1 imaging boards.
<P>
The
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
and
<EM CLASS="Ep">aoiheight</EM>
select partial scan readout of the sensor, selecting
the coordinates of the left edge and top edge of the readout AOI,
and width and height of the readout AOI.
<P>
The
<EM CLASS="Ep">pixelClkFreq</EM>
specifies the sensor's pixel clock frequency, in MHz.
Lower frequencies provide for longer exposures, but slower
frame rates.
Higher frequencies provide higher frame rates, but shorter
exposures and more fixed pattern noise.
Any invalid value is corrected to the nearest valid value.
<P>
Use of
<A HREF="#pxd_SV1281_setResolutionAndTiming"CLASS="Er">pxd_SV1281_setResolutionAndTiming</A>
may change the captured image's resolution,
and thus affect the return values of
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>
and
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>.
Use of
<A HREF="#pxd_SV1281_setResolutionAndTiming"CLASS="Er">pxd_SV1281_setResolutionAndTiming</A>
will terminate any capture in progress,
such as that initiated by
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
or
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>.
<P>
The
<A HREF="#pxd_SV1281_getAoiTop"CLASS="Er">pxd_SV1281_getAoiTop</A>
and
<A HREF="#pxd_SV1281_getAoiLeft"CLASS="Er">pxd_SV1281_getAoiLeft</A>
return the current AOI left and top edges, respectively.
The
<A HREF="#pxd_SV1281_getPixelClock"CLASS="Er">pxd_SV1281_getPixelClock</A>
returns the current pixel clock frequency, as described above.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV1281_getAoiTop"CLASS="Er">pxd_SV1281_getAoiTop</A>,
<A HREF="#pxd_SV1281_getAoiLeft"CLASS="Er">pxd_SV1281_getAoiLeft</A>,
and
<A HREF="#pxd_SV1281_getPixelClock"CLASS="Er">pxd_SV1281_getPixelClock</A>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV1281_setResolutionAndTiming"CLASS="Er">pxd_SV1281_setResolutionAndTiming</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV1281_setVideoAndTriggerMode NX497"CLASS="NX"></A>
<A NAME="pxd_SV1281_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV1281 Video And Trigger Modes NX498"CLASS="NX"></A>
<A NAME="Set SV1281 Video And Trigger Modes   ---   pxd_SV1281_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV1281 Video And Trigger Modes   ---   pxd_SV1281_setVideoAndTriggerMode"></A>
<H6 CLASS="Sf">Set SV1281 Video And Trigger Modes   ---   pxd_SV1281_setVideoAndTriggerMode</H6>
<A NAME="pxd_SV1281_setCtrlRate NX499"CLASS="NX"></A>
<A NAME="pxd_SV1281_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV1281 Controlled Frame Rate NX500"CLASS="NX"></A>
<A NAME="Set SV1281 Controlled Frame Rate   ---   pxd_SV1281_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV1281 Controlled Frame Rate   ---   pxd_SV1281_setCtrlRate"></A>
<H6 CLASS="Sg">Set SV1281 Controlled Frame Rate   ---   pxd_SV1281_setCtrlRate</H6>
<A NAME="pxd_SV1281_getVideoMode NX501"CLASS="NX"></A>
<A NAME="pxd_SV1281_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1281 Video Mode NX502"CLASS="NX"></A>
<A NAME="Get SV1281 Video Mode   ---   pxd_SV1281_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1281 Video Mode   ---   pxd_SV1281_getVideoMode"></A>
<H6 CLASS="Sg">Get SV1281 Video Mode   ---   pxd_SV1281_getVideoMode</H6>
<A NAME="pxd_SV1281_getCtrlVideoMode NX503"CLASS="NX"></A>
<A NAME="pxd_SV1281_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1281 Controlled Video Mode NX504"CLASS="NX"></A>
<A NAME="Get SV1281 Controlled Video Mode   ---   pxd_SV1281_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV1281 Controlled Video Mode   ---   pxd_SV1281_getCtrlVideoMode"></A>
<H6 CLASS="Sg">Get SV1281 Controlled Video Mode   ---   pxd_SV1281_getCtrlVideoMode</H6>
<A NAME="pxd_SV1281_getCtrlTriggerMode NX505"CLASS="NX"></A>
<A NAME="pxd_SV1281_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV1281 Controlled Trigger Mode NX506"CLASS="NX"></A>
<A NAME="Get SV1281 Controlled Trigger Mode   ---   pxd_SV1281_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV1281 Controlled Trigger Mode   ---   pxd_SV1281_getCtrlTriggerMode"></A>
<H6 CLASS="Sg">Get SV1281 Controlled Trigger Mode   ---   pxd_SV1281_getCtrlTriggerMode</H6>
<A NAME="pxd_SV1281_getCtrlFrameRate NX507"CLASS="NX"></A>
<A NAME="pxd_SV1281_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV1281 Controlled Frame Rate NX508"CLASS="NX"></A>
<A NAME="Get SV1281 Controlled Frame Rate   ---   pxd_SV1281_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV1281 Controlled Frame Rate   ---   pxd_SV1281_getCtrlFrameRate"></A>
<H6 CLASS="Sg">Get SV1281 Controlled Frame Rate   ---   pxd_SV1281_getCtrlFrameRate</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV1281_setVideoAndTriggerMode(unitmap, rsvd, videomode, controlledmode, triggermode,
                                         rsvd1, rsvd2, rsvd3);
int    pxd_SV1281_setCtrlRate(unitmap, rsvd, rsvd4, framerate, rsvd5);
int    pxd_SV1281_getVideoMode(unitmap);
int    pxd_SV1281_getCtrlVideoMode(unitmap);
int    pxd_SV1281_getCtrlTriggerMode(unitmap);
double pxd_SV1281_getCtrlFrameRate(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 videomode;          // Camera video mode: 'f': free-run, 'c': controlled
int                 controlledmode;     // Controlled mode: 'c': continuous, 's': singleshot
int                 triggermode;        // Controlled trigger: '+': rising, '-': falling,
                                        //                     'n': none, 'b': snap function
double              framerate;          // Controlled frame rate, Hz.
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
double              rsvd4;              // Reserved, should be 0
double              rsvd5;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV1281_setVideoAndTriggerMode"CLASS="Er">pxd_SV1281_setVideoAndTriggerMode</A>
sets the video and trigger modes of the
SILICON VIDEO&reg; 1281M and
SILICON VIDEO&reg; 1281C
cameras connected to PIXCI&reg; D2X1 imaging boards.
If
<EM CLASS="Ep">videomode</EM>='f',
the camera is free-running with frame period
(frame rate) controlled by the camera
and set via
<A HREF="#pxd_SV1281_setResolutionAndTiming"CLASS="Er">pxd_SV1281_setResolutionAndTiming</A>;
other parameters to
<A HREF="#pxd_SV1281_setVideoAndTriggerMode"CLASS="Er">pxd_SV1281_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV1281_setCtrlRate"CLASS="Er">pxd_SV1281_setCtrlRate</A>
have no effect.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and the
<EM CLASS="Ep">triggermode</EM>='n'
video fields are continuously and automatically triggered.
The
<EM CLASS="Ep">framerate</EM>
specifies the field repetition rate.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='s'
and
<EM CLASS="Ep">triggermode</EM>='b',
video fields are triggered only upon demand;
no hardware trigger is used and video fields
are triggered by
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and
<EM CLASS="Ep">triggermode</EM>='+'
or
<EM CLASS="Ep">triggermode</EM>='-',
video fields are triggered only upon demand;
video fields are triggered by a rising or falling,
respectively, edge of the trigger signal;
the
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
must be invoked before the hardware trigger
so as to
''arm''
the imaging board.
<P>
The
<A HREF="#pxd_SV1281_getVideoMode"CLASS="Er">pxd_SV1281_getVideoMode</A>,
<A HREF="#pxd_SV1281_getCtrlVideoMode"CLASS="Er">pxd_SV1281_getCtrlVideoMode</A>,
and
<A HREF="#pxd_SV1281_getCtrlTriggerMode"CLASS="Er">pxd_SV1281_getCtrlTriggerMode</A>,
returns the camera's video mode, the controlled video mode,
and the controlled trigger mode,
respectively, coded as described above.
The
<A HREF="#pxd_SV1281_getCtrlFrameRate"CLASS="Er">pxd_SV1281_getCtrlFrameRate</A>
returns the controlled frame rate.
<P>
The
<A HREF="#pxd_SV1281_setVideoAndTriggerMode"CLASS="Er">pxd_SV1281_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV1281_setCtrlRate"CLASS="Er">pxd_SV1281_setCtrlRate</A>
eliminate having to use
''raw''
values via
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
to set the controlled exposure and/or frame rate.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV1281_getVideoMode"CLASS="Er">pxd_SV1281_getVideoMode</A>,
<A HREF="#pxd_SV1281_getCtrlVideoMode"CLASS="Er">pxd_SV1281_getCtrlVideoMode</A>,
<A HREF="#pxd_SV1281_getCtrlTriggerMode"CLASS="Er">pxd_SV1281_getCtrlTriggerMode</A>,
and
<A HREF="#pxd_SV1281_getCtrlFrameRate"CLASS="Er">pxd_SV1281_getCtrlFrameRate</A>
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV1281_setVideoAndTriggerMode"CLASS="Er">pxd_SV1281_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV1281_setCtrlRate"CLASS="Er">pxd_SV1281_setCtrlRate</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV9M001_setExposureAndGain NX509"CLASS="NX"></A>
<A NAME="pxd_SV9M001_setExposureAndGain"CLASS="Sf"></A>
<A NAME="Set SV9M001/SV9T001 Exposure and Gain NX510"CLASS="NX"></A>
<A NAME="Set SV9M001/SV9T001 Exposure and Gain   ---   pxd_SV9M001_setExposureAndGain"CLASS="Sf"></A>
<A NAME="Set SV9M001/SV9T001 Exposure and Gain   ---   pxd_SV9M001_setExposureAndGain"></A>
<H6 CLASS="Sf">Set SV9M001/SV9T001 Exposure and Gain   ---   pxd_SV9M001_setExposureAndGain</H6>
<HR SIZE="1">
<A NAME="pxd_SV9M001_setExposureAndDigitalGain NX511"CLASS="NX"></A>
<A NAME="pxd_SV9M001_setExposureAndDigitalGain"CLASS="Sf"></A>
<A NAME="Set SV9T001 Exposure and Digital Gain NX512"CLASS="NX"></A>
<A NAME="Set SV9T001 Exposure and Digital Gain   ---   pxd_SV9M001_setExposureAndDigitalGain"CLASS="Sf"></A>
<A NAME="Set SV9T001 Exposure and Digital Gain   ---   pxd_SV9M001_setExposureAndDigitalGain"></A>
<H6 CLASS="Sf">Set SV9T001 Exposure and Digital Gain   ---   pxd_SV9M001_setExposureAndDigitalGain</H6>
<A NAME="pxd_SV9M001_getExposure NX513"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getExposure"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Exposure NX514"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Exposure   ---   pxd_SV9M001_getExposure"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Exposure   ---   pxd_SV9M001_getExposure"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Exposure   ---   pxd_SV9M001_getExposure</H6>
<A NAME="pxd_SV9M001_getGain NX515"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getGain"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Gain NX516"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Gain   ---   pxd_SV9M001_getGain"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Gain   ---   pxd_SV9M001_getGain"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Gain   ---   pxd_SV9M001_getGain</H6>
<A NAME="pxd_SV9M001_getDigitalGain NX517"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getDigitalGain"CLASS="Sg"></A>
<A NAME="Get SV9T001 Digital Gain NX518"CLASS="NX"></A>
<A NAME="Get SV9T001 Digital Gain   ---   pxd_SV9M001_getDigitalGain"CLASS="Sg"></A>
<A NAME="Get SV9T001 Digital Gain   ---   pxd_SV9M001_getDigitalGain"></A>
<H6 CLASS="Sg">Get SV9T001 Digital Gain   ---   pxd_SV9M001_getDigitalGain</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV9M001_setExposureAndGain(unitmap, rsvd, exposure, redgain, grnrgain, bluegain, grnbgain);
int    pxd_SV9M001_setExposureAndDigitalGain(unitmap, rsvd, exposure, digitalgain, rsvd2, rsvd3, rsvd4);
double pxd_SV9M001_getExposure(unitmap);
double pxd_SV9M001_getGain(unitmap, color);
double pxd_SV9M001_getDigitalGain(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
double              exposure;           // Exposure period, in milliseconds
double              redgain;            // Gain of red pixels, in dB.
double              grnrgain;           // Gain of green-next-to-red pixels, in dB.
double              blugain;            // Gain of blue pixels, in dB.
double              grnbgain;           // Gain of green-next-to-blue pixels, in dB.
double              digitalgain;        // Digital gain, in dB, SV9T001 only
int                 color;              // Color selection: 'R', 'G'^'r', 'B', or 'G'^'B'
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO&reg; NX519"CLASS="NX"></A>
The
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>
sets the exposure period and gain of
SILICON VIDEO&reg; 9M001,
SILICON VIDEO&reg; 9M001C, and
SILICON VIDEO&reg; 9T001C
cameras connected to PIXCI&reg; SI imaging boards.
<P>
The camera's exposure period
is set to
<EM CLASS="Ep">exposure</EM>
milliseconds.
The allowable values are dependent on the camera's
current operating mode - specifically the pixel clock frequency,
AOI height, and decimation.
Any invalid value is corrected to the nearest valid value.
<P>
The camera's gain of red, green-next-to-red, blue,
and green-next-to-blue
pixels is set to
<EM CLASS="Ep">redgain</EM>,
<EM CLASS="Ep">grnrgain</EM>,
<EM CLASS="Ep">blugain</EM>,
and
<EM CLASS="Ep">grnggain</EM>,
respectively,
each in the range of 0.0 to 20*log<SUB><SMALL>10</SMALL></SUB>(15) dB
(for
SILICON VIDEO&reg; 9M001 and
SILICON VIDEO&reg; 9M001C)
or to
20*log<SUB><SMALL>10</SMALL></SUB>(4) dB
(for
SILICON VIDEO&reg; 9T001C).
Different gains per
''color''
can be set for the SILICON VIDEO&reg; 9M001
(i.e. monochrome) camera; the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, for monochrome cameras the gains are identical.
<P>
The
<A HREF="#pxd_SV9M001_setExposureAndDigitalGain"CLASS="Er">pxd_SV9M001_setExposureAndDigitalGain</A>
sets the exposure period and digital gain of
SILICON VIDEO&reg; 9T001C
cameras connected to PIXCI&reg; SI imaging boards.
The camera's exposure period is set to
<EM CLASS="Ep">exposure</EM>
millseconds, duplicating the effect of the
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>
function.
The camera's digital gain is set to
<EM CLASS="Ep">digitalgain</EM>,
in the range of 0.0 to (20*log<SUB><SMALL>10</SMALL></SUB>(1+127.0/8)) dB.
The
SILICON VIDEO&reg; 9M001 and
SILICON VIDEO&reg; 9M001C
cameras do not provide a distinct digital gain control.
<P>
The
<A HREF="#pxd_SV9M001_getExposure"CLASS="Er">pxd_SV9M001_getExposure</A>
returns the current exposure setting,
in milliseconds.
<P>
The
<A HREF="#pxd_SV9M001_getGain"CLASS="Er">pxd_SV9M001_getGain</A>
returns one of the current gain settings, in dB.
If
<EM CLASS="Ep">color</EM>='R',
the red gain is returned,
if
<EM CLASS="Ep">color</EM>='G'^'R',
the green-next-to-red gain is returned,
if
<EM CLASS="Ep">color</EM>='B',
the blue gain is returned,
if
<EM CLASS="Ep">color</EM>='G'^'B',
the green-next-to-blue gain is returned.
<P>
The
<A HREF="#pxd_SV9M001_getDigitalGain"CLASS="Er">pxd_SV9M001_getDigitalGain</A>
returns the current digital gain settings, in dB.
<P>
Note: The
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
performs partial, quick initialization of XCLIB;
initialization for the
<CITE CLASS="Ec">pxd_SV9M001_</CITE>
functions is delayed until the first such function is called.
Time sensitive applications should call
any
<CITE CLASS="Ec">pxd_SV9M001_</CITE>
function once
before entering the application's time critical phase.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV9M001_getExposure"CLASS="Er">pxd_SV9M001_getExposure</A>,
<A HREF="#pxd_SV9M001_getGain"CLASS="Er">pxd_SV9M001_getGain</A>,
and
<A HREF="#pxd_SV9M001_getDigitalGain"CLASS="Er">pxd_SV9M001_getDigitalGain</A>
returns values as described above, or 0
if the library is not open for use, the
wrong imaging board is in use, or an invalid
value of
<EM CLASS="Ep">color</EM>
is used.
<P>
The
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>
and
<A HREF="#pxd_SV9M001_setExposureAndDigitalGain"CLASS="Er">pxd_SV9M001_setExposureAndDigitalGain</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV9M001_setResolutionAndTiming NX520"CLASS="NX"></A>
<A NAME="pxd_SV9M001_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV9M001/SV9T001 Resolution and Timing NX521"CLASS="NX"></A>
<A NAME="Set SV9M001/SV9T001 Resolution and Timing   ---   pxd_SV9M001_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV9M001/SV9T001 Resolution and Timing   ---   pxd_SV9M001_setResolutionAndTiming"></A>
<H6 CLASS="Sf">Set SV9M001/SV9T001 Resolution and Timing   ---   pxd_SV9M001_setResolutionAndTiming</H6>
<A NAME="pxd_SV9M001_getAoiTop NX522"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Aoi Top Edge NX523"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Aoi Top Edge   ---   pxd_SV9M001_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Aoi Top Edge   ---   pxd_SV9M001_getAoiTop"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Aoi Top Edge   ---   pxd_SV9M001_getAoiTop</H6>
<A NAME="pxd_SV9M001_getAoiLeft NX524"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Aoi Left Edge NX525"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Aoi Left Edge   ---   pxd_SV9M001_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Aoi Left Edge   ---   pxd_SV9M001_getAoiLeft"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Aoi Left Edge   ---   pxd_SV9M001_getAoiLeft</H6>
<A NAME="pxd_SV9M001_getScanDirection NX526"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getScanDirection"CLASS="Sg"></A>
<A NAME="Get SV9M001 Scan Direction NX527"CLASS="NX"></A>
<A NAME="Get SV9M001 Scan Direction   ---   pxd_SV9M001_getScanDirection"CLASS="Sg"></A>
<A NAME="Get SV9M001 Scan Direction   ---   pxd_SV9M001_getScanDirection"></A>
<H6 CLASS="Sg">Get SV9M001 Scan Direction   ---   pxd_SV9M001_getScanDirection</H6>
<A NAME="pxd_SV9M001_getSubsample NX528"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getSubsample"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Subsample NX529"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Subsample   ---   pxd_SV9M001_getSubsample"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Subsample   ---   pxd_SV9M001_getSubsample"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Subsample   ---   pxd_SV9M001_getSubsample</H6>
<A NAME="pxd_SV9M001_getPixelClock NX530"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Pixel Clock Frequency NX531"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Pixel Clock Frequency   ---   pxd_SV9M001_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Pixel Clock Frequency   ---   pxd_SV9M001_getPixelClock"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Pixel Clock Frequency   ---   pxd_SV9M001_getPixelClock</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV9M001_setResolutionAndTiming(unitmap, rsvd, subsample, aoileft, aoitop, aoiwidth,
                                     aoiheight, scandirection, pixelClkFreq, framePeriod, rsvd2);
int    pxd_SV9M001_getAoiTop(unitmap);
int    pxd_SV9M001_getAoiLeft(unitmap);
int    pxd_SV9M001_getScanDirection(unitmap);
int    pxd_SV9M001_getSubsample(unitmap);
double pxd_SV9M001_getPixelClock(unitmap);
double pxd_SV9M001_getFramePeriod(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 subsample;          // Subsample:
                                        //    0x101 for none    0x204 for 2x4
                                        //    0x202 for 2x2     0x208 for 2x8
                                        //    0x404 for 4x4     0x401 for 4x1
                                        //    0x808 for 8x8     0x402 for 4x2
                                        //    0x102 for 1x2     0x408 for 4x8
                                        //    0x104 for 1x4     0x801 for 8x1
                                        //    0x108 for 1x8     0x802 for 8x2
                                        //    0x201 for 2x1     0x804 for 8x4
int                 aoileft;            // Left edge of partial scan AOI
int                 aoitop;             // Top edge of partial scan AOI
int                 aoiwidth;           // Width of partial scan AOI
int                 aoiheight;          // Height of partial scan AOI
int                 scandirection;      // Scan direction:
                                        //   ('L'&lt;&lt;8)|'T': Left-Right/Top-Bottom
                                        //   ('L'&lt;&lt;8)|'B': Left-Right/Bottom-Top
                                        //   (SV9M001, SV9M001C only)
double              pixelClkFreq;       // Pixel clock frequency, in MHz.
double              framePeriod;        // Frame period, in msec.
double              rsvd2;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV9M001_setResolutionAndTiming"CLASS="Er">pxd_SV9M001_setResolutionAndTiming</A>
sets the resolution, scan direction, and pixel clock frequency of
SILICON VIDEO&reg; 9M001,
SILICON VIDEO&reg; 9M001C, and
SILICON VIDEO&reg; 9T001C
cameras connected to PIXCI&reg; SI imaging boards.
<P>
The
<EM CLASS="Ep">subsample</EM>
selects readout subsampling of the sensor.
If
<EM CLASS="Ep">subsample</EM>=0x0101,
subsampling is disabled.
If
<EM CLASS="Ep">subsample</EM>=0x0202,
the readout and captured image consists of every 2'nd pixel,
both horizontally and vertically.
If
<EM CLASS="Ep">subsample</EM>=0x0404,
the readout and captured image consists of every 4'th pixel,
both horizontally and vertically.
If
<EM CLASS="Ep">subsample</EM>=W+H*256,
where W and H are 1, 2, 4, or 8,
the readout and captured image consists of every W'th pixel
horizontally and H'th pixel vertically.
<P>
The
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
and
<EM CLASS="Ep">aoiheight</EM>
select partial scan readout of the sensor, selecting
the coordinates of the left edge and top edge of the readout AOI,
and width and height of the readout AOI.
These parameters are always relative to the sensor's full resolution,
namely 1280 by 1024
(for
SILICON VIDEO&reg; 9M001 and
SILICON VIDEO&reg; 9M001C)
or 2048 by 1536
(for
SILICON VIDEO&reg; 9T001C),
and are not to be scaled due to use of
<EM CLASS="Ep">subsample</EM>.
<P>
The
<EM CLASS="Ep">scandirection</EM>
selects readout scan direction.
If
<EM CLASS="Ep">scandirection</EM>=('L'&lt;&lt;8)|'T',
the readout is left to right, top to bottom.
If
<EM CLASS="Ep">scandirection</EM>=('L'&lt;&lt;8)|'B',
the readout is left to right, bottom to top.
The
<EM CLASS="Ep">scandirection</EM>
is not supported by the
SILICON VIDEO&reg; 9T001C.
<P>
The
<EM CLASS="Ep">pixelClkFreq</EM>
specifies the sensor's pixel clock frequency, in MHz.
Lower frequencies provide for longer exposures, but slower
frame rates.
Higher frequencies provide higher frame rates, but shorter
exposures and more fixed pattern noise.
<P>
The
<EM CLASS="Ep">framePeriod</EM>
specifies the sensor's frame period, or inverse of frame rate,
in millseconds.
A longer frame period allows for longer exposures.
Any invalid value is corrected to the nearest valid value.
Thus,
<EM CLASS="Ep">framePeriod</EM>=0
can be used to specify the minimum frame period (maximum frame
rate) obtainable with the specified
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
<EM CLASS="Ep">aoiheight</EM>,
and
<EM CLASS="Ep">subsample</EM>.
<P>
Use of
<A HREF="#pxd_SV9M001_setResolutionAndTiming"CLASS="Er">pxd_SV9M001_setResolutionAndTiming</A>
may change the captured image's resolution,
and thus affect the return values of
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>
and
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>.
Use of
<A HREF="#pxd_SV9M001_setResolutionAndTiming"CLASS="Er">pxd_SV9M001_setResolutionAndTiming</A>
will terminate any capture in progress,
such as that initiated by
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
or
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>.
<P>
The
<A HREF="#pxd_SV9M001_getSubsample"CLASS="Er">pxd_SV9M001_getSubsample</A>
returns the current decimation setting, coded as described above.
The
<A HREF="#pxd_SV9M001_getAoiTop"CLASS="Er">pxd_SV9M001_getAoiTop</A>
and
<A HREF="#pxd_SV9M001_getAoiLeft"CLASS="Er">pxd_SV9M001_getAoiLeft</A>
return the current AOI left and top edges, respectively.
The
<A HREF="#pxd_SV9M001_getScanDirection"CLASS="Er">pxd_SV9M001_getScanDirection</A>
returns the current scan direction setting, coded as described above.
The
<A HREF="#pxd_SV9M001_getPixelClock"CLASS="Er">pxd_SV9M001_getPixelClock</A>
returns the current pixel clock frequency, as described above.
The
<A HREF="#pxd_SV9M001_getFramePeriod"CLASS="Er">pxd_SV9M001_getFramePeriod</A>
returns the current frame period, or frame rate, as described above.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV9M001_getSubsample"CLASS="Er">pxd_SV9M001_getSubsample</A>,
<A HREF="#pxd_SV9M001_getAoiTop"CLASS="Er">pxd_SV9M001_getAoiTop</A>,
<A HREF="#pxd_SV9M001_getAoiLeft"CLASS="Er">pxd_SV9M001_getAoiLeft</A>,
<A HREF="#pxd_SV9M001_getScanDirection"CLASS="Er">pxd_SV9M001_getScanDirection</A>,
<A HREF="#pxd_SV9M001_getPixelClock"CLASS="Er">pxd_SV9M001_getPixelClock</A>,
and
<A HREF="#pxd_SV9M001_getFramePeriod"CLASS="Er">pxd_SV9M001_getFramePeriod</A>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV9M001_setResolutionAndTiming"CLASS="Er">pxd_SV9M001_setResolutionAndTiming</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV9M001_setVideoAndTriggerMode NX532"CLASS="NX"></A>
<A NAME="pxd_SV9M001_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV9M001/SV9T001 Video And Trigger Modes NX533"CLASS="NX"></A>
<A NAME="Set SV9M001/SV9T001 Video And Trigger Modes   ---   pxd_SV9M001_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV9M001/SV9T001 Video And Trigger Modes   ---   pxd_SV9M001_setVideoAndTriggerMode"></A>
<H6 CLASS="Sf">Set SV9M001/SV9T001 Video And Trigger Modes   ---   pxd_SV9M001_setVideoAndTriggerMode</H6>
<A NAME="pxd_SV9M001_setCtrlRate NX534"CLASS="NX"></A>
<A NAME="pxd_SV9M001_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV9M001/SV9T001 Controlled Exposure And Frame Rate NX535"CLASS="NX"></A>
<A NAME="Set SV9M001/SV9T001 Controlled Exposure And Frame Rate   ---   pxd_SV9M001_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV9M001/SV9T001 Controlled Exposure And Frame Rate   ---   pxd_SV9M001_setCtrlRate"></A>
<H6 CLASS="Sg">Set SV9M001/SV9T001 Controlled Exposure And Frame Rate   ---   pxd_SV9M001_setCtrlRate</H6>
<A NAME="pxd_SV9M001_getVideoMode NX536"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Video Mode NX537"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Video Mode   ---   pxd_SV9M001_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Video Mode   ---   pxd_SV9M001_getVideoMode"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Video Mode   ---   pxd_SV9M001_getVideoMode</H6>
<A NAME="pxd_SV9M001_getCtrlVideoMode NX538"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Video Mode NX539"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Video Mode   ---   pxd_SV9M001_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Video Mode   ---   pxd_SV9M001_getCtrlVideoMode"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Controlled Video Mode   ---   pxd_SV9M001_getCtrlVideoMode</H6>
<A NAME="pxd_SV9M001_getCtrlTriggerMode NX540"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Trigger Mode NX541"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Trigger Mode   ---   pxd_SV9M001_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Trigger Mode   ---   pxd_SV9M001_getCtrlTriggerMode"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Controlled Trigger Mode   ---   pxd_SV9M001_getCtrlTriggerMode</H6>
<A NAME="pxd_SV9M001_getCtrlFrameRate NX542"CLASS="NX"></A>
<A NAME="pxd_SV9M001_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Frame Rate NX543"CLASS="NX"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Frame Rate   ---   pxd_SV9M001_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV9M001/SV9T001 Controlled Frame Rate   ---   pxd_SV9M001_getCtrlFrameRate"></A>
<H6 CLASS="Sg">Get SV9M001/SV9T001 Controlled Frame Rate   ---   pxd_SV9M001_getCtrlFrameRate</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV9M001_setVideoAndTriggerMode(unitmap, rsvd, videomode, controlledmode, triggermode, rsvd4, rsvd5, rsvd6);
int    pxd_SV9M001_setCtrlRate(unitmap, rsvd, rsvd2, framerate, rsvd3);
int    pxd_SV9M001_getVideoMode(unitmap);
int    pxd_SV9M001_getCtrlVideoMode(unitmap);
int    pxd_SV9M001_getCtrlTriggerMode(unitmap);
double pxd_SV9M001_getCtrlFrameRate(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
int                 rsvd4;              // Reserved, should be 0
double              rsvd5;              // Reserved, should be 0
double              rsvd6;              // Reserved, should be 0
int                 videomode;          // Camera video mode: 'f': free-run, 'c': controlled
int                 controlledmode;     // Controlled mode: 'c': continuous, 's': singleshot
int                 triggermode;        // Controlled trigger: 'n': none, '+': rising, '-': falling
double              framerate;          // Controlled frame rate, Hz.
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV9M001_setVideoAndTriggerMode"CLASS="Er">pxd_SV9M001_setVideoAndTriggerMode</A>
sets the video and trigger modes of the
SILICON VIDEO&reg; 9M001,
SILICON VIDEO&reg; 9M001C, and
SILICON VIDEO&reg; 9T001C
cameras connected to PIXCI&reg; SI imaging boards.
If
<EM CLASS="Ep">videomode</EM>='f',
the camera is free-running with exposure controlled by the camera
and set via
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>;
other parameters to
<A HREF="#pxd_SV9M001_setVideoAndTriggerMode"CLASS="Er">pxd_SV9M001_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV9M001_setCtrlRate"CLASS="Er">pxd_SV9M001_setCtrlRate</A>
have no effect.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and the
<EM CLASS="Ep">triggermode</EM>='n'
video fields are continuously and automatically triggered.
The
<EM CLASS="Ep">framerate</EM>
specifies the field repetition rate.
The exposure is controlled by the camera via
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='s'
and
<EM CLASS="Ep">triggermode</EM>='n',
video fields are triggered only upon demand;
no hardware trigger is used and video fields
are triggered by
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and
<EM CLASS="Ep">triggermode</EM>='+'
or
<EM CLASS="Ep">triggermode</EM>='-',
video fields are triggered only upon demand;
video fields are triggered by a rising or falling,
respectively, edge of the trigger signal;
the
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
must be invoked before the hardware trigger
so as to
''arm''
the imaging board.
The exposure
is set via
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>.
<P>
The
<A HREF="#pxd_SV9M001_getVideoMode"CLASS="Er">pxd_SV9M001_getVideoMode</A>,
<A HREF="#pxd_SV9M001_getCtrlVideoMode"CLASS="Er">pxd_SV9M001_getCtrlVideoMode</A>,
and
<A HREF="#pxd_SV9M001_getCtrlTriggerMode"CLASS="Er">pxd_SV9M001_getCtrlTriggerMode</A>,
returns the camera's video mode, the controlled video mode,
and the controlled trigger mode, respectively, coded as described above.
The
<A HREF="#pxd_SV9M001_getCtrlFrameRate"CLASS="Er">pxd_SV9M001_getCtrlFrameRate</A>
return the controlled frame rate.
<P>
The
<A HREF="#pxd_SV9M001_setVideoAndTriggerMode"CLASS="Er">pxd_SV9M001_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV9M001_setCtrlRate"CLASS="Er">pxd_SV9M001_setCtrlRate</A>
eliminate having to use
''raw''
values via
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
to set the controlled exposure and/or frame rate.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV9M001_getVideoMode"CLASS="Er">pxd_SV9M001_getVideoMode</A>,
<A HREF="#pxd_SV9M001_getCtrlVideoMode"CLASS="Er">pxd_SV9M001_getCtrlVideoMode</A>,
<A HREF="#pxd_SV9M001_getCtrlTriggerMode"CLASS="Er">pxd_SV9M001_getCtrlTriggerMode</A>,
and
<A HREF="#pxd_SV9M001_getCtrlFrameRate"CLASS="Er">pxd_SV9M001_getCtrlFrameRate</A>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV9M001_setVideoAndTriggerMode"CLASS="Er">pxd_SV9M001_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV9M001_setCtrlRate"CLASS="Er">pxd_SV9M001_setCtrlRate</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV642_setExposureAndGain NX544"CLASS="NX"></A>
<A NAME="pxd_SV642_setExposureAndGain"CLASS="Sf"></A>
<A NAME="Set SV642 Exposure and Gain NX545"CLASS="NX"></A>
<A NAME="Set SV642 Exposure and Gain   ---   pxd_SV642_setExposureAndGain"CLASS="Sf"></A>
<A NAME="Set SV642 Exposure and Gain   ---   pxd_SV642_setExposureAndGain"></A>
<H6 CLASS="Sf">Set SV642 Exposure and Gain   ---   pxd_SV642_setExposureAndGain</H6>
<A NAME="pxd_SV642_getExposure NX546"CLASS="NX"></A>
<A NAME="pxd_SV642_getExposure"CLASS="Sg"></A>
<A NAME="Get SV642 Exposure NX547"CLASS="NX"></A>
<A NAME="Get SV642 Exposure   ---   pxd_SV642_getExposure"CLASS="Sg"></A>
<A NAME="Get SV642 Exposure   ---   pxd_SV642_getExposure"></A>
<H6 CLASS="Sg">Get SV642 Exposure   ---   pxd_SV642_getExposure</H6>
<A NAME="pxd_SV642_getGain NX548"CLASS="NX"></A>
<A NAME="pxd_SV642_getGain"CLASS="Sg"></A>
<A NAME="Get SV642 Gain NX549"CLASS="NX"></A>
<A NAME="Get SV642 Gain   ---   pxd_SV642_getGain"CLASS="Sg"></A>
<A NAME="Get SV642 Gain   ---   pxd_SV642_getGain"></A>
<H6 CLASS="Sg">Get SV642 Gain   ---   pxd_SV642_getGain</H6>
<A NAME="pxd_SV642_getGainRange NX550"CLASS="NX"></A>
<A NAME="pxd_SV642_getGainRange"CLASS="Sg"></A>
<A NAME="Get SV642 Gain Range NX551"CLASS="NX"></A>
<A NAME="Get SV642 Gain Range   ---   pxd_SV642_getGainRange"CLASS="Sg"></A>
<A NAME="Get SV642 Gain Range   ---   pxd_SV642_getGainRange"></A>
<H6 CLASS="Sg">Get SV642 Gain Range   ---   pxd_SV642_getGainRange</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV642_setExposureAndGain(unitmap, rsvd, exposure, redgain, grnrgain, bluegain, grnbgain, gainrange);
double pxd_SV642_getExposure(unitmap);
double pxd_SV642_getGain(unitmap, color);
int    pxd_SV642_getGainRange(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
double              exposure;           // Exposure period, in milliseconds
double              redgain;            // Gain of red pixels, in dB.
double              grnrgain;           // Gain of green-next-to-red pixels, in dB.
double              blugain;            // Gain of blue pixels, in dB.
double              grnbgain;           // Gain of green-next-to-blue pixels, in dB.
int                 color;              // Color selection: 'R', 'G'^'r', 'B', or 'G'^'B'
int                 gainrange;          // 10: high/coarse range, 5: low/fine range
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO&reg; NX552"CLASS="NX"></A>
The
<A HREF="#pxd_SV642_setExposureAndGain"CLASS="Er">pxd_SV642_setExposureAndGain</A>
sets the exposure period and gain of
SILICON VIDEO&reg; 642M
and
SILICON VIDEO&reg; 642C
cameras connected to PIXCI&reg; SI imaging boards.
<P>
The camera's exposure period
is set to
<EM CLASS="Ep">exposure</EM>
milliseconds.
The allowable values are dependent on the camera's
current operating mode - specifically the pixel clock frequency,
and AOI height.
Any invalid value is corrected to the nearest valid value.
<P>
The camera's gain of red, green-next-to-red, blue,
and green-next-to-blue
pixels is set to
<EM CLASS="Ep">redgain</EM>,
<EM CLASS="Ep">grnrgain</EM>,
<EM CLASS="Ep">blugain</EM>,
and
<EM CLASS="Ep">grnggain</EM>,
respectively,
each in the range of 0.0 to 20*log<SUB><SMALL>10</SMALL></SUB>(18) dB
if
<EM CLASS="Ep">gainrange</EM>=10
or in the range of 0.0 to 20*log<SUB><SMALL>10</SMALL></SUB>(18)/2 dB
if
<EM CLASS="Ep">gainrange</EM>=5.
Different gains per
''color''
can be set for the SILICON VIDEO&reg; 642
(i.e. monochrome) camera; the gain settings affect
various pixels according to their placement
in what would be a Bayer pattern.
Normally, for monochrome cameras the gains are identical.
<P>
The
<A HREF="#pxd_SV642_getExposure"CLASS="Er">pxd_SV642_getExposure</A>
returns the current exposure setting,
in milliseconds.
<P>
The
<A HREF="#pxd_SV642_getGain"CLASS="Er">pxd_SV642_getGain</A>
returns one of the current gain settings, in dB.
If
<EM CLASS="Ep">color</EM>='R',
the red gain is returned,
if
<EM CLASS="Ep">color</EM>='G'^'R',
the green-next-to-red gain is returned,
if
<EM CLASS="Ep">color</EM>='B',
the blue gain is returned,
if
<EM CLASS="Ep">color</EM>='G'^'B',
the green-next-to-blue gain is returned.
<P>
The
<A HREF="#pxd_SV642_getGainRange"CLASS="Er">pxd_SV642_getGainRange</A>
returns the current gain range setting, 5 or 10.
<P>
Note: The
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
performs partial, quick initialization of XCLIB;
initialization for the
<CITE CLASS="Ec">pxd_SV642_</CITE>
functions is delayed until the first such function is called.
Time sensitive applications should call
any
<CITE CLASS="Ec">pxd_SV642_</CITE>
function once
before entering the application's time critical phase.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV642_getExposure"CLASS="Er">pxd_SV642_getExposure</A>,
<A HREF="#pxd_SV642_getGain"CLASS="Er">pxd_SV642_getGain</A>,
and
<A HREF="#pxd_SV642_getGainRange"CLASS="Er">pxd_SV642_getGainRange</A>
returns values as described above, or 0
if the library is not open for use, the
wrong imaging board is in use, or an invalid
value of
<EM CLASS="Ep">color</EM>
is used.
<P>
The
<A HREF="#pxd_SV642_setExposureAndGain"CLASS="Er">pxd_SV642_setExposureAndGain</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV642_setResolutionAndTiming NX553"CLASS="NX"></A>
<A NAME="pxd_SV642_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV642 Resolution and Timing NX554"CLASS="NX"></A>
<A NAME="Set SV642 Resolution and Timing   ---   pxd_SV642_setResolutionAndTiming"CLASS="Sf"></A>
<A NAME="Set SV642 Resolution and Timing   ---   pxd_SV642_setResolutionAndTiming"></A>
<H6 CLASS="Sf">Set SV642 Resolution and Timing   ---   pxd_SV642_setResolutionAndTiming</H6>
<A NAME="pxd_SV642_getAoiTop NX555"CLASS="NX"></A>
<A NAME="pxd_SV642_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV642 Aoi Top Edge NX556"CLASS="NX"></A>
<A NAME="Get SV642 Aoi Top Edge   ---   pxd_SV642_getAoiTop"CLASS="Sg"></A>
<A NAME="Get SV642 Aoi Top Edge   ---   pxd_SV642_getAoiTop"></A>
<H6 CLASS="Sg">Get SV642 Aoi Top Edge   ---   pxd_SV642_getAoiTop</H6>
<A NAME="pxd_SV642_getAoiLeft NX557"CLASS="NX"></A>
<A NAME="pxd_SV642_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV642 Aoi Left Edge NX558"CLASS="NX"></A>
<A NAME="Get SV642 Aoi Left Edge   ---   pxd_SV642_getAoiLeft"CLASS="Sg"></A>
<A NAME="Get SV642 Aoi Left Edge   ---   pxd_SV642_getAoiLeft"></A>
<H6 CLASS="Sg">Get SV642 Aoi Left Edge   ---   pxd_SV642_getAoiLeft</H6>
<A NAME="pxd_SV642_getPixelClock NX559"CLASS="NX"></A>
<A NAME="pxd_SV642_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV642 Pixel Clock Frequency NX560"CLASS="NX"></A>
<A NAME="Get SV642 Pixel Clock Frequency   ---   pxd_SV642_getPixelClock"CLASS="Sg"></A>
<A NAME="Get SV642 Pixel Clock Frequency   ---   pxd_SV642_getPixelClock"></A>
<H6 CLASS="Sg">Get SV642 Pixel Clock Frequency   ---   pxd_SV642_getPixelClock</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV642_setResolutionAndTiming(unitmap, rsvd, rsvd2, aoileft, aoitop, aoiwidth,
                                     aoiheight, rsvd3, pixelClkFreq, framePeriod, rsvd4);
int    pxd_SV642_getAoiTop(unitmap);
int    pxd_SV642_getAoiLeft(unitmap);
double pxd_SV642_getPixelClock(unitmap);
double pxd_SV642_getFramePeriod(int unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
int                 aoileft;            // Left edge of partial scan AOI
int                 aoitop;             // Top edge of partial scan AOI
int                 aoiwidth;           // Width of partial scan AOI
int                 aoiheight;          // Height of partial scan AOI
double              pixelClkFreq;       // Pixel clock frequency, in MHz.
double              framePeriod;        // Frame period, in msec.
double              rsvd4;              // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV642_setResolutionAndTiming"CLASS="Er">pxd_SV642_setResolutionAndTiming</A>
sets the resolution, scan direction, and pixel clock frequency of
SILICON VIDEO&reg; 642M
and
SILICON VIDEO&reg; 642C
cameras connected to PIXCI&reg; SI imaging boards.
<P>
The
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
and
<EM CLASS="Ep">aoiheight</EM>
select partial scan readout of the sensor, selecting
the coordinates of the left edge and top edge of the readout AOI,
and width and height of the readout AOI.
These parameters are always relative to the sensor's full resolution,
namely 640 by 480.
<P>
The
<EM CLASS="Ep">pixelClkFreq</EM>
specifies the sensor's pixel clock frequency, in MHz.
Lower frequencies provide for longer exposures, but slower
frame rates.
Higher frequencies provide higher frame rates, but shorter
exposures and more fixed pattern noise.
<P>
The
<EM CLASS="Ep">framePeriod</EM>
specifies the sensor's frame period, or inverse of frame rate,
in millseconds.
A longer frame period allows for longer exposures.
Any invalid value is corrected to the nearest valid value.
Thus,
<EM CLASS="Ep">framePeriod</EM>=0
can be used to specify the minimum frame period (maximum frame
rate) obtainable with the specified
<EM CLASS="Ep">aoileft</EM>,
<EM CLASS="Ep">aoitop</EM>,
<EM CLASS="Ep">aoiwidth</EM>,
and
<EM CLASS="Ep">aoiheight</EM>.
<P>
Use of
<A HREF="#pxd_SV642_setResolutionAndTiming"CLASS="Er">pxd_SV642_setResolutionAndTiming</A>
may change the captured image's resolution,
and thus affect the return values of
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>
and
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>.
Use of
<A HREF="#pxd_SV642_setResolutionAndTiming"CLASS="Er">pxd_SV642_setResolutionAndTiming</A>
will terminate any capture in progress,
such as that initiated by
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
or
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>.
<P>
The
<A HREF="#pxd_SV642_getAoiTop"CLASS="Er">pxd_SV642_getAoiTop</A>
and
<A HREF="#pxd_SV642_getAoiLeft"CLASS="Er">pxd_SV642_getAoiLeft</A>
return the current AOI left and top edges, respectively.
The
<A HREF="#pxd_SV642_getPixelClock"CLASS="Er">pxd_SV642_getPixelClock</A>
returns the current pixel clock frequency, as described above.
The
<A HREF="#pxd_SV642_getFramePeriod"CLASS="Er">pxd_SV642_getFramePeriod</A>
returns the current frame period, or frame rate, as described above.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV642_getAoiTop"CLASS="Er">pxd_SV642_getAoiTop</A>,
<A HREF="#pxd_SV642_getAoiLeft"CLASS="Er">pxd_SV642_getAoiLeft</A>,
<A HREF="#pxd_SV642_getPixelClock"CLASS="Er">pxd_SV642_getPixelClock</A>,
and
<A HREF="#pxd_SV642_getFramePeriod"CLASS="Er">pxd_SV642_getFramePeriod</A>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV642_setResolutionAndTiming"CLASS="Er">pxd_SV642_setResolutionAndTiming</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="pxd_SV642_setVideoAndTriggerMode NX561"CLASS="NX"></A>
<A NAME="pxd_SV642_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV642 Video And Trigger Modes NX562"CLASS="NX"></A>
<A NAME="Set SV642 Video And Trigger Modes   ---   pxd_SV642_setVideoAndTriggerMode"CLASS="Sf"></A>
<A NAME="Set SV642 Video And Trigger Modes   ---   pxd_SV642_setVideoAndTriggerMode"></A>
<H6 CLASS="Sf">Set SV642 Video And Trigger Modes   ---   pxd_SV642_setVideoAndTriggerMode</H6>
<A NAME="pxd_SV642_setCtrlRate NX563"CLASS="NX"></A>
<A NAME="pxd_SV642_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV642 Controlled Exposure And Frame Rate NX564"CLASS="NX"></A>
<A NAME="Set SV642 Controlled Exposure And Frame Rate   ---   pxd_SV642_setCtrlRate"CLASS="Sg"></A>
<A NAME="Set SV642 Controlled Exposure And Frame Rate   ---   pxd_SV642_setCtrlRate"></A>
<H6 CLASS="Sg">Set SV642 Controlled Exposure And Frame Rate   ---   pxd_SV642_setCtrlRate</H6>
<A NAME="pxd_SV642_getVideoMode NX565"CLASS="NX"></A>
<A NAME="pxd_SV642_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV642 Video Mode NX566"CLASS="NX"></A>
<A NAME="Get SV642 Video Mode   ---   pxd_SV642_getVideoMode"CLASS="Sg"></A>
<A NAME="Get SV642 Video Mode   ---   pxd_SV642_getVideoMode"></A>
<H6 CLASS="Sg">Get SV642 Video Mode   ---   pxd_SV642_getVideoMode</H6>
<A NAME="pxd_SV642_getCtrlVideoMode NX567"CLASS="NX"></A>
<A NAME="pxd_SV642_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV642 Controlled Video Mode NX568"CLASS="NX"></A>
<A NAME="Get SV642 Controlled Video Mode   ---   pxd_SV642_getCtrlVideoMode"CLASS="Sg"></A>
<A NAME="Get SV642 Controlled Video Mode   ---   pxd_SV642_getCtrlVideoMode"></A>
<H6 CLASS="Sg">Get SV642 Controlled Video Mode   ---   pxd_SV642_getCtrlVideoMode</H6>
<A NAME="pxd_SV642_getCtrlTriggerMode NX569"CLASS="NX"></A>
<A NAME="pxd_SV642_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV642 Controlled Trigger Mode NX570"CLASS="NX"></A>
<A NAME="Get SV642 Controlled Trigger Mode   ---   pxd_SV642_getCtrlTriggerMode"CLASS="Sg"></A>
<A NAME="Get SV642 Controlled Trigger Mode   ---   pxd_SV642_getCtrlTriggerMode"></A>
<H6 CLASS="Sg">Get SV642 Controlled Trigger Mode   ---   pxd_SV642_getCtrlTriggerMode</H6>
<A NAME="pxd_SV642_getCtrlFrameRate NX571"CLASS="NX"></A>
<A NAME="pxd_SV642_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV642 Controlled Frame Rate NX572"CLASS="NX"></A>
<A NAME="Get SV642 Controlled Frame Rate   ---   pxd_SV642_getCtrlFrameRate"CLASS="Sg"></A>
<A NAME="Get SV642 Controlled Frame Rate   ---   pxd_SV642_getCtrlFrameRate"></A>
<H6 CLASS="Sg">Get SV642 Controlled Frame Rate   ---   pxd_SV642_getCtrlFrameRate</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    pxd_SV642_setVideoAndTriggerMode(unitmap, rsvd, videomode, controlledmode, triggermode, rsvd4, rsvd5, rsvd6);
int    pxd_SV642_setCtrlRate(unitmap, rsvd, rsvd2, framerate, rsvd3);
int    pxd_SV642_getVideoMode(unitmap);
int    pxd_SV642_getCtrlVideoMode(unitmap);
int    pxd_SV642_getCtrlTriggerMode(unitmap);
double pxd_SV642_getCtrlFrameRate(unitmap);
<BR>
int                 unitmap;            // Unit selection bit map (1 for single unit)
int                 rsvd;               // Reserved, should be 0
int                 rsvd2;              // Reserved, should be 0
int                 rsvd3;              // Reserved, should be 0
int                 rsvd4;              // Reserved, should be 0
double              rsvd5;              // Reserved, should be 0
double              rsvd6;              // Reserved, should be 0
int                 videomode;          // Camera video mode: 'f': free-run, 'c': controlled
int                 controlledmode;     // Controlled mode: 'c': continuous, 's': singleshot
int                 triggermode;        // Controlled trigger: 'n': none, '+': rising, '-': falling
double              framerate;          // Controlled frame rate, Hz.
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#pxd_SV642_setVideoAndTriggerMode"CLASS="Er">pxd_SV642_setVideoAndTriggerMode</A>
sets the video and trigger modes of the
SILICON VIDEO&reg; 642M
and
SILICON VIDEO&reg; 642C
cameras connected to PIXCI&reg; SI imaging boards.
If
<EM CLASS="Ep">videomode</EM>='f',
the camera is free-running with exposure controlled by the camera
and set via
<A HREF="#pxd_SV642_setExposureAndGain"CLASS="Er">pxd_SV642_setExposureAndGain</A>;
other parameters to
<A HREF="#pxd_SV642_setVideoAndTriggerMode"CLASS="Er">pxd_SV642_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV642_setCtrlRate"CLASS="Er">pxd_SV642_setCtrlRate</A>
have no effect.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and the
<EM CLASS="Ep">triggermode</EM>='n'
video fields are continuously and automatically triggered.
The
<EM CLASS="Ep">framerate</EM>
specifies the field repetition rate.
The exposure is controlled by the camera via
<A HREF="#pxd_SV642_setExposureAndGain"CLASS="Er">pxd_SV642_setExposureAndGain</A>.
<P>
If
<EM CLASS="Ep">videomode</EM>='c',
initiation of each video field is controlled
by the PIXCI&reg; imaging board.
If
<EM CLASS="Ep">controlledmode</EM>='s'
and
<EM CLASS="Ep">triggermode</EM>='n',
video fields are triggered only upon demand;
no hardware trigger is used and video fields
are triggered by
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>.
If
<EM CLASS="Ep">controlledmode</EM>='c'
and
<EM CLASS="Ep">triggermode</EM>='+'
or
<EM CLASS="Ep">triggermode</EM>='-',
video fields are triggered only upon demand;
video fields are triggered by a rising or falling,
respectively, edge of the trigger signal;
the
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>
or
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>
must be invoked before the hardware trigger
so as to
''arm''
the imaging board.
The exposure
is set via
<A HREF="#pxd_SV642_setExposureAndGain"CLASS="Er">pxd_SV642_setExposureAndGain</A>.
<P>
The
<A HREF="#pxd_SV642_getVideoMode"CLASS="Er">pxd_SV642_getVideoMode</A>,
<A HREF="#pxd_SV642_getCtrlVideoMode"CLASS="Er">pxd_SV642_getCtrlVideoMode</A>,
and
<A HREF="#pxd_SV642_getCtrlTriggerMode"CLASS="Er">pxd_SV642_getCtrlTriggerMode</A>,
returns the camera's video mode, the controlled video mode,
and the controlled trigger mode, respectively, coded as described above.
The
<A HREF="#pxd_SV642_getCtrlFrameRate"CLASS="Er">pxd_SV642_getCtrlFrameRate</A>
return the controlled frame rate.
<P>
The
<A HREF="#pxd_SV642_setVideoAndTriggerMode"CLASS="Er">pxd_SV642_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV642_setCtrlRate"CLASS="Er">pxd_SV642_setCtrlRate</A>
eliminate having to use
''raw''
values via
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>
to set the controlled exposure and/or frame rate.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
The
<A HREF="#pxd_SV642_getVideoMode"CLASS="Er">pxd_SV642_getVideoMode</A>,
<A HREF="#pxd_SV642_getCtrlVideoMode"CLASS="Er">pxd_SV642_getCtrlVideoMode</A>,
<A HREF="#pxd_SV642_getCtrlTriggerMode"CLASS="Er">pxd_SV642_getCtrlTriggerMode</A>,
and
<A HREF="#pxd_SV642_getCtrlFrameRate"CLASS="Er">pxd_SV642_getCtrlFrameRate</A>,
returns values as described above, or 0
if the library is not open for use, or the
wrong imaging board is in use.
<P>
The
<A HREF="#pxd_SV642_setVideoAndTriggerMode"CLASS="Er">pxd_SV642_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV642_setCtrlRate"CLASS="Er">pxd_SV642_setCtrlRate</A>
returns:
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="3">
<A NAME="Structured Style Interface - Open, Close, Information, and Fault Services"CLASS="Ch"></A>
<A NAME="4.  Structured Style Interface - Open, Close, Information, and Fault Services"></A>
<H1>4.  Structured Style Interface - Open, Close, Information, and Fault Services</H1>
<P>
The Open, Close, Information, and Fault services
open the library for use, close the library after use,
identify the types of imaging board(s) and/or functional units present
as well as the versions of library and driver,
and provide descriptions of operational faults.<A HREF="#Footnote 29"CLASS="Ff"><SUP>[29]</SUP></A>
<HR SIZE="1">
<A NAME="xclib_libincid NX573"CLASS="NX"></A>
<A NAME="xclib_libincid"CLASS="Sf"></A>
<A NAME="Get Imaging Board Include Files ID NX574"CLASS="NX"></A>
<A NAME="Get Imaging Board Include Files ID   ---   xclib_libincid"CLASS="Sf"></A>
<A NAME="Get Imaging Board Include Files ID   ---   xclib_libincid"></A>
<H6 CLASS="Sf">Get Imaging Board Include Files ID   ---   xclib_libincid</H6>
<A NAME="xclib_liblibid NX575"CLASS="NX"></A>
<A NAME="xclib_liblibid"CLASS="Sg"></A>
<A NAME="Get Imaging Board Library ID NX576"CLASS="NX"></A>
<A NAME="Get Imaging Board Library ID   ---   xclib_liblibid"CLASS="Sg"></A>
<A NAME="Get Imaging Board Library ID   ---   xclib_liblibid"></A>
<H6 CLASS="Sg">Get Imaging Board Library ID   ---   xclib_liblibid</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int     xclib_liblibid(info);
#define xclib_libincid(info)
<BR>
struct pxdevinfo    *info;          // Only 'libraryid' field used
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#xclib_liblibid"CLASS="Er">xclib_liblibid</A>
fills the
<EM CLASS="Ep">libraryid</EM>
field of the
<EM CLASS="Ep">info</EM>
instance of the
<A HREF="#pxdevinfo"CLASS="Er">pxdevinfo</A>
structure with an identification string of the current
imaging board library.
<P>
The
<A HREF="#xclib_libincid"CLASS="Er">xclib_libincid</A>
fills the
<EM CLASS="Ep">libraryid</EM>
field of the
<EM CLASS="Ep">info</EM>
instance of the
<A HREF="#pxdevinfo"CLASS="Er">pxdevinfo</A>
structure with an identification string of the current
include (i.e.
''.h'')
files.
<P>
Both
<A HREF="#xclib_liblibid"CLASS="Er">xclib_liblibid</A>
and
<A HREF="#xclib_libincid"CLASS="Er">xclib_libincid</A>
may be used with the XCLIB library closed.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">info</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect
(<A HREF="#xclib_liblibid"CLASS="Er">xclib_liblibid</A>
only).
</DL>
<HR SIZE="1">
<A NAME="xclib_open NX577"CLASS="NX"></A>
<A NAME="xclib_open"CLASS="Sf"></A>
<A NAME="PIXCI&reg; Imaging Board: Structured Open NX578"CLASS="NX"></A>
<A NAME="PIXCI&reg; Imaging Board: Structured Open   ---   xclib_open"CLASS="Sf"></A>
<A NAME="PIXCI&reg; Imaging Board: Structured Open   ---   xclib_open"></A>
<H6 CLASS="Sf">PIXCI&reg; Imaging Board: Structured Open   ---   xclib_open</H6>
<A NAME="xclib_close NX579"CLASS="NX"></A>
<A NAME="xclib_close"CLASS="Sg"></A>
<A NAME="PIXCI&reg; Imaging Board: Structured Close NX580"CLASS="NX"></A>
<A NAME="PIXCI&reg; Imaging Board: Structured Close   ---   xclib_close"CLASS="Sg"></A>
<A NAME="PIXCI&reg; Imaging Board: Structured Close   ---   xclib_close"></A>
<H6 CLASS="Sg">PIXCI&reg; Imaging Board: Structured Close   ---   xclib_close</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int xclib_open (xclib, drivermodes, driverparms, formatname, formatfile);
int xclib_close(xclib);
<BR>
struct xclibs       *xclib;         // Existing instance of struct xclibs
char                *drivermodes;   // Driver open mode
char                *driverparms;   // Driver configuration parms, or NULL or &quot;&quot;
char                *formatname;    // Video format configuration name, or NULL or &quot;&quot;
char                *formatfile;    // Video format configuration file name, or NULL or &quot;&quot;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>
opens the PIXCI&reg; XCLIB Library and Driver for use.
The
<EM CLASS="Ep">xclib</EM>
instance
of the
<A HREF="#xclibs"CLASS="Er">xclibs</A>
structure, provided by the application, is initialized by
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>;
thereafter library and driver services are accessed through
function pointers within the
<EM CLASS="Ep">xclib</EM>.
Once open, the PIXCI&reg; library and driver
should be closed by
<A HREF="#xclib_close"CLASS="Er">xclib_close</A>
upon the same
<EM CLASS="Ep">xclib</EM>
before the program exits;
most services accessed through the same
<EM CLASS="Ep">xclib</EM>
after closing return a PXERNOTOPEN error.
<P>
If
<EM CLASS="Ep">drivermodes</EM>=NULL
or
<EM CLASS="Ep">drivermodes</EM>=&quot;&quot;<EM CLASS="Ep">,</EM>
the library, driver, and imaging boards(s)
are open for use.
<P>
If
<EM CLASS="Ep">drivermodes</EM>
contains the string &quot;-offline&quot;,
the library is opened only for use of off-line services, namely:
<A HREF="#::allocStateCopy"CLASS="Er">::allocStateCopy</A>,
<A HREF="#::compareStateCopy"CLASS="Er">::compareStateCopy</A>,
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>,
<A HREF="#::freeStateCopy"CLASS="Er">::freeStateCopy</A>,
<A HREF="#::importStateCopy"CLASS="Er">::importStateCopy</A>,
<A HREF="#::initStateCopy"CLASS="Er">::initStateCopy</A>,
and
<A HREF="#::errorCodeString"CLASS="Er">::errorCodeString</A>.
The driver and/or imaging board need not be present.
<P>
If
<EM CLASS="Ep">drivermodes</EM>
contains the string &quot;-configure&quot;,
the library and driver is opened only for use of configuration services, namely:
<A HREF="#::allocStateCopy"CLASS="Er">::allocStateCopy</A>,
<A HREF="#::compareStateCopy"CLASS="Er">::compareStateCopy</A>,
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>,
<A HREF="#::freeStateCopy"CLASS="Er">::freeStateCopy</A>,
<A HREF="#::importStateCopy"CLASS="Er">::importStateCopy</A>,
<A HREF="#::initStateCopy"CLASS="Er">::initStateCopy</A>,
<A HREF="#::setDevParms"CLASS="Er">::setDevParms</A>,
<A HREF="#::getDevParms"CLASS="Er">::getDevParms</A>,
and
<A HREF="#::errorCodeString"CLASS="Er">::errorCodeString</A>.
<P>
The
<EM CLASS="Ep">driverparms</EM>
may be a Driver Configuration Parameter string
as described in
<A HREF="#Installation and Configuration &mdash; Run Time"CLASS="Er">Installation and Configuration &mdash; Run Time</A>.
<P>
The
<EM CLASS="Ep">formatfile</EM>
may be the file name of a Video Configuration Format
previously saved with
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>
or with the
<CITE CLASS="Ec">XCAP</CITE>
application.<A HREF="#Footnote 30"CLASS="Ff"><SUP>[30]</SUP></A>
The
<EM CLASS="Ep">formatfile</EM>
is imported and all of its Video Configuration Formats
are defined for later use via
<A HREF="#::definedState"CLASS="Er">::definedState</A>.
<P>
The
<EM CLASS="Ep">formatname</EM>
may be the predefined name of a
standard video configuration format
suitable for the imaging board in use;
the valid predefined names are described in
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>.
The specified standard Video Configuration Format
is defined via
<A HREF="#::definedState"CLASS="Er">::definedState</A>
for later use with a
video state id of PXMODE_DIGI.
<P>
The
<EM CLASS="Ep">formatfile</EM>
and
<EM CLASS="Ep">formatname</EM>
may be NULL.
If both are NULL,
a video state must be defined via
<A HREF="#::importStateCopy"CLASS="Er">::importStateCopy</A>,
or by filling the actual video configuration format
structures and
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
before capturing, displaying or accessing image frame buffers.
If both are specified, the
<EM CLASS="Ep">formatfile</EM>
is imported first; the
<EM CLASS="Ep">formatname</EM>
re-defines any video state id of PXMODE_DIGI
that was imported.
<P>
If the
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>
fails, the
<A HREF="#::getFault"CLASS="Er">::getFault</A>,
<A HREF="#::faultMessageBox"CLASS="Er">::faultMessageBox</A>,
<A HREF="#::faultPrintf"CLASS="Er">::faultPrintf</A>,
and
<A HREF="#::errorCodeString"CLASS="Er">::errorCodeString</A>
services may used to obtain additional
information about the cause of failure.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
The PIXCI&reg; XCLIB  Library and Driver is open
and ready for use.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">xclib</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXERMALLOC<DD>
Memory allocation error.
<BR><DT>PXERNOFILE<DD>
No file named
<EM CLASS="Ep">formatfile</EM>
found.
<BR><DT>PXERFILEFORM<DD>
The file format of
<EM CLASS="Ep">formatfile</EM>
is invalid.
<BR><DT>PXERDOSIO<DD>
Can't read file named
<EM CLASS="Ep">formatfile</EM>.
<BR><DT>PXERSEARCH<DD>
The
<EM CLASS="Ep">formatname</EM>
was invalid.
<BR><DT>PXERVIDFORM<DD>
The
<EM CLASS="Ep">formatname</EM>
was a valid string,
but the specified format is not supported on the current imaging board.
<BR><DT>PXERBADPARM<DD>
The parameters in
<EM CLASS="Ep">driverparms</EM>
are invalid.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxdev.getDevInfo NX581"CLASS="NX"></A>
<A NAME="::pxdev.getDevInfo"CLASS="Sf"></A>
<A NAME="Get Imaging Board and Driver Information NX582"CLASS="NX"></A>
<A NAME="Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo"CLASS="Sf"></A>
<A NAME="Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo"></A>
<H6 CLASS="Sf">Get Imaging Board and Driver Information   ---   ::pxdev.getDevInfo</H6>
<A NAME="::xcdev.getDevInfo NX583"CLASS="NX"></A>
<A NAME="::xcdev.getDevInfo"CLASS="Sg"></A>
<A NAME="Get Extended Imaging Board and Driver Information NX584"CLASS="NX"></A>
<A NAME="Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo"CLASS="Sg"></A>
<A NAME="Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo"></A>
<H6 CLASS="Sg">Get Extended Imaging Board and Driver Information   ---   ::xcdev.getDevInfo</H6>
<A NAME="::getDevInfo"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxdev.getDevInfo) (&amp;pxdev, unitmap, rsvd, pxinfo);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct pxdevinfo    *pxinfo;        // Filled with information
<BR>
int (xcdev.getDevInfo) (&amp;xcdev, unitmap, rsvd, xcinfo);
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct xcdevinfo    *xcinfo;        // Filled with information
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Information about the driver and about the
single selected
<EM CLASS="Ep">unitmap</EM>
imaging board is
''returned''
in the
<EM CLASS="Ep">pxinfo</EM>
instance of the
<A HREF="#pxdevinfo"CLASS="Er">pxdevinfo</A>
structure,
or the
<EM CLASS="Ep">xcinfo</EM>
instance of the
<A HREF="#xcdevinfo"CLASS="Er">xcdevinfo</A>
structure.
<P>
A non-exhaustive list of information provided
includes the imaging board model,
imaging board submodel (if applicable),
imaging board revision level (if applicable),
the number of imaging boards open for use,
the total amount of image frame buffer memory per imaging board,
a driver identification string,
and a library identification string.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">pxinfo</EM>'s
or the
<EM CLASS="Ep">xcinfo</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxdev.getFault NX585"CLASS="NX"></A>
<A NAME="::pxdev.getFault"CLASS="Sf"></A>
<A NAME="Obtain Last Logged Fault NX586"CLASS="NX"></A>
<A NAME="Obtain Last Logged Fault   ---   ::pxdev.getFault"CLASS="Sf"></A>
<A NAME="Obtain Last Logged Fault   ---   ::pxdev.getFault"></A>
<H6 CLASS="Sf">Obtain Last Logged Fault   ---   ::pxdev.getFault</H6>
<A NAME="::getFault"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxdev.getFault) (&amp;pxdev, unitmap, rsvd, fault);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct pxdevfault   *fault;         // Fault information
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::getFault"CLASS="Er">::getFault</A>
checks whether a new fault has occurred since the last check,
and if so
''returns''
the fault information, filling the
<EM CLASS="Ep">fault</EM>
instance of the
<A HREF="#pxdevfault"CLASS="Er">pxdevfault</A>
structure.
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit upon which faults
are checked and displayed.
<P>
Faults are not related to PXER... error codes.
Rather, faults are typically asynchronous events,
such as reporting that the video signal
has been interrupted or corrupted.
Faults are not the error description,
if any, of the last called library function,
with the exception that after
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>
fails, the
<A HREF="#::getFault"CLASS="Er">::getFault</A>
may provide additional information about the cause of failure.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>1<DD>
Information about a new logged fault
has been returned.
<BR><DT>0<DD>
No new logged fault exists, no
information has been returned.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">fault</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::xcdev.getDevParms NX587"CLASS="NX"></A>
<A NAME="::xcdev.getDevParms"CLASS="Sf"></A>
<A NAME="Get Driver Parameters NX588"CLASS="NX"></A>
<A NAME="Get Driver Parameters   ---   ::xcdev.getDevParms"CLASS="Sf"></A>
<A NAME="Get Driver Parameters   ---   ::xcdev.getDevParms"></A>
<H6 CLASS="Sf">Get Driver Parameters   ---   ::xcdev.getDevParms</H6>
<A NAME="::xcdev.setDevParms NX589"CLASS="NX"></A>
<A NAME="::xcdev.setDevParms"CLASS="Sg"></A>
<A NAME="Set Driver Parameters NX590"CLASS="NX"></A>
<A NAME="Set Driver Parameters   ---   ::xcdev.setDevParms"CLASS="Sg"></A>
<A NAME="Set Driver Parameters   ---   ::xcdev.setDevParms"></A>
<H6 CLASS="Sg">Set Driver Parameters   ---   ::xcdev.setDevParms</H6>
<A NAME="::getDevParms"CLASS="Tr"></A>
<A NAME="::setDevParms"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.getDevParms) (&amp;xcdev, unitmap, rsvd, parms);
int (xcdev.setDevParms) (&amp;xcdev, unitmap, rsvd, parms);
<BR>
struct pxdevservice pxdev;          // A pxdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd;           // Reserved, should be 0
struct xcdevparms   devparm;        // Driver configuration parameters
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::getDevParms"CLASS="Er">::getDevParms</A>
returns the current Driver Configuration Parameters
for the single selected
<EM CLASS="Ep">unitmap</EM>
in the
<EM CLASS="Ep">devparm</EM>
instance of the
<A HREF="#xcdevparms"CLASS="Er">xcdevparms</A>
structure.
These are the same parameters as set by the third
argument of
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>,
although expressed as structure fields rather than as a string.
The
<A HREF="#::setDevParms"CLASS="Er">::setDevParms</A>
returns an error; parameters
can't be changed once the driver and imaging board are open for use.
<P>
If the XCLIB has been opened in &quot;-configure&quot; mode (see
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>),
the
<A HREF="#::getDevParms"CLASS="Er">::getDevParms</A>
returns the default Driver Configuration Parameters in the
<EM CLASS="Ep">devparm</EM>
instance of the
<A HREF="#xcdevparms"CLASS="Er">xcdevparms</A>
structure,
and the
<A HREF="#::setDevParms"CLASS="Er">::setDevParms</A>
sets the default Driver Configuration Parameters from
<EM CLASS="Ep">devparm</EM>.
The
<EM CLASS="Ep">unitmap</EM>
is ignored.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">devparm</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="3">
<A NAME="Structured Style Interface - Video Format Configuration Services"CLASS="Ch"></A>
<A NAME="5.  Structured Style Interface - Video Format Configuration Services"></A>
<H1>5.  Structured Style Interface - Video Format Configuration Services</H1>
<P>
The Video Format Configuration &amp; Video State ID services
provide for the manipulation of the Video Format Configuration structures,
and associating a Video Format Configuration with a numeric video state id.
<P>
The
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
is the primary Video Format Configuration structure,
which incorporates several substructures,
<P>
The
<A HREF="#::allocStateCopy"CLASS="Er">::allocStateCopy</A>,
<A HREF="#::compareStateCopy"CLASS="Er">::compareStateCopy</A>,
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>,
<A HREF="#::freeStateCopy"CLASS="Er">::freeStateCopy</A>,
<A HREF="#::importStateCopy"CLASS="Er">::importStateCopy</A>,
and
<A HREF="#::initStateCopy"CLASS="Er">::initStateCopy</A>
services perform off-line manipulation
of Video Format Configuration structures;
their manipulation has no direct effect
on the XCLIB library's or the imaging board's state.
Their names of
''...StateCopy''
are intended to suggest that the
Video Format Configuration structures manipulated
are off-line copies;
not that the
Video Format Configuration structures manipulated
are necessarily copies of any video state in use.
<P>
Other services manipulate
Video Format Configuration structures
in the context of the imaging board in use,
with effect upon the library's state.
<HR SIZE="1">
<A NAME="::pxlib.allocStateCopy NX591"CLASS="NX"></A>
<A NAME="::pxlib.allocStateCopy"CLASS="Sf"></A>
<A NAME="Allocate Copy of Video State NX592"CLASS="NX"></A>
<A NAME="Allocate Copy of Video State   ---   ::pxlib.allocStateCopy"CLASS="Sf"></A>
<A NAME="Allocate Copy of Video State   ---   ::pxlib.allocStateCopy"></A>
<H6 CLASS="Sf">Allocate Copy of Video State   ---   ::pxlib.allocStateCopy</H6>
<A NAME="::pxlib.freeStateCopy NX593"CLASS="NX"></A>
<A NAME="::pxlib.freeStateCopy"CLASS="Sg"></A>
<A NAME="Free Copy of Video State NX594"CLASS="NX"></A>
<A NAME="Free Copy of Video State   ---   ::pxlib.freeStateCopy"CLASS="Sg"></A>
<A NAME="Free Copy of Video State   ---   ::pxlib.freeStateCopy"></A>
<H6 CLASS="Sg">Free Copy of Video State   ---   ::pxlib.freeStateCopy</H6>
<A NAME="::allocStateCopy"CLASS="Tr"></A>
<A NAME="::freeStateCopy"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxlib.allocStateCopy)    (&amp;pxlib, options, stateid, statepp);
int (pxlib.freeStateCopy)     (&amp;pxlib, options, stateid, statepp);
<BR>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statepp;       // Pointer to video state pointer
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::allocStateCopy"CLASS="Er">::allocStateCopy</A>
<CITE CLASS="Ec">malloc</CITE>'s
a set of Video Format Configuration structures.
The
<EM CLASS="Ep">stateid</EM>
is reserved and should be 0.
The
*<EM CLASS="Ep">statepp</EM>
must initially be NULL;
the pointer to the allocated
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure and substructures
is
''returned''
at
*<EM CLASS="Ep">statepp</EM>.
The
''returned''
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure and substructures
are initialized to zero, with the
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
and
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
signatures set.
<P>
The
<A HREF="#::freeStateCopy"CLASS="Er">::freeStateCopy</A>
<CITE CLASS="Ec">free</CITE>'s
a set of previously
<CITE CLASS="Ec">malloc</CITE>'ed
Video Format Configuration structures referenced by
*<EM CLASS="Ep">statepp</EM>.
The
<EM CLASS="Ep">stateid</EM>
is reserved and should be 0.
After
<A HREF="#::freeStateCopy"CLASS="Er">::freeStateCopy</A>,
the
*<EM CLASS="Ep">statepp</EM>
is invalid, set to NULL, and must not be used with any function.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERMALLOC<DD>
Memory allocation error.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxlib.compareStateCopy NX595"CLASS="NX"></A>
<A NAME="::pxlib.compareStateCopy"CLASS="Sf"></A>
<A NAME="Compare Pair of Video State Copies NX596"CLASS="NX"></A>
<A NAME="Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy"CLASS="Sf"></A>
<A NAME="Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy"></A>
<H6 CLASS="Sf">Compare Pair of Video State Copies   ---   ::pxlib.compareStateCopy</H6>
<A NAME="::compareStateCopy"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxlib.compareStateCopy)  (&amp;pxlib, options, stateid, statep, state2p);
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statep;        // Pointer to video state
struct pxvidstate   *state2p;       // Pointer to second video state
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::compareStateCopy"CLASS="Er">::compareStateCopy</A>
compares Video Format Configuration settings
of the Video Format Configurations referenced by the
<EM CLASS="Ep">statep</EM>
and
<EM CLASS="Ep">state2p</EM>
instances of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure.
Value 1 or 0 is returned
if the settings are identical or not identical, respectively.
The
<EM CLASS="Ep">stateid</EM>
is reserved and should be 0.
<P>
The
<A HREF="#::compareStateCopy"CLASS="Er">::compareStateCopy</A>
is not equivalent to a simple
<CITE CLASS="Ec">memcmp</CITE>
of
<EM CLASS="Ep">statep</EM>
and
<EM CLASS="Ep">state2p</EM>;
substructures within each are
referenced by pointers which may point to different
instances of Video Format Configuration substructures.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>1<DD>
The Video Format Configuration
are identical.
<BR><DT>0<DD>
The Video Format Configuration
are not identical.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">statep</EM>'s
or
<EM CLASS="Ep">state2p</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxlib.defineState NX597"CLASS="NX"></A>
<A NAME="::pxlib.defineState"CLASS="Sf"></A>
<A NAME="Define Video State NX598"CLASS="NX"></A>
<A NAME="Define Video State   ---   ::pxlib.defineState"CLASS="Sf"></A>
<A NAME="Define Video State   ---   ::pxlib.defineState"></A>
<H6 CLASS="Sf">Define Video State   ---   ::pxlib.defineState</H6>
<A NAME="::pxlib.deleteState NX599"CLASS="NX"></A>
<A NAME="::pxlib.deleteState"CLASS="Sg"></A>
<A NAME="Delete Video State NX600"CLASS="NX"></A>
<A NAME="Delete Video State   ---   ::pxlib.deleteState"CLASS="Sg"></A>
<A NAME="Delete Video State   ---   ::pxlib.deleteState"></A>
<H6 CLASS="Sg">Delete Video State   ---   ::pxlib.deleteState</H6>
<A NAME="::pxlib.getState NX601"CLASS="NX"></A>
<A NAME="::pxlib.getState"CLASS="Sg"></A>
<A NAME="Get Video State NX602"CLASS="NX"></A>
<A NAME="Get Video State   ---   ::pxlib.getState"CLASS="Sg"></A>
<A NAME="Get Video State   ---   ::pxlib.getState"></A>
<H6 CLASS="Sg">Get Video State   ---   ::pxlib.getState</H6>
<A NAME="::defineState"CLASS="Tr"></A>
<A NAME="::deleteState"CLASS="Tr"></A>
<A NAME="::getState"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxlib.defineState)  (&amp;pxlib, options, stateid, statep);
int (pxlib.deleteState)  (&amp;pxlib, options, stateid, statep);
int (pxlib.getState)     (&amp;pxlib, options, stateid, statep);
<BR>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id
struct pxvidstate   *statep;        // Pointer to video state
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::defineState"CLASS="Er">::defineState</A>
copies and stores the Video Configuration Parameters
contained in the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure,
assigning it a video state id of
<EM CLASS="Ep">stateid</EM>.
The
<EM CLASS="Ep">stateid</EM>
may be an arbitrary integer greater than 0.
After
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
the
<EM CLASS="Ep">statep</EM>
may be
<CITE CLASS="Ec">free</CITE>'ed
or changed without affecting the
Video Configuration Parameters
associated with the
<EM CLASS="Ep">stateid</EM>.
<P>
The
<A HREF="#::deleteState"CLASS="Er">::deleteState</A>
deletes any
Video Configuration Parameters
associated with the
<EM CLASS="Ep">stateid</EM>.
The
<EM CLASS="Ep">statep</EM>
is ignored.
<P>
The
<A HREF="#::getState"CLASS="Er">::getState</A>
retrieves and copies the
Video Configuration Parameters
associated with the
<EM CLASS="Ep">stateid</EM>
into the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure.
<P>
Using
<A HREF="#::defineState"CLASS="Er">::defineState</A>
or
<A HREF="#::deleteState"CLASS="Er">::deleteState</A>
on a video state id already in
use as the current
Video Configuration Parameters
for a video capture or display activity
does not automatically affect
the video capture or display activity.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">statep</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXERMALLOC<DD>
Memory allocation error.
<BR><DT>PXERNOITEM<DD>
The specified
<EM CLASS="Ep">stateid</EM>
was not previously defined (for
<A HREF="#::deleteState"CLASS="Er">::deleteState</A>
and
<A HREF="#::getState"CLASS="Er">::getState</A>).
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxlib.exportStateCopy NX603"CLASS="NX"></A>
<A NAME="::pxlib.exportStateCopy"CLASS="Sf"></A>
<A NAME="Export Copy of Video State NX604"CLASS="NX"></A>
<A NAME="Export Copy of Video State   ---   ::pxlib.exportStateCopy"CLASS="Sf"></A>
<A NAME="Export Copy of Video State   ---   ::pxlib.exportStateCopy"></A>
<H6 CLASS="Sf">Export Copy of Video State   ---   ::pxlib.exportStateCopy</H6>
<A NAME="::pxlib.importStateCopy NX605"CLASS="NX"></A>
<A NAME="::pxlib.importStateCopy"CLASS="Sg"></A>
<A NAME="Import Copy of Video State NX606"CLASS="NX"></A>
<A NAME="Import Copy of Video State   ---   ::pxlib.importStateCopy"CLASS="Sg"></A>
<A NAME="Import Copy of Video State   ---   ::pxlib.importStateCopy"></A>
<H6 CLASS="Sg">Import Copy of Video State   ---   ::pxlib.importStateCopy</H6>
<A NAME="::exportStateCopy"CLASS="Tr"></A>
<A NAME="::importStateCopy"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxlib.exportStateCopy)(&amp;pxlib, options, stateid, statep, stateindex, pathname, filemode,
                            progname, filecomment);
int (pxlib.importStateCopy)(&amp;pxlib, options, stateid, statep, stateindex, pathname, filemode);
<BR>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id
struct pxvidstate   *statep;        // Pointer to video state
int                 stateindex;     // Index into file
char                *pathname;      // File path and name
char                *filemode;      // File open mode, or NULL
char                *progname;      // Optional name of program
char                *filecomment;   // Optional additional comment
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>
exports the Video Format Configuration settings
contained in the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure
to a file in a format compatible with
<A HREF="#::importStateCopy"CLASS="Er">::importStateCopy</A>
and with the
<CITE CLASS="Ec">XCAP</CITE>
application (using the same version of libraries).
<P>
The
<EM CLASS="Ep">::importStateCopy</EM>
imports one set of Video Format Configuration settings
into the provided
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure.
<P>
The
<EM CLASS="Ep">pathname</EM>
specifies the file's path name.<A HREF="#Footnote 31"CLASS="Ff"><SUP>[31]</SUP></A>
The
<EM CLASS="Ep">filemode</EM>
specifies the file's
<CITE CLASS="Ec">fopen</CITE>
mode, or may be NULL for default.
For
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>
and the default
<EM CLASS="Ep">filemode</EM>,
any existing file
<EM CLASS="Ep">pathname</EM>
is deleted and a new file
<EM CLASS="Ep">pathname</EM>
created.
<P>
For
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>,
the optional
<EM CLASS="Ep">progname</EM>
and
<EM CLASS="Ep">filecomment</EM>
provide text for comments to be written into the file.
The
<EM CLASS="Ep">stateindex</EM>
is reserved and should be 0.
The
<EM CLASS="Ep">stateid</EM>
is an arbitrary, non-zero, numeric state identification
which distinguishes the Video Format Configuration settings
from others in the same file.
It does NOT necessarily reference a video state id
currently defined in the library.
<P>
For
<A HREF="#::importStateCopy"CLASS="Er">::importStateCopy</A>,
the
<EM CLASS="Ep">pathname</EM>
may contain multiple Video Format Configurations.
If
<EM CLASS="Ep">stateid</EM>&gt;0,
a Video Format Configuration previously
saved with the same
<EM CLASS="Ep">stateid</EM>
is imported.
<EM CLASS="Ep">stateid</EM>&lt;0,
the
<EM CLASS="Ep">stateindex</EM>'th
sequential Video Format Configuration in the
<EM CLASS="Ep">pathname</EM>
is imported;
where the
<EM CLASS="Ep">stateindex</EM>
is 1 for the first, 2 for the second, etc.
The
<EM CLASS="Ep">stateid</EM>
does NOT necessarily reference a video state id
currently defined in the library.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>9999<DD>
A complete set of Video Format Configuration
structures and substructures imported (for
<A HREF="#::importVideoState"CLASS="Er">::importVideoState</A>).
<BR><DT>&ge;0<DD>
The number of Video Format Configuration
substructures imported (for
<A HREF="#::importVideoState"CLASS="Er">::importVideoState</A>).
<BR><DT>0<DD>
Operation complete (for
<A HREF="#::exportVideoState"CLASS="Er">::exportVideoState</A>).
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">statep</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXERNOFILE<DD>
File can't be read (for
<A HREF="#::importVideoState"CLASS="Er">::importVideoState</A>).
<BR><DT>PXERNEWFILE<DD>
File can't be created or written (for
<A HREF="#::exportVideoState"CLASS="Er">::exportVideoState</A>).
<BR><DT>PXERFILEFORM<DD>
The file format is invalid.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::xclib.fixxStateCopy NX607"CLASS="NX"></A>
<A NAME="::xclib.fixxStateCopy"CLASS="Sf"></A>
<A NAME="Fixup Video State NX608"CLASS="NX"></A>
<A NAME="Fixup Video State   ---   ::xclib.fixxStateCopy"CLASS="Sf"></A>
<A NAME="Fixup Video State   ---   ::xclib.fixxStateCopy"></A>
<H6 CLASS="Sf">Fixup Video State   ---   ::xclib.fixxStateCopy</H6>
<A NAME="::xclib.fillStateCopy NX609"CLASS="NX"></A>
<A NAME="::xclib.fillStateCopy"CLASS="Sg"></A>
<A NAME="Fill Video State NX610"CLASS="NX"></A>
<A NAME="Fill Video State   ---   ::xclib.fillStateCopy"CLASS="Sg"></A>
<A NAME="Fill Video State   ---   ::xclib.fillStateCopy"></A>
<H6 CLASS="Sg">Fill Video State   ---   ::xclib.fillStateCopy</H6>
<A NAME="::xclib.signStateCopy NX611"CLASS="NX"></A>
<A NAME="::xclib.signStateCopy"CLASS="Sg"></A>
<A NAME="Sign Video State NX612"CLASS="NX"></A>
<A NAME="Sign Video State   ---   ::xclib.signStateCopy"CLASS="Sg"></A>
<A NAME="Sign Video State   ---   ::xclib.signStateCopy"></A>
<H6 CLASS="Sg">Sign Video State   ---   ::xclib.signStateCopy</H6>
<A NAME="::fixxStateCopy"CLASS="Tr"></A>
<A NAME="::fillStateCopy"CLASS="Tr"></A>
<A NAME="::signStateCopy"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xclib.fixxStateCopy)  (&amp;xclib, options, stateid, statep);
int (xclib.fillStateCopy)  (&amp;xclib, options, stateid, statep, buffer);
int (xclib.signStateCopy)  (&amp;xclib, options, stateid, statep, adrsspace, mode);
<BR>
struct xclibservice xclib;          // A xclibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statep;        // Pointer to video state
pxbuffer_t          buffer;         // Image frame buffer
<BR>
int                 mode;           // 's': sign, 'c': check signature, 'r': get adrsspace
int                 adrsspace;      // 'i': image frame buffer memory
                                    // 'p': physical memory
                                    // 'u': application memory
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::fixxStateCopy"CLASS="Er">::fixxStateCopy</A>
normalizes
the Video Configuration Parameters referenced by the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure.
The
Video Configuration Parameters
are normalized to be internally consistent
(typically by reference to the contents
of the
<A HREF="#pxvidformat"CLASS="Er">pxvidformat</A>
structure),
and to be consistent with the capabilities
of the current imaging board.
<P>
The
<A HREF="#::fillStateCopy"CLASS="Er">::fillStateCopy</A>
fills the
<A HREF="#pxvidphys"CLASS="Er">pxvidphys</A>
structure of the
Video Configuration Parameters
to refer to image frame buffer number
<EM CLASS="Ep">buffer</EM>,
<EM CLASS="Ep">buffer</EM>&ge;1,
within the imaging board's frame buffer memory.
<P>
The
<A HREF="#::signStateCopy"CLASS="Er">::signStateCopy</A>
signs the
<A HREF="#pxvidphys"CLASS="Er">pxvidphys</A>
structure of the
Video Configuration Parameters
as containing valid addresses
which refer to memory other than the
image frame buffer memory,
or checks whether the
<A HREF="#pxvidphys"CLASS="Er">pxvidphys</A>
structure of the Video Configuration Parameters
is properly signed.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
In particular, for
<A HREF="#::fillStateCopy"CLASS="Er">::fillStateCopy</A>,
a
<EM CLASS="Ep">buffer</EM>
which is less than one or greater than
the number of buffers which fit within
frame buffer memory.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">statep</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxlib.initStateCopy NX613"CLASS="NX"></A>
<A NAME="::pxlib.initStateCopy"CLASS="Sf"></A>
<A NAME="Set Default Configuration Copy of Video State NX614"CLASS="NX"></A>
<A NAME="Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy"CLASS="Sf"></A>
<A NAME="Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy"></A>
<H6 CLASS="Sf">Set Default Configuration Copy of Video State   ---   ::pxlib.initStateCopy</H6>
<A NAME="::compareStateCopy"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxlib.initStateCopy)     (&amp;pxlib, options, stateid, statep, infop, formatname, vidmode);
<BR>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 stateid;        // Video state id, should be 0
struct pxvidstate   *statep;        // Pointer to video state
struct pxdevinfo    *info;          // Description of imaging board
char                *formatname;    // A predefined name of video format
int                 vidmode;        // A PXMODE_ value
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::initStateCopy"CLASS="Er">::initStateCopy</A>
initializes the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure
to the default Video Configuration Parameters
appropriate to the imaging board described in
<EM CLASS="Ep">info</EM>,
with the
<EM CLASS="Ep">formatname</EM>
predefined name of a
standard video configuration format,
and suitable to an activity
specified by
<EM CLASS="Ep">vidmode.</EM>
<P>
The
<EM CLASS="Ep">info</EM>
for the current imaging board may be obtained from
<A HREF="#::getDevInfo"CLASS="Er">::getDevInfo</A>.
The allowable predefined names
of standard video configuration format
are described in
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>.
The
<EM CLASS="Ep">vidmode</EM>
is a PXMODE_ type value,
such as PXMODE_DIGI to indicate that the
Video Configuration Parameters are to be used for capturing.
<BR>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">statep</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXERSEARCH<DD>
The
<EM CLASS="Ep">formatname</EM>
was invalid.
<BR><DT>PXERVIDFORM<DD>
The
<EM CLASS="Ep">formatname</EM>
is a valid string,
but the specified format is not supported on the imaging board
described by
<EM CLASS="Ep">info</EM>.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="xclib_DeclareVidStateStructs NX615"CLASS="NX"></A>
<A NAME="xclib_DeclareVidStateStructs"CLASS="Sf"></A>
<A NAME="Declare Instance of Video Format Configuration Structures NX616"CLASS="NX"></A>
<A NAME="Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs"CLASS="Sf"></A>
<A NAME="Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs"></A>
<H6 CLASS="Sf">Declare Instance of Video Format Configuration Structures   ---   xclib_DeclareVidStateStructs</H6>
<A NAME="xclib_InitVidStateStructs NX617"CLASS="NX"></A>
<A NAME="xclib_InitVidStateStructs"CLASS="Sg"></A>
<A NAME="Initialize Instance of Video Format Configuration Structures NX618"CLASS="NX"></A>
<A NAME="Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs"CLASS="Sg"></A>
<A NAME="Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs"></A>
<H6 CLASS="Sg">Initialize Instance of Video Format Configuration Structures   ---   xclib_InitVidStateStructs</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
#define xclib_DeclareVidStateStructs(Name)
#define xclib_InitVidStateStruct(Name)
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#xclib_DeclareVidStateStructs"CLASS="Er">xclib_DeclareVidStateStructs</A>
macro declares a instance of a
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure named
<EM CLASS="Ep">Name</EM>,
and all of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
substructures with decorated names starting with
<EM CLASS="Ep">Name</EM>.
<P>
The
<A HREF="#xclib_InitVidStateStruct"CLASS="Er">xclib_InitVidStateStruct</A>
initializes the structures previously declared by
<A HREF="#xclib_DeclareVidStateStructs"CLASS="Er">xclib_DeclareVidStateStructs</A>,
setting the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
fields to point its substructures,
and setting the
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
and
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
structure signatures.
<P>
These macros provide only C/C++
declaration and initialization
of structures; there is no effect
on the XCLIB library's or the imaging board's state.
<HR SIZE="3">
<A NAME="Structured Style Interface - Memory Access Services"CLASS="Ch"></A>
<A NAME="6.  Structured Style Interface - Memory Access Services"></A>
<H1>6.  Structured Style Interface - Memory Access Services</H1>
<P>
The Memory Access services
provide several methods of accessing image data
or other memory associated with the imaging board.
<P>
The
<A HREF="#::initPximage"CLASS="Er">::initPximage</A>,
<A HREF="#::initPximage3"CLASS="Er">::initPximage3</A>,
<A HREF="#::initFilteredPximage"CLASS="Er">::initFilteredPximage</A>,
and
<A HREF="#::initFilteredPximage3"CLASS="Er">::initFilteredPximage3</A>,
are the suggested services for accessing imaging board memory.
Use of the low level
<A HREF="#::io"CLASS="Er">::io</A>,
<A HREF="#::getImap"CLASS="Er">::getImap</A>,
and
<A HREF="#::freeImap"CLASS="Er">::freeImap</A>
services should be minimized.
<HR SIZE="1">
<A NAME="::pxdev.getImap NX619"CLASS="NX"></A>
<A NAME="::pxdev.getImap"CLASS="Sf"></A>
<A NAME="Obtain Pointer into Imaging Board Memory NX620"CLASS="NX"></A>
<A NAME="Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap"CLASS="Sf"></A>
<A NAME="Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap"></A>
<H6 CLASS="Sf">Obtain Pointer into Imaging Board Memory   ---   ::pxdev.getImap</H6>
<A NAME="::pxdev.freeImap NX621"CLASS="NX"></A>
<A NAME="::pxdev.freeImap"CLASS="Sg"></A>
<A NAME="Free Pointer into Imaging Board Memory NX622"CLASS="NX"></A>
<A NAME="Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap"CLASS="Sg"></A>
<A NAME="Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap"></A>
<H6 CLASS="Sg">Free Pointer into Imaging Board Memory   ---   ::pxdev.freeImap</H6>
<A NAME="::getImap"CLASS="Tr"></A>
<A NAME="::freeImap"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxdev.getImap)  (pxdevservice_s *me, options, unitmap, adrs, altspace, accessptr, accesslen);
int (pxdev.freeImap) (pxdevservice_s *me, options, unitmap, adrs, altspace, accessptr, accesslen);
<BR>
struct pxdevservice pxdev;          // A pxdevservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint32              adrs;           // Address of imaging board memory
uint                altspace;       // 0: image frame buffer memory
uchar _farimap      **accessptr;    // Returned pointer to imaging board memory address
ulong               *accesslen;     // Returned access length, may be NULL
                                    // _farimap is a predefined adjective:
                                    //    &lt;blank&gt;  [in Win 95/98/ME/NT/2000/XP environments]
                                    //    _far     [in DOS+Tenberry environments]
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::getImap"CLASS="Er">::getImap</A>
obtains and returns a pointer into memory associated
with the imaging board, if available.
The
<A HREF="#::freeImap"CLASS="Er">::freeImap</A>
frees a pointer previously obtained with
<A HREF="#::getImap"CLASS="Er">::getImap</A>.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit
to which a pointer is to be obtained.
The
<EM CLASS="Ep">adrs</EM>
specifies the zero based address
within the imaging board memory.
The
<EM CLASS="Ep">altspace</EM>=0
selects the image frame buffer memory.
<P>
If a pointer to the requested memory can be obtained,
the pointer is
''returned''
at
*<EM CLASS="Ep">accessptr</EM>,
and the length in bytes for which
the pointer is valid is
''returned''
at
*<EM CLASS="Ep">accesslen</EM>.
The
<EM CLASS="Ep">accesslen</EM>
may be NULL; no length information is returned.
<P>
The
*<EM CLASS="Ep">accessptr</EM>
and
*<EM CLASS="Ep">accesslen</EM>
allows accessing a range of memory
without additional use of
<A HREF="#::getImap"CLASS="Er">::getImap</A>;
the bytes of imaging board memory from
<EM CLASS="Ep">adrs</EM>
through
<EM CLASS="Ep">adrs</EM>+<EM CLASS="Ep">accesslen</EM>-1
can be accessed by using
*<EM CLASS="Ep">accessptr</EM>
through
*<EM CLASS="Ep">accessptr</EM>+<EM CLASS="Ep">accesslen</EM>-1.
<P>
The availability of a direct pointer into imaging board memory
varies with the type of imaging board, the state of the imaging board,
the current operating system,
and the current Driver Configuration Parameters.
<P>
Under Windows 95/98/ME/NT/2000/XP:
The access pointer
provided by
<A HREF="#::getImap"CLASS="Er">::getImap</A>
can be used by the application to access imaging board memory,
but cannot be passed to other applications or to system
services such as file I/O.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxlib.initPximage NX623"CLASS="NX"></A>
<A NAME="::pxlib.initPximage"CLASS="Sf"></A>
<A NAME="Obtain pximage Access into Imaging Board Memory NX624"CLASS="NX"></A>
<A NAME="Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage"CLASS="Sf"></A>
<A NAME="Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage"></A>
<H6 CLASS="Sf">Obtain pximage Access into Imaging Board Memory   ---   ::pxlib.initPximage</H6>
<A NAME="::pxlib.initPximage3 NX625"CLASS="NX"></A>
<A NAME="::pxlib.initPximage3"CLASS="Sg"></A>
<A NAME="Obtain pximage3 Access into Imaging Board Memory NX626"CLASS="NX"></A>
<A NAME="Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3"CLASS="Sg"></A>
<A NAME="Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3"></A>
<H6 CLASS="Sg">Obtain pximage3 Access into Imaging Board Memory   ---   ::pxlib.initPximage3</H6>
<A NAME="::pxlib.initFilteredPximage NX627"CLASS="NX"></A>
<A NAME="::pxlib.initFilteredPximage"CLASS="Sg"></A>
<A NAME="Obtain Filtered pximage Access into Imaging Board Memory NX628"CLASS="NX"></A>
<A NAME="Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage"CLASS="Sg"></A>
<A NAME="Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage"></A>
<H6 CLASS="Sg">Obtain Filtered pximage Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage</H6>
<A NAME="::pxlib.initFilteredPximage3 NX629"CLASS="NX"></A>
<A NAME="::pxlib.initFilteredPximage3"CLASS="Sg"></A>
<A NAME="Obtain Filtered pximage3 Access into Imaging Board Memory NX630"CLASS="NX"></A>
<A NAME="Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3"CLASS="Sg"></A>
<A NAME="Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3"></A>
<H6 CLASS="Sg">Obtain Filtered pximage3 Access into Imaging Board Memory   ---   ::pxlib.initFilteredPximage3</H6>
<A NAME="::initPximage"CLASS="Tr"></A>
<A NAME="::initPximage3"CLASS="Tr"></A>
<A NAME="::initFilteredPximage"CLASS="Tr"></A>
<A NAME="::initFilteredPximage3"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxlib.initPximage)         (&amp;pxlib, unitmap, ip,  ipcnt, colorhint, altspace, stateid,
                                 framebuf, mbpcihint);
int (pxlib.initPximage3)        (&amp;pxlib, unitmap, ip3, ipcnt, colorhint, altspace, stateid,
                                 unused,   mbpcihint);
int (pxlib.initFilteredPximage) (&amp;pxlib, unitmap, ip,  ipcnt, colorhint, altspace, stateid,
                                 framebuf, mbpcihint, colormap);
int (pxlib.initFilteredPximage3)(&amp;pxlib, unitmap, ip3, ipcnt, colorhint, altspace, stateid,
                                 unused,   mbpcihint, colormap);
<BR>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
struct pximage      ip[];           // Array of pximage's
struct pximage      ip3[];          // Array of pximage3's
int                 ipcnt;          // Dimension of ip or ip3
int                 colorhint;      // Requested color representation
uint                altspace;       // 0: image frame buffer memory
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
int                 mbpcihint;      // Reserved, should be 0
int                 colormap;       // Pixel value component selection
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
A
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>
is initialized so as to provide access
to the imaging board's frame buffers,
or to other memory associated with the imaging board.
The
<A HREF="#::initPximage"CLASS="Er">::initPximage</A>
provides access to a single image frame buffers,
in the color space(s) directly obtainable
from the image frame buffer.
The
<A HREF="#::initPximage3"CLASS="Er">::initPximage3</A>
provides access to a sequence of all image frame buffers,
in the color space(s) directly obtainable
from the image frame buffer.
The
<A HREF="#::initFilteredPximage"CLASS="Er">::initFilteredPximage</A>
and
<A HREF="#::initFilteredPximage3"CLASS="Er">::initFilteredPximage3</A>
are similar, but initializes additional
conversions, as needed, to provide
any supported color space interpretation
of the image frame buffers.
<P>
These services initialize the
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>
structures provided;
thereafter these structures
can be used to access
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>
services.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit
to which access is to be provided.
The
<EM CLASS="Ep">stateid</EM>
specifies a video state id
previously defined by
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
against which the
<EM CLASS="Ep">framebuf</EM>
is interpreted.
<P>
The
<EM CLASS="Ep">ip</EM>
or
<EM CLASS="Ep">ip3</EM>
specify instances of an array of
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>
structures;
the
<EM CLASS="Ep">ipcnt</EM>
specifies the number of structures provided.
In the worst case,
<A HREF="#::initPximage"CLASS="Er">::initPximage</A>
and
<A HREF="#::initPximage3"CLASS="Er">::initPximage3</A>
may require
<EM CLASS="Ep">ipcnt</EM>=PXMAX_IRBGF,
<A HREF="#::initFilteredPximage"CLASS="Er">::initFilteredPximage</A>
and
<A HREF="#::initFilteredPximage3"CLASS="Er">::initFilteredPximage3</A>
may require
<EM CLASS="Ep">ipcnt</EM>=PXMAX_FIRBGF.
<P>
The
<EM CLASS="Ep">colorhint</EM>
is a PXHINT...
type value specifying the desired color space.
The
<EM CLASS="Ep">colorhint</EM>
may not be available; the
<EM CLASS="Ep">ip</EM>
or
<EM CLASS="Ep">ip3</EM>
may be initialized so as to access the image frame buffers
with a different color space.
More
<EM CLASS="Ep">colorhint</EM>'s
are available through use of
<A HREF="#::initFilteredPximage"CLASS="Er">::initFilteredPximage</A>
and
<A HREF="#::initFilteredPximage3"CLASS="Er">::initFilteredPximage3</A>
instead of
<A HREF="#::initPximage"CLASS="Er">::initPximage</A>
and
<A HREF="#::initPximage3"CLASS="Er">::initPximage3</A>.
<P>
For
<A HREF="#::initFilteredPximage"CLASS="Er">::initFilteredPximage</A>
and
<A HREF="#::initFilteredPximage3"CLASS="Er">::initFilteredPximage3</A>,
the
<EM CLASS="Ep">colormap</EM>
selects which color component values are to be accessed.
The
<EM CLASS="Ep">colormap</EM>
is a bit-map; the i'th
bit selects the i'th color component.
<P>
If
<EM CLASS="Ep">altspace</EM>=0,
access is provided to image frame buffers.
For PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, SI, and A imaging boards,
using
<EM CLASS="Ep">altspace</EM>=(('t'&lt;&lt;8)|'s')
provides access to the four byte video field counter
attached to each captured frame buffer.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>&ge;1<DD>
Operation complete.
The return value indicates the
number of
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>
structures used.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERMORESPACE<DD>
There are insufficient
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>
structures to provide access.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxdev.io NX631"CLASS="NX"></A>
<A NAME="::pxdev.io"CLASS="Sf"></A>
<A NAME="Read/Write Imaging Board Memory NX632"CLASS="NX"></A>
<A NAME="Read/Write Imaging Board Memory   ---   ::pxdev.io"CLASS="Sf"></A>
<A NAME="Read/Write Imaging Board Memory   ---   ::pxdev.io"></A>
<H6 CLASS="Sf">Read/Write Imaging Board Memory   ---   ::pxdev.io</H6>
<A NAME="::io"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxdev.io) (&amp;pxdev, options, unitmap, adrs, altspace, buf, cnt, rw, async, time);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint32              adrs;           // Address of imaging board memory
uint                altspace;       // 0: image frame buffer memory
void                *buf;           // Application program buffer
uint                cnt;            // Transfer count, bytes
uint                rw;             // PXREAD: Copy into program buffer
                                    // PXRITE: Copy from program buffer
pxasync_s           *async;         // Reserved, should be NULL
pxtimespec_s        *time;          // Reserved, should be NULL
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The contents of imaging board memory
is copied to or from an array or buffer provided
by the application.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit
from which memory is to be copied.
The
<EM CLASS="Ep">adrs</EM>
specifies the zero based address
within the imaging board memory.
The
<EM CLASS="Ep">altspace</EM>=0
selects the image frame buffer memory.
The
<EM CLASS="Ep">buf</EM>
specifies an array or buffer provided by the application.
The
<EM CLASS="Ep">cnt</EM>
specifies the number of bytes to be read or written.
The
<EM CLASS="Ep">rw</EM>=PXREAD
chooses read of the imaging board memory
into the
*<EM CLASS="Ep">buf</EM>;
<EM CLASS="Ep">rw</EM>=PXRITE
chooses write of the imaging board memory
from the
*<EM CLASS="Ep">buf</EM>;
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="3">
<A NAME="Structured Style Interface - Video Services"CLASS="Ch"></A>
<A NAME="7.  Structured Style Interface - Video Services"></A>
<H1>7.  Structured Style Interface - Video Services</H1>
<P>
<HR SIZE="1">
<A NAME="::xcdev.getLiveStatus NX633"CLASS="NX"></A>
<A NAME="::xcdev.getLiveStatus"CLASS="Sf"></A>
<A NAME="Get Live/Snap Status NX634"CLASS="NX"></A>
<A NAME="Get Live/Snap Status   ---   ::xcdev.getLiveStatus"CLASS="Sf"></A>
<A NAME="Get Live/Snap Status   ---   ::xcdev.getLiveStatus"></A>
<H6 CLASS="Sf">Get Live/Snap Status   ---   ::xcdev.getLiveStatus</H6>
<A NAME="::getLiveStatus"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.getLiveStatus) (&amp;xcdev, unitmap, rsvd1, mode);
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 mode;           // Status to check
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The status of the current video snap or live
modes initiated by
<A HREF="#::setSnapBuf"CLASS="Er">::setSnapBuf</A>,
<A HREF="#::setSnapPairBuf"CLASS="Er">::setSnapPairBuf</A>,
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>,
<A HREF="#::setLivePairBuf"CLASS="Er">::setLivePairBuf</A>,
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>,
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>,
<A HREF="#::setLivePhys"CLASS="Er">::setLivePhys</A>,
<A HREF="#::setUnLive"CLASS="Er">::setUnLive</A>,
or
<A HREF="#::setAbortLive"CLASS="Er">::setAbortLive</A>
is returned.
<P>
The
<EM CLASS="Ep">mode</EM>
specifies the status to be returned.
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
mode                            
</TD>
<TD ALIGN="left" COLSPAN="1">
 status returned
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_QUEUED | PXVIST_STATEID  
</TD>
<TD ALIGN="left" COLSPAN="1">
 video state id in queue for captured
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_QUEUED | PXVIST_BUFFER   
</TD>
<TD ALIGN="left" COLSPAN="1">
 image frame buffer in queue for captured
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_QUEUED | PXVIST_VIDMODE  
</TD>
<TD ALIGN="left" COLSPAN="1">
 video mode (PXMODE...) in queue for captured
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_RUNNING | PXVIST_STATEID 
</TD>
<TD ALIGN="left" COLSPAN="1">
 video state id now being captured
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_RUNNING | PXVIST_BUFFER  
</TD>
<TD ALIGN="left" COLSPAN="1">
 image frame buffer now being captured
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_RUNNING | PXVIST_VIDMODE 
</TD>
<TD ALIGN="left" COLSPAN="1">
 video mode (PXMODE...) now being captured
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_DONE | PXVIST_STATEID    
</TD>
<TD ALIGN="left" COLSPAN="1">
 video state id of last captured buffer
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_DONE | PXVIST_BUFFER     
</TD>
<TD ALIGN="left" COLSPAN="1">
 image frame buffer of last captured buffer
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_DONE | PXVIST_VIDMODE    
</TD>
<TD ALIGN="left" COLSPAN="1">
 video mode (PXMODE...) of last captured buffer
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_DONE | PXVIST_VCNT       
</TD>
<TD ALIGN="left" COLSPAN="1">
 video field count of last captured buffer
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_DONE | PXVIST_SYSTICKS0  
</TD>
<TD ALIGN="left" COLSPAN="1">
 low uint of system time of last captured buffer
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXVIST_DONE | PXVIST_SYSTICKS1  
</TD>
<TD ALIGN="left" COLSPAN="1">
 high uint of system time of last captured buffer<A HREF="#Footnote 32"CLASS="Ff"><SUP>[32]</SUP></A>
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
With
<EM CLASS="Ep">mode</EM>=PXVIST_DONE|PXVIST_SYSTICKS0
and
<EM CLASS="Ep">mode</EM>=PXVIST_DONE|PXVIST_SYSTICKS1
the return value should be interpreted as,
and cast to, a
''uint''.
The return value is 0 if the status request does not apply,
such as using PXVIST_RUNNING|PXVIST_STATEID
when the imaging board is done capturing.
<P>
The
<EM CLASS="Ep">::getLiveStatus</EM>
normally obtains the status of the
single unit selected by
<EM CLASS="Ep">unitmap</EM>.
If the
<EM CLASS="Ep">mode</EM>
is OR'ed with PXVIST_ORUNITS,
<EM CLASS="Ep">::getLiveStatus</EM>
obtains the status of the
multiple units selected by
<EM CLASS="Ep">unitmap</EM>;
OR'ing the individual status of each unit together
and returning the result.
This, combined with the default return value of 0
when the status request does not apply,
allows checking whether all units have completed
a snap or live operation with a single invocation.
<P>
The differentiation and exact timing of whether
or when an imaging board's status qualifies for
PXVIST_RUNNING or for PXVIST_QUEUED
is imaging board dependent.
For example, when
<A HREF="#::setSnapBuf"CLASS="Er">::setSnapBuf</A>
is issued, and before the start of the next video frame
arrives, the pending request might considered either
PXVIST_RUNNING or PXVIST_QUEUED.
Similarly, after issuing
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>
and continuously capturing into a single buffer,
during the blanking period between frames
the PXVIST_RUNNING modes may return zero.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
Returns video status.
Also may return PXER... codes.
<HR SIZE="1">
<A NAME="::pxdev.getVidStatus NX635"CLASS="NX"></A>
<A NAME="::pxdev.getVidStatus"CLASS="Sf"></A>
<A NAME="Get Current Video Status NX636"CLASS="NX"></A>
<A NAME="Get Current Video Status   ---   ::pxdev.getVidStatus"CLASS="Sf"></A>
<A NAME="Get Current Video Status   ---   ::pxdev.getVidStatus"></A>
<H6 CLASS="Sf">Get Current Video Status   ---   ::pxdev.getVidStatus</H6>
<A NAME="::xcdev.getVidStatus NX637"CLASS="NX"></A>
<A NAME="::xcdev.getVidStatus"CLASS="Sg"></A>
<A NAME="Get Extended Video Status NX638"CLASS="NX"></A>
<A NAME="Get Extended Video Status   ---   ::xcdev.getVidStatus"CLASS="Sg"></A>
<A NAME="Get Extended Video Status   ---   ::xcdev.getVidStatus"></A>
<H6 CLASS="Sg">Get Extended Video Status   ---   ::xcdev.getVidStatus</H6>
<A NAME="::pxdev.getVidStatusValue NX639"CLASS="NX"></A>
<A NAME="::pxdev.getVidStatusValue"CLASS="Sg"></A>
<A NAME="Get Current Video Status Value NX640"CLASS="NX"></A>
<A NAME="Get Current Video Status Value   ---   ::pxdev.getVidStatusValue"CLASS="Sg"></A>
<A NAME="Get Current Video Status Value   ---   ::pxdev.getVidStatusValue"></A>
<H6 CLASS="Sg">Get Current Video Status Value   ---   ::pxdev.getVidStatusValue</H6>
<A NAME="::getVidStatus"CLASS="Tr"></A>
<A NAME="::getVidStatusValue"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    (pxdev.getVidStatus)      (&amp;pxdev, unitmap, rsvd1, pxstatus, mode);
int    (xcdev.getVidStatus)      (&amp;xcdev, unitmap, rsvd1, xcstatus, mode);
uint32 (pxdev.getVidStatusValue) (&amp;pxdev, unitmap, rsvd1, mode, offset);
<BR>
struct pxdevservice pxdev;          // A pxdevservice instance
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 mode;           // Selection mode
struct pxvidstatus  *pxstatus;      // Video status
struct pxvidstatus  *xcstatus;      // Extended video status
uint                offset;         // Offset to single value in pxvidstats
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::pxdev.getVidStatus"CLASS="Er">::pxdev.getVidStatus</A>
obtains the current video status
of the single imaging board selected by
<EM CLASS="Ep">unitmap</EM>,
''returning''
the status in the
<EM CLASS="Ep">pxstatus</EM>
instance of the
<A HREF="#pxvidstatus"CLASS="Er">pxvidstatus</A>
structure.
<P>
The
<A HREF="#::xcdev.getVidStatus"CLASS="Er">::xcdev.getVidStatus</A>
obtains the current extended video status
of the single imaging board selected by
<EM CLASS="Ep">unitmap</EM>,
''returning''
the status in the
<EM CLASS="Ep">xcstatus</EM>
instance of the
<A HREF="#xcvidstatus"CLASS="Er">xcvidstatus</A>
structure.
<P>
The
<A HREF="#::getVidStatusValue"CLASS="Er">::getVidStatusValue</A>
returns one
''uint32''
value of the current video status
of the single imaging board selected by
<EM CLASS="Ep">unitmap</EM>,
avoiding having to transfer an entire structure
in order to observe one value.
The most common use is to obtain the current video field
count:
<BLOCKQUOTE>
<PRE>
    xclib.pxdev.getVidStatusValue(&amp;xclibs.pxdev, 1, 0, PXSTAT_LASTIRQ, Offset(pxvidstatus2, time.vcnt));
</PRE>
</BLOCKQUOTE>
where the
<CITE CLASS="Ec">Offset</CITE>
macro is defined in the C/C++ library.
<P>
If
<EM CLASS="Ep">mode</EM>=PXSTAT_LASTIRQ,
the video status returned is as of the last interrupt,
regardless of the interrupt's cause.
If
<EM CLASS="Ep">mode</EM>=PXSTAT_LASTVSP,
the video status returned is as of the last
Vertical Switch Point interrupt;
typically the start or end (imaging board dependent)
of vertical drive at which a
''switch''
of capture video status is performed.
If
<EM CLASS="Ep">mode</EM>=PXSTAT_UPDATED,
the video status returned is that as of the instant
of execution of
<A HREF="#::pxdev.getVidStatus"CLASS="Er">::pxdev.getVidStatus</A>,
<A HREF="#::xcdev.getVidStatus"CLASS="Er">::xcdev.getVidStatus</A>,
or
<A HREF="#::getVidStatusValue"CLASS="Er">::getVidStatusValue</A>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
For
<A HREF="#::pxdev.getVidStatus"CLASS="Er">::pxdev.getVidStatus</A>
and
<A HREF="#::xcdev.getVidStatus"CLASS="Er">::xcdev.getVidStatus</A>:
<DL>
<BR><DT>0<DD>
Operation complete
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<P>
The
<A HREF="#::getVidStatusValue"CLASS="Er">::getVidStatusValue</A>
returns the requested value, or a
PXER... code cast to a uint32.
<HR SIZE="1">
<A NAME="::pxlib.goingBufStatus NX641"CLASS="NX"></A>
<A NAME="::pxlib.goingBufStatus"CLASS="Sf"></A>
<A NAME="Get Current Buffer Status NX642"CLASS="NX"></A>
<A NAME="Get Current Buffer Status   ---   ::pxlib.goingBufStatus"CLASS="Sf"></A>
<A NAME="Get Current Buffer Status   ---   ::pxlib.goingBufStatus"></A>
<H6 CLASS="Sf">Get Current Buffer Status   ---   ::pxlib.goingBufStatus</H6>
<A NAME="::goingBufStatus&quot;"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int    (pxlib.goingBufStatus)    (&amp;pxlib, options, unitmap, buffer, status);
<BR>
struct pxlibservice pxlib;          // A pxlibservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
pxbuffer_t          buffer;         // Image frame buffer
int                 mode;           // Selection mode
struct pxbufstatus *status;         // Buffer status
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::pxlib.goingBufStatus"CLASS="Er">::pxlib.goingBufStatus</A>
obtains the status of image frame
<EM CLASS="Ep">buffer</EM>
of the single imaging board selected by
<EM CLASS="Ep">unitmap</EM>,
''returning''
the status in the
<EM CLASS="Ep">status</EM>
instance of the
<A HREF="#pxbufstatus"CLASS="Er">pxbufstatus</A>
structure.
<P>
Some of the status information returned is similar
or identical to that obtained via
<A HREF="#::getLiveStatus"CLASS="Er">::getLiveStatus</A>.
However, the
<A HREF="#::getLiveStatus"CLASS="Er">::getLiveStatus</A>
returns information on the current status,
or the status when the last buffer was captured.
In contrast, the
<A HREF="#::pxlib.goingBufStatus"CLASS="Er">::pxlib.goingBufStatus</A>
obtains status information about a specific buffer,
returning status information stored with the buffer.
<P>
Status information may not stored for each frame buffer,
depending on frame buffer memory configuration.
For the PIXCI&reg; CL3SD imaging board, the
''-IM''
<A HREF="#Device Configuration Parameters"CLASS="Er">Device Configuration Parameters</A>
must specify
''frame''
buffer memory, even though the
PIXCI&reg; CL3SD imaging board has on-board memory.
For all PIXCI&reg; imaging boards, use of
forceful memory allocation or the
''-MU''
<A HREF="#Device Configuration Parameters"CLASS="Er">Device Configuration Parameters</A>
can prevent status information from being stored
for each frame buffer.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::xcdev.setSnapBuf NX643"CLASS="NX"></A>
<A NAME="::xcdev.setSnapBuf"CLASS="Sf"></A>
<A NAME="Initiate Snap into Frame Buffer NX644"CLASS="NX"></A>
<A NAME="Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf"CLASS="Sf"></A>
<A NAME="Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf"></A>
<H6 CLASS="Sf">Initiate Snap into Frame Buffer   ---   ::xcdev.setSnapBuf</H6>
<A NAME="::xcdev.setSnapPairBuf NX645"CLASS="NX"></A>
<A NAME="::xcdev.setSnapPairBuf"CLASS="Sg"></A>
<A NAME="Initiate Snap Pair into Frame Buffers NX646"CLASS="NX"></A>
<A NAME="Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf"CLASS="Sg"></A>
<A NAME="Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf"></A>
<H6 CLASS="Sg">Initiate Snap Pair into Frame Buffers   ---   ::xcdev.setSnapPairBuf</H6>
<A NAME="::xcdev.setLiveBuf NX647"CLASS="NX"></A>
<A NAME="::xcdev.setLiveBuf"CLASS="Sg"></A>
<A NAME="Initiate Continuous Capture into Frame Buffer NX648"CLASS="NX"></A>
<A NAME="Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf"CLASS="Sg"></A>
<A NAME="Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf"></A>
<H6 CLASS="Sg">Initiate Continuous Capture into Frame Buffer   ---   ::xcdev.setLiveBuf</H6>
<A NAME="::xcdev.setLivePairBuf NX649"CLASS="NX"></A>
<A NAME="::xcdev.setLivePairBuf"CLASS="Sg"></A>
<A NAME="Initiate Continuous Alternate Capture into Frame Buffers NX650"CLASS="NX"></A>
<A NAME="Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf"CLASS="Sg"></A>
<A NAME="Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf"></A>
<H6 CLASS="Sg">Initiate Continuous Alternate Capture into Frame Buffers   ---   ::xcdev.setLivePairBuf</H6>
<A NAME="::setLivePhys NX651"CLASS="NX"></A>
<A NAME="::setLivePhys"CLASS="Sg"></A>
<A NAME="Initiate Continuous Capture into Memory Space NX652"CLASS="NX"></A>
<A NAME="Initiate Continuous Capture into Memory Space   ---   ::setLivePhys"CLASS="Sg"></A>
<A NAME="Initiate Continuous Capture into Memory Space   ---   ::setLivePhys"></A>
<H6 CLASS="Sg">Initiate Continuous Capture into Memory Space   ---   ::setLivePhys</H6>
<A NAME="::setSnapBuf"CLASS="Tr"></A>
<A NAME="::setSnapPairBuf"CLASS="Tr"></A>
<A NAME="::setLiveBuf"CLASS="Tr"></A>
<A NAME="::setLivePairBuf"CLASS="Tr"></A>
<A NAME="::setLivePhys"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.setSnapBuf)     (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1);
int (xcdev.setSnapPairBuf) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1, buf2, tracker2);
int (xcdev.setLiveBuf)     (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1);
int (xcdev.setLivePairBuf) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf1, tracker1, buf2, tracker2, period);
int (xcdev.setLivePhys)    (&amp;xcdev, unitmap, rsvd1, stateid, statep, time, vidphys);
<BR>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   *time;          // Reserved, should be NULL
pxbuffer_t          buf1;           // Image frame buffer
pxbuffer_t          buf2;           // Image frame buffer
int                 tracker1;       // Reserved, should be 0
int                 tracker2;       // Reserved, should be 0
int                 period;         // Reserved, should be 1
struct pxvidphys    vidphys[];      // Memory space specification
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::setSnapBuf"CLASS="Er">::setSnapBuf</A>
initiates a snap of a single video field or frame
on the multiple units selected by
<EM CLASS="Ep">unitmap</EM>
into image frame buffer
<EM CLASS="Ep">buf1</EM>.
<P>
The
<A HREF="#::setSnapPairBuf"CLASS="Er">::setSnapPairBuf</A>
initiates a snap of a pair of video fields or frames
on the multiple units selected by
<EM CLASS="Ep">unitmap</EM>
into image frame buffers
<EM CLASS="Ep">buf1</EM>
and
<EM CLASS="Ep">buf2</EM>;
it is intended for use only with cameras with a so-called
''Triggered Dual Exposure''
mode.
<P>
The
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>
initiates continuous capture of video fields or frames
on the multiple units selected by
<EM CLASS="Ep">unitmap</EM>
into image frame buffer
<EM CLASS="Ep">buf1</EM>.
<P>
The
<A HREF="#::setLivePairBuf"CLASS="Er">::setLivePairBuf</A>
initiates continuous capture of video fields or frames
on the multiple units selected by
<EM CLASS="Ep">unitmap</EM>
into alternating image frame buffers
<EM CLASS="Ep">buf1</EM>
and
<EM CLASS="Ep">buf2</EM>.
<P>
If
<EM CLASS="Ep">stateid</EM>&ne;0,
the Video Format Configuration
associated with that video state id
by
<A HREF="#::defineState"CLASS="Er">::defineState</A>
is used to interpret the
<EM CLASS="Ep">buf1</EM>
and
<EM CLASS="Ep">buf2</EM>.
If
<EM CLASS="Ep">statep</EM>&ne;NULL,
the Video Format Configuration contained in the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure is used to interpret the
<EM CLASS="Ep">buf1</EM>
and
<EM CLASS="Ep">buf2</EM>.
The
<EM CLASS="Ep">stateid</EM>&ne;0
and
<EM CLASS="Ep">statep</EM>&ne;NULL
should not both be specified.
<P>
The
<A HREF="#::setVideoConfig"CLASS="Er">::setVideoConfig</A>
must have been previously invoked
to configure the imaging board to the
Video Format Configuration
specified by
<EM CLASS="Ep">stateid</EM>
or
<EM CLASS="Ep">statep</EM>.
<P>
The
<A HREF="#::setLivePhys"CLASS="Er">::setLivePhys</A>
initiates continuous capture of video fields or frames
on the multiple units selected by
<EM CLASS="Ep">unitmap</EM>
into the memory space specified by
<EM CLASS="Ep">vidphys</EM>.
There must be one element of
<EM CLASS="Ep">vidphys</EM>
for each unit
<U CLASS="U">selected</U>
by
<EM CLASS="Ep">unitmap</EM>;
e.g. for
<EM CLASS="Ep">unitmap</EM>=9,
the
<EM CLASS="Ep">vidphys</EM>[0]
is used for unit 0, and the
<EM CLASS="Ep">vidphys</EM>[1]
is used for unit 3.
<P>
The
<A HREF="#::setSnapBuf"CLASS="Er">::setSnapBuf</A>,
<A HREF="#::setSnapPairBuf"CLASS="Er">::setSnapPairBuf</A>,
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>,
<A HREF="#::setLivePairBuf"CLASS="Er">::setLivePairBuf</A>,
and
<A HREF="#::setLivePhys"CLASS="Er">::setLivePhys</A>
have effect and return
''immediately'';
i.e. without regards to, or waiting for, video sync
or completion of capture of the video field or frames.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERRESOURCEBUSY<DD>
Video is already being captured
and must be terminated before
initiating a new capture.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::setLiveSeqBuf NX653"CLASS="NX"></A>
<A NAME="::setLiveSeqBuf"CLASS="Sf"></A>
<A NAME="Initiate Sequence Capture into Frame Buffers NX654"CLASS="NX"></A>
<A NAME="Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf"CLASS="Sf"></A>
<A NAME="Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf"></A>
<H6 CLASS="Sf">Initiate Sequence Capture into Frame Buffers   ---   ::setLiveSeqBuf</H6>
<A NAME="::setLiveSeqBuf"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.setLiveSeqBuf)(&amp;xcdev, unitmap, rsvd1, stateid, statep, time, startbuf, endbuf,
                          incbuf, numbuf, period, trackers);
<BR>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   *time;          // Reserved, should be NULL
pxbuffer_t          startbuf;       // Image frame buffer start
pxbuffer_t          endbuf;         // Image frame buffer end
pxbuffer_t          incbuf;         // Image frame buffer increment
pxbuffer_t          numbuf          // Number of Image frame buffers
int                 period;         // Period between captured fields or frames
int                 trackers;       // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>
initiates a snap of a sequence of video fields or frames
on the multiple units selected by
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>
initiates sequence capture of images into
<EM CLASS="Ep">startbuf</EM>
through
<EM CLASS="Ep">endbuf</EM>.
The sequence capture starts into
<EM CLASS="Ep">startbuf</EM>
and continues into frame buffers
<EM CLASS="Ep">startbuf</EM>+<EM CLASS="Ep">incbuf</EM>*1,
<EM CLASS="Ep">startbuf</EM>+<EM CLASS="Ep">incbuf</EM>*2,
etc., wrapping around from the
<EM CLASS="Ep">endbuf</EM>
back to the
<EM CLASS="Ep">startbuf</EM>.
Typically
<EM CLASS="Ep">incbuf</EM>=1
for use of consecutive ascending frame buffers.
The
<EM CLASS="Ep">numbuf</EM>
specifies the number image frame buffers
to be captured.
Typically,
<EM CLASS="Ep">numbuf</EM>
is
endbuf<EM CLASS="Ep">-</EM>startbuf<EM CLASS="Ep">+1</EM>
for simple sequence capture, or 0
for continuous (i.e.
''circular'')
sequence capture.
The
<EM CLASS="Ep">videoperiod</EM>
specifies the time interval, in video fields or frames,
between captured image frame buffers.
Typically,
<EM CLASS="Ep">videoperiod</EM>=1
for video rate capture.
For non-interlaced video formats, the
<EM CLASS="Ep">videoperiod</EM>
is in fields.
For interlaced video formats, the
<EM CLASS="Ep">videoperiod</EM>
is in units of frames,
unless,
a)&nbsp;Each image frame buffer is configured to
contain only one field, and
b)&nbsp;Video
''switching''
is configured to take place after the
''next'',
rather than after an
''odd''
or an
''even''
field.
<P>
If
<EM CLASS="Ep">stateid</EM>&ne;0,
the Video Format Configuration
associated with that video state id
by
<A HREF="#::defineState"CLASS="Er">::defineState</A>
is used to interpret the
<EM CLASS="Ep">startbuf</EM>
through
<EM CLASS="Ep">endbuf</EM>.
If
<EM CLASS="Ep">statep</EM>&ne;NULL,
the Video Format Configuration contained in the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure is used to interpret the
<EM CLASS="Ep">startbuf</EM>
through
<EM CLASS="Ep">endbuf</EM>.
The
<EM CLASS="Ep">stateid</EM>&ne;0
and
<EM CLASS="Ep">statep</EM>&ne;NULL
should not both be specified.
<P>
The
<A HREF="#::setVideoConfig"CLASS="Er">::setVideoConfig</A>
must have been previously invoked
to configure the imaging board to the
Video Format Configuration
specified by
<EM CLASS="Ep">stateid</EM>
or
<EM CLASS="Ep">statep</EM>.
<P>
The
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>
has effect and returns
''immediately'';
i.e. without regards to, or waiting for, video sync
or completion of capture of the video field or frames.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERRESOURCEBUSY<DD>
Video is already being captured
and must be terminated before
initiating a new capture.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::setLiveTrigBuf NX655"CLASS="NX"></A>
<A NAME="::setLiveTrigBuf"CLASS="Sf"></A>
<A NAME="Initiate Triggered Capture into Frame Buffer NX656"CLASS="NX"></A>
<A NAME="Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf"CLASS="Sf"></A>
<A NAME="Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf"></A>
<H6 CLASS="Sf">Initiate Triggered Capture into Frame Buffer   ---   ::setLiveTrigBuf</H6>
<A NAME="::setLiveTrigBuf"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.setLiveTrigBuf)(&amp;xcdev, unitmap, rsvd1, stateid, statep, time, buf, tracker, trigspec);
<BR>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   *time;          // Reserved, should be NULL
pxbuffer_t          buffer;         // Image frame buffer
int                 tracker;        // Reserved, should be 0
struct pxtrigspec   trigspec;       // Trigger specification
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
initiates a triggered capture of a video field or frame
on the multiple units selected by
<EM CLASS="Ep">unitmap</EM>.
<P>
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
is not intended, and not needed
for PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, and SI imaging boards
where the PIXCI&reg; and/or camera hardware
provides dedicated (typically asynchronous) triggering and
''single-shot''
capabilities.
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
is intended for cameras producing continuous
video, and where the imaging board's
General Purpose Input/Output signals
are used to sense external events, and control
external devices.
<P>
The
<EM CLASS="Ep">trigspec</EM>
instance of the
<A HREF="#pxtrigspec"CLASS="Er">pxtrigspec</A>
structure
specifies how the
General Purpose Input
signal(s) are to be sensed,
how the General Purpose Output
signals are to be controlled,
how many fields or frames to wait at each step,
and when to conclude the capture.
<P>
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
is not available for PIXCI&reg; SV2 and SV3
imaging boards.
For PIXCI&reg; D, D24, and D32 imaging boards,
the actual non-zero value of
<EM CLASS="Ep">trigspec</EM>.<EM CLASS="Ep">gpin30wait</EM>
is immaterial; the imaging board's hardware determines
the edge sensitivity of the General Purpose Input.
<P>
If
<EM CLASS="Ep">stateid</EM>&ne;0,
the Video Format Configuration
associated with that video state id
by
<A HREF="#::defineState"CLASS="Er">::defineState</A>
is used to interpret the
<EM CLASS="Ep">buffer</EM>.
If
<EM CLASS="Ep">statep</EM>&ne;NULL,
the Video Format Configuration contained in the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure is used to interpret the
<EM CLASS="Ep">buffer</EM>.
The
<EM CLASS="Ep">stateid</EM>&ne;0
and
<EM CLASS="Ep">statep</EM>&ne;NULL
should not both be specified.
<P>
The
<A HREF="#::setVideoConfig"CLASS="Er">::setVideoConfig</A>
must have been previously invoked
to configure the imaging board to the
Video Format Configuration
specified by
<EM CLASS="Ep">stateid</EM>
or
<EM CLASS="Ep">statep</EM>.
<P>
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
has effect and returns
''immediately'';
i.e. without regards to, or waiting for, video sync
or completion of capture of the video field or frames.
In execution, the
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
implements continuous capture of multiple fields or frames
(i.e. effectively a
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>)
into the same
<EM CLASS="Ep">buffer</EM>
which at the appropriate time is terminated
(i.e. effectively a
<A HREF="#::setUnLive"CLASS="Er">::setUnLive</A>)
leaving the last captured field or frame.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERRESOURCEBUSY<DD>
Video is already being captured
and must be terminated before
initiating a new capture.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::xcdev.setUnLive NX657"CLASS="NX"></A>
<A NAME="::xcdev.setUnLive"CLASS="Sf"></A>
<A NAME="Terminate Live/Snap into Frame Buffer NX658"CLASS="NX"></A>
<A NAME="Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive"CLASS="Sf"></A>
<A NAME="Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive"></A>
<H6 CLASS="Sf">Terminate Live/Snap into Frame Buffer   ---   ::xcdev.setUnLive</H6>
<A NAME="::xcdev.setAbortLive NX659"CLASS="NX"></A>
<A NAME="::xcdev.setAbortLive"CLASS="Sg"></A>
<A NAME="Abort Live/Snap into Frame Buffer NX660"CLASS="NX"></A>
<A NAME="Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive"CLASS="Sg"></A>
<A NAME="Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive"></A>
<H6 CLASS="Sg">Abort Live/Snap into Frame Buffer   ---   ::xcdev.setAbortLive</H6>
<A NAME="::setUnLive"CLASS="Tr"></A>
<A NAME="::setAbortLive"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.setUnLive)    (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
int (xcdev.setAbortLive) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
<BR>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 mode;           // Status to check
int                 stateid;        // Reserved, should be 0
struct pxvidstate   *statep;        // Reserved, should be NULL
struct pxtimespec   *time;          // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The current video capture mode initiated
by
<A HREF="#::setSnapBuf"CLASS="Er">::setSnapBuf</A>,
<A HREF="#::setSnapPairBuf"CLASS="Er">::setSnapPairBuf</A>,
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>,
<A HREF="#::setLivePairBuf"CLASS="Er">::setLivePairBuf</A>,
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>
or
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
is terminated.
The
<A HREF="#::setUnLive"CLASS="Er">::setUnLive</A>
causes video capture to be terminated at
the next appropriate field or frame boundary.
The
<A HREF="#::setAbortLive"CLASS="Er">::setAbortLive</A>
causes video capture to be terminated immediately,
regardless of video timing.
<P>
Both
<A HREF="#::setUnLive"CLASS="Er">::setUnLive</A>
and
<A HREF="#::setAbortLive"CLASS="Er">::setAbortLive</A>
return
''immediately''
without waiting for completion.
<P>
For PIXCI&reg; CL3SD, the
<A HREF="#::setAbortLive"CLASS="Er">::setAbortLive</A>
currently behaves the same as
<A HREF="#::setUnLive"CLASS="Er">::setUnLive</A>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::xcdev.setVideoConfig NX661"CLASS="NX"></A>
<A NAME="::xcdev.setVideoConfig"CLASS="Sf"></A>
<A NAME="Set Video Configuration NX662"CLASS="NX"></A>
<A NAME="Set Video Configuration   ---   ::xcdev.setVideoConfig"CLASS="Sf"></A>
<A NAME="Set Video Configuration   ---   ::xcdev.setVideoConfig"></A>
<H6 CLASS="Sf">Set Video Configuration   ---   ::xcdev.setVideoConfig</H6>
<A NAME="::xcdev.setVideoAdjust NX663"CLASS="NX"></A>
<A NAME="::xcdev.setVideoAdjust"CLASS="Sg"></A>
<A NAME="Adjust Video Configuration NX664"CLASS="NX"></A>
<A NAME="Adjust Video Configuration   ---   ::xcdev.setVideoAdjust"CLASS="Sg"></A>
<A NAME="Adjust Video Configuration   ---   ::xcdev.setVideoAdjust"></A>
<H6 CLASS="Sg">Adjust Video Configuration   ---   ::xcdev.setVideoAdjust</H6>
<A NAME="::setVideoConfig"CLASS="Tr"></A>
<A NAME="::setVideoAdjust"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.setVideoConfig) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
int (xcdev.setVideoAdjust) (&amp;xcdev, unitmap, rsvd1, stateid, statep, time);
<BR>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 rsvd1;          // Reserved, should be 0
int                 stateid;        // Video state id, or 0
struct pxvidstate   *statep;        // Pointer to video state, or NULL
struct pxtimespec   time;           // Reserved, should be NULL
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::setVideoConfig"CLASS="Er">::setVideoConfig</A>
configures the multiple imaging boards
selected by
<EM CLASS="Ep">unitmap</EM>
to a Video Format Configuration.
Configuration always implies terminating any video capture
currently in progress; termination is always immediate.
<P>
The
<A HREF="#::setVideoAdjust"CLASS="Er">::setVideoAdjust</A>
adjusts the multiple imaging boards
selected by
<EM CLASS="Ep">unitmap</EM>
to a Video Format Configuration.
Only those features which can be adjusted
without reconfiguration of image frame buffers
or without terminating any video capture in progress
are set.
<P>
If
<EM CLASS="Ep">stateid</EM>&ne;0,
the Video Format Configuration
associated with that video state id
by
<A HREF="#::defineState"CLASS="Er">::defineState</A>
is used.
If
<EM CLASS="Ep">statep</EM>&ne;NULL,
the Video Format Configuration contained in the
<EM CLASS="Ep">statep</EM>
instance of the
<A HREF="#pxvidstate"CLASS="Er">pxvidstate</A>
structure is used.
The
<EM CLASS="Ep">stateid</EM>&ne;0
and
<EM CLASS="Ep">statep</EM>&ne;NULL
should not both be specified.
<P>
The
<A HREF="#::setVideoConfig"CLASS="Er">::setVideoConfig</A>
and
<A HREF="#::setVideoAdjust"CLASS="Er">::setVideoAdjust</A>
have effect and return
''immediately'';
i.e. without regards to video timing.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="3">
<A NAME="Structured Style Interface - Miscellaneous Services"CLASS="Ch"></A>
<A NAME="8.  Structured Style Interface - Miscellaneous Services"></A>
<H1>8.  Structured Style Interface - Miscellaneous Services</H1>
<P>
<HR SIZE="1">
<A NAME="::xcdev.getGpin NX665"CLASS="NX"></A>
<A NAME="::xcdev.getGpin"CLASS="Sf"></A>
<A NAME="General Purpose Input Signal: Sense NX666"CLASS="NX"></A>
<A NAME="General Purpose Input Signal: Sense   ---   ::xcdev.getGpin"CLASS="Sf"></A>
<A NAME="General Purpose Input Signal: Sense   ---   ::xcdev.getGpin"></A>
<H6 CLASS="Sf">General Purpose Input Signal: Sense   ---   ::xcdev.getGpin</H6>
<A NAME="::xcdev.setGpin NX667"CLASS="NX"></A>
<A NAME="::xcdev.setGpin"CLASS="Sg"></A>
<A NAME="General Purpose Input Signal: Reset NX668"CLASS="NX"></A>
<A NAME="General Purpose Input Signal: Reset   ---   ::xcdev.setGpin"CLASS="Sg"></A>
<A NAME="General Purpose Input Signal: Reset   ---   ::xcdev.setGpin"></A>
<H6 CLASS="Sg">General Purpose Input Signal: Reset   ---   ::xcdev.setGpin</H6>
<A NAME="::xcdev.setGpout NX669"CLASS="NX"></A>
<A NAME="::xcdev.setGpout"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Set NX670"CLASS="NX"></A>
<A NAME="General Purpose Output Signal: Set   ---   ::xcdev.setGpout"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Set   ---   ::xcdev.setGpout"></A>
<H6 CLASS="Sg">General Purpose Output Signal: Set   ---   ::xcdev.setGpout</H6>
<A NAME="::xcdev.getGpout NX671"CLASS="NX"></A>
<A NAME="::xcdev.getGpout"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Get NX672"CLASS="NX"></A>
<A NAME="General Purpose Output Signal: Get   ---   ::xcdev.getGpout"CLASS="Sg"></A>
<A NAME="General Purpose Output Signal: Get   ---   ::xcdev.getGpout"></A>
<H6 CLASS="Sg">General Purpose Output Signal: Get   ---   ::xcdev.getGpout</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (xcdev.getGpin) (&amp;xcdev, unitmap, time, rsvd1, rsvd2);
int (xcdev.setGpin) (&amp;xcdev, unitmap, time, rsvd1, value);
int (xcdev.getGpout)(&amp;xcdev, unitmap, time, rsvd1, rsvd2);
int (xcdev.setGpout)(&amp;xcdev, unitmap, time, rsvd1, value);
<BR>
struct xcdevservice xcdev;          // A xcdevservice instance
int                 unitmap;        // Unit selection bit map (1 for single unit)
struct pxtimespec   *time;          // Reserved, should be 0
int                 rsvd1;          // Reserved, should be 0
int                 value;          // Binary value(s) to set or reset
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The general purpose input and output
signals are sensed, set, or reset.
<P>
The
<A HREF="#::getGpin"CLASS="Er">::getGpin</A>
obtains the current value of the general purpose
input signals, if any.
<P>
The
<A HREF="#::setGpin"CLASS="Er">::setGpin</A>
resets the current value of the general purpose
input signals, if any, as per
<EM CLASS="Ep">value</EM>,
for imaging boards where the
general purpose inputs are latched rather than level sensitive.
<P>
The
<A HREF="#::setGpout"CLASS="Er">::setGpout</A>
sets the current value of the general purpose
output signals, if any, to
<EM CLASS="Ep">value</EM>.
<P>
The
<A HREF="#::getGpout"CLASS="Er">::getGpout</A>
gets the current value of the general purpose
output signals, if any,
returning a value in the same format as
the
<EM CLASS="Ep">value</EM>
parameter of
<A HREF="#::setGpout"CLASS="Er">::setGpout</A>.
<P>
For
<A HREF="#::getGpin"CLASS="Er">::getGpin</A>
and
<A HREF="#::getGpout"CLASS="Er">::getGpout</A>,
the
<EM CLASS="Ep">unitmap</EM>
specifies the single unit for which the general
purpose input signals are sensed or the current value of
the general purpose output signals are obtained.
For
<A HREF="#::setGpin"CLASS="Er">::setGpin</A>
and
<A HREF="#::setGpout"CLASS="Er">::setGpout</A>,
the
<EM CLASS="Ep">unitmap</EM>
specifies the multiple units for which the general
purpose input signals are reset or the general purpose
output signals are set.
<P>
For the PIXCI&reg;&nbsp;SV2, SV3, SV4, SV5, and SV5A imaging boards:
The boards' four general purpose output signals, XD4, XD5, XD6, and XD7,
are set to the bits 0x01, 0x02, 0x04, and 0x08 of
<EM CLASS="Ep">value</EM>,
respectively.
The boards' four general purpose input signals, XD0, XD1, XD2, and XD3,
are sensed in bits
0x01, 0x02, 0x04, and 0x08,
respectively,
of the returned value of
<A HREF="#::getGpin"CLASS="Er">::getGpin</A>.
The general purpose inputs are level sensitive,
the
<A HREF="#::setGpin"CLASS="Er">::setGpin</A>
has no effect.
<P>
For the PIXCI&reg;&nbsp;D, D24, and D32 imaging boards:
The availability of general purpose inputs and outputs
depends upon the board model, revision level, and video format configuration.
The boards may have a single general purpose latched input signal,
sensed as bit 0x01 of the returned value of
<A HREF="#::getGpin"CLASS="Er">::getGpin</A>,
and reset as bit 0x01
of the
<EM CLASS="Ep">value</EM>
of
<A HREF="#::setGpin"CLASS="Er">::setGpin</A>.
The boards may have a single general purpose latched output signal,
set to bit 0x01 of
<EM CLASS="Ep">value</EM>.
<P>
For the PIXCI&reg;&nbsp;D2X, D3X, SI, CL2, E1, E4, and CL3SD imaging boards,
and for each functional unit of the PIXCI&reg;&nbsp;E1DB imaging board:
The two general purpose output signals
are set to bits 0x01 and 0x02 of
<EM CLASS="Ep">value</EM>.
The two general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<A HREF="#::getGpin"CLASS="Er">::getGpin</A>.
The general purpose inputs are level sensitive,
the
<A HREF="#::setGpin"CLASS="Er">::setGpin</A>
has no effect.
<P>
For the PIXCI&reg;&nbsp;CL1 imaging boards:
The board's one (revision one boards) or two (revision two and later boards)
general purpose output signals
are set to bits 0x01 and 0x02 of
<EM CLASS="Ep">value</EM>.
The board's one (revision one boards) or two (revision two and later boards)
general purpose input signals
are sensed in bits
0x01 and 0x02
of the returned value of
<A HREF="#::getGpin"CLASS="Er">::getGpin</A>.
The general purpose inputs are level sensitive,
the
<A HREF="#::setGpin"CLASS="Er">::setGpin</A>
has no effect.
<P>
Note:
The general purpose input(s) and output(s)
are those
''auxiliary''
features available on some imaging boards
where, at the hardware level, the signal has no direct effect
on video capture.
The general purpose input(s) and output(s)
are not related to, and not needed for,
camera specific, hardware supported, typically asynchronous exposure,
triggering features available on some cameras when used with
the PIXCI&reg;&nbsp;D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Function performed,
however this returned value is not proof that the
imaging board supports the general purpose input(s) and
output(s).
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxdev.ioctl NX673"CLASS="NX"></A>
<A NAME="::pxdev.ioctl"CLASS="Sf"></A>
<A NAME="Device Control NX674"CLASS="NX"></A>
<A NAME="Device Control   ---   ::pxdev.ioctl"CLASS="Sf"></A>
<A NAME="Device Control   ---   ::pxdev.ioctl"></A>
<H6 CLASS="Sf">Device Control   ---   ::pxdev.ioctl</H6>
<A NAME="::ioctl"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxdev.ioctl) (&amp;pxdev,options,unitmap,adrs,space,subspace,buf,cnt,rw,async,time);
struct pxdevservice pxdev;          // A pxdevservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
uint32              adrs;           // Address of device
uint                space;          // Device selection space
uint                subspace;       // Device selection subspace
void                *buf;           // Application program buffer
uint                cnt;            // Transfer count, bytes
uint                rw;             // PXREAD: Copy into program buffer
                                    // PXRITE: Copy from program buffer
pxasync_s           *async;         // Reserved, should be NULL
pxtimespec_s        *time;          // Reserved, should be NULL
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Various imaging board features are accessed and controlled.
<P>
For the PIXCI&reg; CL1, CL2, E1, E4, E1DB, and CL3SD,
using
<A HREF="#ioctl"CLASS="Er">ioctl</A>
with
<EM CLASS="Ep">space</EM>=CCCC('U','A','R','T')
provides access and control to the serial ports.<A HREF="#Footnote 33"CLASS="Ff"><SUP>[33]</SUP></A>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit's serial port to
be accessed and controlled.
<P>
If
<EM CLASS="Ep">subspace</EM>=CCCC('C','F','G','a')
and
<EM CLASS="Ep">rw</EM>=PXRITE,
the serial port is configured.
The
<EM CLASS="Ep">buf</EM>
and
<EM CLASS="Ep">cnt</EM>
are expected to be a pointer to, and size of:
<BLOCKQUOTE>
<PRE>
    int config[5];
<BR>
    config[0] = 96000;  // baud rate * 10
    config[1] = 0;      // reserved
    config[2] = 8;      // data bits
    config[3] = 'n';    // parity selection
    config[4] = 1;      // stop bits
</PRE>
</BLOCKQUOTE>
which specify the serial format.
Values shown above correspond to the Camera Link standard.
The PIXCI&reg; CL2, and the PIXCI&reg; CL1 Rev. 3 and later
supports any baud rate between
192.0 and 12,500,000.0 baud, other serial format characteristics
are fixed in hardware.
The PIXCI&reg; CL1 before Rev. 3 and the PIXCI&reg; CL3SD support any baud rate between
95.4 and 6,250,000.0 baud, other serial format characteristics
are fixed in hardware.
The PIXCI&reg; E1 and E4
supports any baud rate between
512.4 and 12,500,000.0 baud, other serial format characteristics
are fixed in hardware.
The PIXCI&reg; E1DB
supports any of the baud rates
9600, 19200, 38400, 57600, 115200, 230400, 460800, or 921600 baud
(the Camera Link V2.0 Specification baud rates),
other serial format characteristics
are fixed in hardware.
<P>
If
<EM CLASS="Ep">subspace</EM>=CCCC('R','C','V','1'),
<EM CLASS="Ep">rw</EM>=PXREAD,
and
<EM CLASS="Ep">cnt</EM>=0,
the number of received characters waiting to be transferred
from the internal receive queue is returned.
The
<EM CLASS="Ep">buf</EM>
must be a valid pointer, even though it is not used.
If
<EM CLASS="Ep">subspace</EM>=CCCC('R','C','V','!'),
<EM CLASS="Ep">rw</EM>=PXREAD,
and
<EM CLASS="Ep">cnt</EM>&gt;0,
received characters are transferred from the internal receive
queue to the buffer
<EM CLASS="Ep">buf</EM>,
and deleted from the receive queue.
The number of characters transferred is the smaller of
<EM CLASS="Ep">cnt</EM>
and the number of characters waiting in the receive queue;
the same number is returned.
<P>
If
<EM CLASS="Ep">subspace</EM>=CCCC('X','M','T','0'),
<EM CLASS="Ep">rw</EM>=PXREAD,
and
<EM CLASS="Ep">cnt</EM>=0,
the number of characters of empty space available
in the transmit queue is returned.
The
<EM CLASS="Ep">buf</EM>
must be a valid pointer, even though it is not used.
If
<EM CLASS="Ep">subspace</EM>=CCCC('U','A','R','T'),
<EM CLASS="Ep">rw</EM>=PXRITE,
and
<EM CLASS="Ep">cnt</EM>&gt;<EM CLASS="Ep">0,</EM>
<EM CLASS="Ep">cnt</EM>
characters are transferred from buffer
<EM CLASS="Ep">buf</EM>
to the transmit queue.
The number of characters actually added to the transmit queue
is the smaller of
<EM CLASS="Ep">cnt</EM>
and the number of characters of empty space available
in the transmit queue; the same number is returned.
<P>
None of the serial port features wait for data to
be received, or data to be transmitted; all return
''immediately'',
save minimal execution time.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="3">
<A NAME="Structured Style Interface - Auxiliary Services"CLASS="Ch"></A>
<A NAME="9.  Structured Style Interface - Auxiliary Services"></A>
<H1>9.  Structured Style Interface - Auxiliary Services</H1>
<P>
The group of Auxiliary Services provides
''convenience''
features.
These features could also be obtained by
using more fundamental Structured Style Interface
services, either combining several such services,
or combining such services along with the Windows API, the
''C''
library API,
and/or the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
functions.
<P>
For example, the
<A HREF="#::imageReadUChar"CLASS="Er">::imageReadUChar</A>,
and
<A HREF="#::imageWriteUChar"CLASS="Er">::imageWriteUChar</A>,
is a combination of
<A HREF="#::initPximage"CLASS="Er">::initPximage</A>
along with the pximage's
<A HREF="#::ioread"CLASS="Er">::ioread</A>;
the
<A HREF="#::imageLoadBmp"CLASS="Er">::imageLoadBmp</A>
and
<A HREF="#::imageSaveBmp"CLASS="Er">::imageSaveBmp</A>
combines
<A HREF="#::initPximage"CLASS="Er">::initPximage</A>
with
<CITE CLASS="Ec">pxio8_bmpread</CITE>
and
<CITE CLASS="Ec">pxio8_bmpwrite</CITE>
of the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>;
and the
<A HREF="#::MessageBoxFault"CLASS="Er">::MessageBoxFault</A>
combines
<A HREF="#::getFault"CLASS="Er">::getFault</A>
with
<CITE CLASS="Ec">MessageBox</CITE>
of the Windows API.
<HR SIZE="1">
<A NAME="::pxaux.bufferLoadStream NX675"CLASS="NX"></A>
<A NAME="::pxaux.bufferLoadStream"CLASS="Sf"></A>
<A NAME="Load Frame Buffers as Stream NX676"CLASS="NX"></A>
<A NAME="Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream"CLASS="Sf"></A>
<A NAME="Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream"></A>
<H6 CLASS="Sf">Load Frame Buffers as Stream   ---   ::pxaux.bufferLoadStream</H6>
<A NAME="::pxaux.bufferSaveStream NX677"CLASS="NX"></A>
<A NAME="::pxaux.bufferSaveStream"CLASS="Sg"></A>
<A NAME="Save Frame Buffers as Stream NX678"CLASS="NX"></A>
<A NAME="Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream"CLASS="Sg"></A>
<A NAME="Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream"></A>
<H6 CLASS="Sg">Save Frame Buffers as Stream   ---   ::pxaux.bufferSaveStream</H6>
<A NAME="::bufferLoadStream"CLASS="Tr"></A>
<A NAME="::bufferSaveStream"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxaux.bufferSaveStream) (&amp;pxaux, abortp, options, unitmap, stateid, startbuf,
                              endbuf, pathname, filehandle, fileoffset, alignsector);
int (pxaux.bufferLoadStream) (&amp;pxaux, abortp, options, unitmap, stateid, startbuf,
                              endbuf, pathname, filehandle, fileoffset, alignsector);
<BR>
struct pxauxservice pxaux;          // A pxauxservice instance
pxabortfunc_t       **abortp;       // Premature termination function, or NULL
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          startbuf;       // First image frame buffer
pxbuffer_t          endbuf;         // Last image frame buffer, inclusive
char                *pathname;      // File path name to be read or written, or NULL
void                *filehandle;    // Existing file handle to be read or written, or NULL
pxbuffer_t          fileoffset;     // Offset into file, in units of image frame buffers
uint32              alignsector;    // Pad image frame buffer size to multiple of ...
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
A sequence of one or more consecutive image frame buffers
is saved to, for
<A HREF="#::bufferSaveStream"CLASS="Er">::bufferSaveStream</A>,
or loaded from, for
<A HREF="#::bufferLoadStream"CLASS="Er">::bufferLoadStream</A>,
a file.
<P>
If
<EM CLASS="Ep">pathname</EM>&ne;NULL,
the image frame buffers are saved to, or loaded from, the
<EM CLASS="Ep">pathname</EM>;
for
<A HREF="#::bufferSaveStream"CLASS="Er">::bufferSaveStream</A>
an already existing
is not deleted and recreated, but partially or fully overwritten
allowable replacement of one or more images within an existing file.<A HREF="#Footnote 34"CLASS="Ff"><SUP>[34]</SUP></A>
Alternately, a
<EM CLASS="Ep">filehandle</EM>&ne;NULL,
to a file previously opened by the application may be supplied.
Under Windows the
<EM CLASS="Ep">filehandle</EM>
is expected to be a
<CITE CLASS="Ec">HANDLE</CITE>
provided by
<CITE CLASS="Ec">CreateFile</CITE>.
Under Linux the
<EM CLASS="Ep">filehandle</EM>
is expected to be a
''file descriptor''
provided by
<CITE CLASS="Ec">_open</CITE>.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit from which, or to which,
image frame buffers are to be saved or loaded.
The
<EM CLASS="Ep">startbuf</EM>
and
<EM CLASS="Ep">endbuf</EM>,
<EM CLASS="Ep">startbuf</EM>&lt;=<EM CLASS="Ep">endbuf</EM>,
specify the first and last image frame buffers, inclusive,
to be saved or loaded.
The entire image frame buffer is loaded or saved.
The
<EM CLASS="Ep">stateid</EM>
specifies a video state id
previously defined by
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
against which the
<EM CLASS="Ep">startbuf</EM>
and
<EM CLASS="Ep">endbuf</EM>
are interpreted.
<P>
Each image frame buffer is saved to, or loaded from,
the file sequentially starting at position
<EM CLASS="Ep">fileoffset</EM>,
where
<EM CLASS="Ep">fileoffset</EM>
is interpreted in units
of the size of an image frame buffer.
For example,
<EM CLASS="Ep">fileoffset</EM>=0
starts at the beginning of the file,
while
<EM CLASS="Ep">fileoffset</EM>=1
starts with the second image frame buffer in the file.
If
<EM CLASS="Ep">alignsector</EM>&ne;0,
the size of each saved image frame buffer, and thus the starting position
relative to the beginning of the file, is padded to a multiple
of
<EM CLASS="Ep">alignsector</EM>
bytes; typically so that each saved image frame buffer can
be aligned on a multiple of the file system's sector size,
or the operating system's virtual page size.
<P>
The image frame buffers are saved or loaded
with a file format which is an exact copy, byte for byte, of
the imaging board's frame buffer memory.
The file format is intended for efficient saving and loading
of image frame buffers; the actual format will vary
with different imaging boards, or different video formats
with a single imaging board.
Use of these functions, and the file format created,
is contraindicated for export to other
(i.e. non-EPIX&reg; imaging software) applications.
Use is also contraindicated for archival storage,
as reloading an image requires the presence of the same
imaging board set to the same video format.
<P>
Use of the phrase
''stream''
is intended to suggest that memory containing multiple frame buffers
can be saved or loaded efficiently, without
delays due to frame buffer boundaries.
It is not intended to suggest that these functions, by themselves,
continuously save or load an ongoing video stream.
<P>
The operation will terminate prematurely if
<EM CLASS="Ep">abortp</EM>&ne;NULL,
and
<EM CLASS="Ep">(*abortp)(...)</EM>,
tested periodically, returns a nonzero value.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERNOFILE<DD>
File doesn't exist (for
<A HREF="#::bufferLoadStream"CLASS="Er">::bufferLoadStream</A>).
<BR><DT>PXERNEWFILE<DD>
File can't be created (for
<A HREF="#::bufferSaveStream"CLASS="Er">::bufferSaveStream</A>).
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxaux.errorCodeString NX679"CLASS="NX"></A>
<A NAME="::pxaux.errorCodeString"CLASS="Sf"></A>
<A NAME="Errors: Translate Error Code to String NX680"CLASS="NX"></A>
<A NAME="Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString"CLASS="Sf"></A>
<A NAME="Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString"></A>
<H6 CLASS="Sf">Errors: Translate Error Code to String   ---   ::pxaux.errorCodeString</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (pxaux.errorCodeString) (&amp;pxaux, errorcode);
<BR>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 errorcode;      // Error return code
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Any of the
''PXER...''
error codes returned by various library functions,
given as the
<EM CLASS="Ep">errorcode</EM>
parameter, is translated and returned as a
suitable, concise, NULL terminated
error message string.
A NULL value is returned if
<EM CLASS="Ep">errorcode</EM>
is not a recognized
''PXER...''
code.
<P>
The
<A HREF="#::errorCodeString"CLASS="Er">::errorCodeString</A>
is identical to
<A HREF="#pxd_mesgErrorCode"CLASS="Er">pxd_mesgErrorCode</A>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
A char&nbsp;* to an error message, or NULL.
<HR SIZE="1">
<A NAME="::pxaux.faultMessageBox NX681"CLASS="NX"></A>
<A NAME="::pxaux.faultMessageBox"CLASS="Sf"></A>
<A NAME="Errors: Check &amp; Report Faults NX682"CLASS="NX"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox"CLASS="Sf"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox"></A>
<H6 CLASS="Sf">Errors: Check &amp; Report Faults   ---   ::pxaux.faultMessageBox</H6>
<A NAME="::pxaux.faultPrintf NX683"CLASS="NX"></A>
<A NAME="::pxaux.faultPrintf"CLASS="Sg"></A>
<A NAME="Errors: Check &amp; Report Faults NX684"CLASS="NX"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf"CLASS="Sg"></A>
<A NAME="Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf"></A>
<H6 CLASS="Sg">Errors: Check &amp; Report Faults   ---   ::pxaux.faultPrintf</H6>
<A NAME="::MessageBoxFault"CLASS="Tr"></A>
<A NAME="::printfFault"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int (pxaux.faultMessageBox) (&amp;pxaux, options, unitmap, fault, hWnd, lpCaption, uType);
int (pxaux.faultPrintf)     (&amp;pxaux, options, unitmap, fault, stdio, head, tail);
<BR>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
struct pxdevfault   *fault;         // Fault to report, or NULL to check for new fault
<BR>
HWND                hWnd;           // Parent Window for MessageBox
LPCSTR              lpCaption;      // Caption for MessageBox, or NULL for default
UINT                uType;          // Type of MessageBox, or 0 for default.
<BR>
FILE                *stdio;         // Pointer to stream
char                *head;          // Header to displayed fault, or NULL
char                *tail;          // Footer to displayed fault, or NULL
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::faultMessageBox"CLASS="Er">::faultMessageBox</A>
and
<A HREF="#::faultPrintf"CLASS="Er">::faultPrintf</A>
display faults as described in a
<A HREF="#pxdevfault"CLASS="Er">pxdevfault</A>
structure.
<P>
If
<EM CLASS="Ep">fault</EM>=NULL,
<A HREF="#::faultMessageBox"CLASS="Er">::faultMessageBox</A>
and
<A HREF="#::faultPrintf"CLASS="Er">::faultPrintf</A>
check whether a fault has occurred since the last check,
and if so displays the fault.
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit for which faults
are checked and displayed.
<P>
If
<EM CLASS="Ep">fault</EM>&ne;NULL,
<A HREF="#::faultMessageBox"CLASS="Er">::faultMessageBox</A>
and
<A HREF="#::faultPrintf"CLASS="Er">::faultPrintf</A>
display the fault described by the
<EM CLASS="Ep">fault</EM>
instance of the
<A HREF="#pxdevfault"CLASS="Er">pxdevfault</A>
structure;
no check is made for any faults that may have occurred
since the last check and
<EM CLASS="Ep">unitmap</EM>
is ignored.
<P>
For
<A HREF="#::faultMessageBox"CLASS="Er">::faultMessageBox</A>,
the fault's description is displayed in a Windows
<CITE CLASS="Ec">MessageBox</CITE>;
the
<EM CLASS="Ep">Hwnd</EM>,
<EM CLASS="Ep">lpCation</EM>,
and
<EM CLASS="Ep">uType</EM>
are the window handle, caption, and type parameters passed to the
<CITE CLASS="Ec">MessageBox</CITE>.
If
<EM CLASS="Ep">lpCation</EM>=NULL,
a default caption is used.
If
<EM CLASS="Ep">uType</EM>=0,
a type of MB_OK|MB_TASKMODAL is used.
<P>
For
<A HREF="#::faultPrintf"CLASS="Er">::faultPrintf</A>,
the fault's description is output via the
''C''
standard I/O stream referenced by
<EM CLASS="Ep">stdio</EM>.
The optional
<EM CLASS="Ep">head</EM>
and
<EM CLASS="Ep">tail</EM>
may contain new-line ('\n') terminated text
to be output above and below the fault's
description.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>1<DD>
Fault displayed.
<BR><DT>0<DD>
No fault displayed.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERBADSTRUCT<DD>
The
<EM CLASS="Ep">fault</EM>'s
<A HREF="#ddch.mos"CLASS="Er">ddch.mos</A>
or
<A HREF="#ddch.len"CLASS="Er">ddch.len</A>
signature was incorrect.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">See Also</EM>
<P>
See
<A HREF="#::getFault"CLASS="Er">::getFault</A>
for additional discussion
regarding the cause and nature of faults.
<HR SIZE="1">
<A NAME="::pxaux.imageLoadBmp NX685"CLASS="NX"></A>
<A NAME="::pxaux.imageLoadBmp"CLASS="Sf"></A>
<A NAME="Load Image: BMP Format NX686"CLASS="NX"></A>
<A NAME="Load Image: BMP Format   ---   ::pxaux.imageLoadBmp"CLASS="Sf"></A>
<A NAME="Load Image: BMP Format   ---   ::pxaux.imageLoadBmp"></A>
<H6 CLASS="Sf">Load Image: BMP Format   ---   ::pxaux.imageLoadBmp</H6>
<A NAME="::pxaux.imageLoadTiff NX687"CLASS="NX"></A>
<A NAME="::pxaux.imageLoadTiff"CLASS="Sg"></A>
<A NAME="Load Image: TIFF Format NX688"CLASS="NX"></A>
<A NAME="Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff"CLASS="Sg"></A>
<A NAME="Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff"></A>
<H6 CLASS="Sg">Load Image: TIFF Format   ---   ::pxaux.imageLoadTiff</H6>
<A NAME="::pxaux.imageSaveBmp NX689"CLASS="NX"></A>
<A NAME="::pxaux.imageSaveBmp"CLASS="Sg"></A>
<A NAME="Save Image: BMP Format NX690"CLASS="NX"></A>
<A NAME="Save Image: BMP Format   ---   ::pxaux.imageSaveBmp"CLASS="Sg"></A>
<A NAME="Save Image: BMP Format   ---   ::pxaux.imageSaveBmp"></A>
<H6 CLASS="Sg">Save Image: BMP Format   ---   ::pxaux.imageSaveBmp</H6>
<A NAME="::pxaux.imageSavePcx NX691"CLASS="NX"></A>
<A NAME="::pxaux.imageSavePcx"CLASS="Sg"></A>
<A NAME="Save Image: PCX Format NX692"CLASS="NX"></A>
<A NAME="Save Image: PCX Format   ---   ::pxaux.imageSavePcx"CLASS="Sg"></A>
<A NAME="Save Image: PCX Format   ---   ::pxaux.imageSavePcx"></A>
<H6 CLASS="Sg">Save Image: PCX Format   ---   ::pxaux.imageSavePcx</H6>
<A NAME="::pxaux.imageSaveTga NX693"CLASS="NX"></A>
<A NAME="::pxaux.imageSaveTga"CLASS="Sg"></A>
<A NAME="Save Image: TARGA Format NX694"CLASS="NX"></A>
<A NAME="Save Image: TARGA Format   ---   ::pxaux.imageSaveTga"CLASS="Sg"></A>
<A NAME="Save Image: TARGA Format   ---   ::pxaux.imageSaveTga"></A>
<H6 CLASS="Sg">Save Image: TARGA Format   ---   ::pxaux.imageSaveTga</H6>
<A NAME="::pxaux.imageSaveTiff NX695"CLASS="NX"></A>
<A NAME="::pxaux.imageSaveTiff"CLASS="Sg"></A>
<A NAME="Save Image: TIFF Format NX696"CLASS="NX"></A>
<A NAME="Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff"CLASS="Sg"></A>
<A NAME="Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff"></A>
<H6 CLASS="Sg">Save Image: TIFF Format   ---   ::pxaux.imageSaveTiff</H6>
<A NAME="TIFF Format NX697"CLASS="NX"></A>
<A NAME="BMP Format NX698"CLASS="NX"></A>
<A NAME="TARGA Format NX699"CLASS="NX"></A>
<A NAME="PCX Format NX700"CLASS="NX"></A>
<A NAME="::imageLoadBmp"CLASS="Tr"></A>
<A NAME="::imageLoadTiff"CLASS="Tr"></A>
<A NAME="::imageSaveBmp"CLASS="Tr"></A>
<A NAME="::imageSavePcx"CLASS="Tr"></A>
<A NAME="::imageSaveTga"CLASS="Tr"></A>
<A NAME="::imageSaveTiff"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (pxaux.imageLoadBmp) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageLoadTiff)(&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSaveBmp) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSavePcx) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSaveTga) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
int  (pxaux.imageSaveTiff)(&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,pathname,loadmode);
<BR>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
char                *pathname;      // File path name to load from, or save to
int                 loadmode;       // Resize: 'b': Bilinear, 'n': Nearest neighbor
                                    // Color Space: 0x100: convert, 0: no convert
int                 savemode;       // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
An image frame buffer, or an area of interest within the frame buffer,
is loaded from, or saved to, a file named
<EM CLASS="Ep">pathname</EM>.
<P>
The
<A HREF="#::imageLoadBmp"CLASS="Er">::imageLoadBmp</A>,
<A HREF="#::imageLoadTiff ,"CLASS="Er">::imageLoadTiff ,</A>
<A HREF="#::imageSaveBmp"CLASS="Er">::imageSaveBmp</A>,
<A HREF="#::imageSavePcx"CLASS="Er">::imageSavePcx</A>,
<A HREF="#::imageSaveTga"CLASS="Er">::imageSaveTga</A>,
and
<A HREF="#::imageSaveTiff"CLASS="Er">::imageSaveTiff</A>,
are identical to
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>,
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>,
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>,
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>,
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>,
and
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>,
respectively,
except allowing use with an
explicit instance of the XCLIB
library via the
<EM CLASS="Ep">pxaux</EM>
parameter and using an explicit
video state id specified by
<EM CLASS="Ep">stateid</EM>,
previously defined by
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
against which the
<EM CLASS="Ep">framebuf</EM>
and other parameters are interpreted.
All other parameters of
<A HREF="#::imageLoadBmp"CLASS="Er">::imageLoadBmp</A>,
<A HREF="#::imageLoadTiff ,"CLASS="Er">::imageLoadTiff ,</A>
<A HREF="#::imageSaveBmp"CLASS="Er">::imageSaveBmp</A>,
<A HREF="#::imageSavePcx"CLASS="Er">::imageSavePcx</A>,
<A HREF="#::imageSaveTga"CLASS="Er">::imageSaveTga</A>,
and
<A HREF="#::imageSaveTiff"CLASS="Er">::imageSaveTiff</A>,
correspond in name and meaning to the
parameters of
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>,
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>,
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>,
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>,
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>,
and
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
Same as
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>,
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>,
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>,
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>,
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>,
and
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>.
<HR SIZE="1">
<A NAME="::pxaux.imageReadUChar NX701"CLASS="NX"></A>
<A NAME="::pxaux.imageReadUChar"CLASS="Sf"></A>
<A NAME="Read Pixel Values as Unsigned Char NX702"CLASS="NX"></A>
<A NAME="Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar"CLASS="Sf"></A>
<A NAME="Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar"></A>
<H6 CLASS="Sf">Read Pixel Values as Unsigned Char   ---   ::pxaux.imageReadUChar</H6>
<A NAME="::pxaux.imageReadUShort NX703"CLASS="NX"></A>
<A NAME="::pxaux.imageReadUShort"CLASS="Sg"></A>
<A NAME="Read Pixel Values as Unsigned Short NX704"CLASS="NX"></A>
<A NAME="Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort"CLASS="Sg"></A>
<A NAME="Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort"></A>
<H6 CLASS="Sg">Read Pixel Values as Unsigned Short   ---   ::pxaux.imageReadUShort</H6>
<A NAME="::pxaux.imageReadUInt NX705"CLASS="NX"></A>
<A NAME="::pxaux.imageReadUInt"CLASS="Sg"></A>
<A NAME="Read Pixel Values as Unsigned Int NX706"CLASS="NX"></A>
<A NAME="Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt"CLASS="Sg"></A>
<A NAME="Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt"></A>
<H6 CLASS="Sg">Read Pixel Values as Unsigned Int   ---   ::pxaux.imageReadUInt</H6>
<A NAME="::pxaux.imageWriteUChar NX707"CLASS="NX"></A>
<A NAME="::pxaux.imageWriteUChar"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Char NX708"CLASS="NX"></A>
<A NAME="Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar"></A>
<H6 CLASS="Sg">Write Pixel Values as Unsigned Char   ---   ::pxaux.imageWriteUChar</H6>
<A NAME="::pxaux.imageWriteUShort NX709"CLASS="NX"></A>
<A NAME="::pxaux.imageWriteUShort"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Short NX710"CLASS="NX"></A>
<A NAME="Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort"></A>
<H6 CLASS="Sg">Write Pixel Values as Unsigned Short   ---   ::pxaux.imageWriteUShort</H6>
<A NAME="::pxaux.imageWriteUInt NX711"CLASS="NX"></A>
<A NAME="::pxaux.imageWriteUInt"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Int NX712"CLASS="NX"></A>
<A NAME="Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt"CLASS="Sg"></A>
<A NAME="Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt"></A>
<H6 CLASS="Sg">Write Pixel Values as Unsigned Int   ---   ::pxaux.imageWriteUInt</H6>
<A NAME="::imageReadUChar"CLASS="Tr"></A>
<A NAME="::imageReadUShort"CLASS="Tr"></A>
<A NAME="::imageReadUInt"CLASS="Tr"></A>
<A NAME="::imageWriteUChar"CLASS="Tr"></A>
<A NAME="::imageWriteUShort"CLASS="Tr"></A>
<A NAME="::imageWriteUInt"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (pxaux.imageReadUChar)  (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ucharbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageReadUShort) (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ushortbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageReadUInt)   (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,uintbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageWriteUChar) (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ucharbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageWriteUShort)(&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,ushortbuf,
                              cnt,colorspace,colormap,iomode,iodata);
int  (pxaux.imageWriteUInt)  (&amp;pxaux,options,unitmap,stateid,framebuf,nwx,nwy,sex,sey,uintbuf,
                              cnt,colorspace,colormap,iomode,iodata);
<BR>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
uchar               ucharbuf[];     // Program's buffer to receive or originate values
ushort              ushortbuf[];    // Program's buffer to receive or originate values
uint                uintbuf[];      // Program's buffer to receive or originate values
size_t              cnt;            // Size of ucharbuf, ushortbuf, or uintbuf,
                                    //  in uchar's, ushort's or uint's, respectively.
int                 colorspace;     // Requested color representation
int                 colormap;       // Pixel value component selection
int                 iomode;         // Reserved, should be 0
int                 iodata;         // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Pixel values from an image frame buffer
are copied into, or copied from,
an array or other memory buffer provided
by the application program.
<P>
The
<A HREF="#::imageReadUChar"CLASS="Er">::imageReadUChar</A>
copies pixels from an image frame buffer
into an
''unsigned char''
array or buffer provided by the application;
the
<A HREF="#::imageWriteUChar"CLASS="Er">::imageWriteUChar</A>
does the reverse.
The
<A HREF="#::imageReadUShort"CLASS="Er">::imageReadUShort</A>
copies pixels from an image frame buffer
into an
''unsigned short''
array or buffer provided by the application;
the
<A HREF="#::imageWriteUShort"CLASS="Er">::imageWriteUShort</A>
does the reverse.
The
<A HREF="#::imageReadUInt"CLASS="Er">::imageReadUInt</A>
copies pixels from an image frame buffer
into an
''unsigned int''
array or buffer provided by the application;
the
<A HREF="#::imageWriteUInt"CLASS="Er">::imageWriteUInt</A>
does the reverse.
<P>
The
<EM CLASS="Ep">unitmap</EM>
specifies the single unit from which, or to which,
pixel values are to be read or written.
The
<EM CLASS="Ep">framebuf</EM>
specifies the image frame buffer from which, or to which,
pixel values are to be read or written.
The
<EM CLASS="Ep">ulx</EM>
and
<EM CLASS="Ep">uly</EM>
respectively specify
the horizontal (x) and vertical coordinate (y)
of the upper left corner
of an area of interest in the frame buffer
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
respectively specify a value one greater than
the horizontal and vertical coordinate of the lower right corner
of an area of interest in the frame buffer
(i.e. an exclusive corner point)
to be used.
The
<EM CLASS="Ep">lrx</EM>
and
<EM CLASS="Ep">lry</EM>
may each be abbreviated to -1 to specify the extreme right
horizontal coordinate
(i.e.
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>())
or the extreme bottom vertical coordinate
(i.e.
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>()),
respectively.
The
<EM CLASS="Ep">stateid</EM>
specifies a video state id
previously defined by
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
against which the
<EM CLASS="Ep">framebuf</EM>,
<EM CLASS="Ep">ulx</EM>,
<EM CLASS="Ep">uly</EM>,
<EM CLASS="Ep">lrx</EM>,
and
<EM CLASS="Ep">lry</EM>
are interpreted.
<P>
The
<EM CLASS="Ep">colorspace</EM>
and
<EM CLASS="Ep">colormap</EM>
specifies the color space and color component(s)
in which pixel values are to be read into, or written from,
the program provided array or buffer.
Valid choices for
<EM CLASS="Ep">colorspace</EM>
are:
<BLOCKQUOTE>
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
colorspace    
</TD>
<TD ALIGN="left" COLSPAN="1">
 Number of Components 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Color Representation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGB     
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGR     
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red (RGB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBSH     
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness, Saturation, Hue (HSB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGBX    
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGRX    
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red, Pad (RGB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTGREY    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCB   
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity, Red Chroma, Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCBX  
</TD>
<TD ALIGN="left" COLSPAN="1">
 4 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity, Red Chroma, Blue Chroma, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBAYER   
</TD>
<TD ALIGN="left" COLSPAN="1">
 1 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Raw Bayer Pattern Values
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTCBYCRY  
</TD>
<TD ALIGN="left" COLSPAN="1">
 2 
</TD>
<TD ALIGN="left" COLSPAN="1">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTCMY     
</TD>
<TD ALIGN="left" COLSPAN="1">
 3 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cyan, Magenta, Yellow
</TD>
</TR>
</TABLE>
</PRE>
</BLOCKQUOTE>
<P>
The
''PXHINTBGRX''
selection, when read into a
''uchar''
buffer on Intel machines with little-endian architecture
(i.e. least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, results in pixels that are compatible with Windows' RGB() data type.
<P>
The
''PXHINTBAYER''
selection is available only in conjunction with cameras
that actually output raw Bayer pattern values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
<P>
The
''PXHINTCBYCRY''
selection is available only in conjunction with imaging boards
that actually capture CbYCrY (UYVY) values, and where the
XCLIB would otherwise be responsible for
converting the values to RGB(x), BGR(x), or YCrCb.
<P>
The
<EM CLASS="Ep">colormap</EM>
specifies which color components of the selected
<EM CLASS="Ep">colorspace</EM>
are to be read into, or written from,
the program provided array or buffer.
The
<EM CLASS="Ep">colormap</EM>
is a bit-map; the i'th
bit selects the i'th color component.
Example (but not an exhaustive list of) choices are:
<BLOCKQUOTE>
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
colorspace    
</TD>
<TD ALIGN="left" COLSPAN="1">
 colormap 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Color Components Selected
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGB     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x01     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGB     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x02     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGB     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x04     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGB     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x07     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGBX    
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x0F     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red, Green, Blue, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGR     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x01     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGR     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x02     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Green
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGR     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x04     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGR     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x07     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGRX    
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x0F     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue, Green, Red, Pad
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBSH     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x01     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBSH     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x02     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Saturation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBSH     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x04     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Hue
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBSH     
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x07     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness, Saturation, Hue (HSB reordered)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTGREY    
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x01     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey Scale
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCB   
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x01     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCB   
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x02     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCB   
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x04     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCB   
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x07     
</TD>
<TD ALIGN="left" COLSPAN="1">
 Intensity, Red Chroma, Blue Chroma
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTCBYCRY  
</TD>
<TD ALIGN="left" COLSPAN="1">
 0x03     
</TD>
<TD ALIGN="left" COLSPAN="1">
 UYVY (Blue &amp; Intensity, Red &amp; Intensity)
</TD>
</TR>
</TABLE>
</PRE>
</BLOCKQUOTE>
Typically, only values of
<EM CLASS="Ep">colormap</EM>
which either select a single component,
or select all components, are supported.
Values of
<EM CLASS="Ep">colormap</EM>
which select other combinations
of components are generally not supported.
<P>
The
<EM CLASS="Ep">ucharbuf</EM>,
<EM CLASS="Ep">ushortbuf</EM>,
or
<EM CLASS="Ep">uintbuf</EM>
specifies a program provided array or buffer which pixel
values are to be copied into, or copied from.
The
<EM CLASS="Ep">cnt</EM>
specifies the
number of unsigned chars ,
unsigned shorts
or unsigned ints
in the array or buffer referenced by
<EM CLASS="Ep">ucharbuf</EM>,
<EM CLASS="Ep">ushortbuf</EM>,
or
<EM CLASS="Ep">uintbuf</EM>,
respectively.
The
<EM CLASS="Ep">cnt</EM>
and the
<EM CLASS="Ep">ucharbuf</EM>,
<EM CLASS="Ep">ushortbuf</EM>,
or
<EM CLASS="Ep">uintbuf</EM>
must be large enough to contain all of the pixel
values implied by
<EM CLASS="Ep">ulx</EM>,
<EM CLASS="Ep">uly</EM>,
<EM CLASS="Ep">lrx</EM>,
<EM CLASS="Ep">lry</EM>,
<EM CLASS="Ep">colorspace</EM>,
and
<EM CLASS="Ep">colormap</EM>;
the
<EM CLASS="Ep">cnt</EM>
is not intended to be used to limit the number of pixel values
transferred, but is rather intended to assert the maximum
allowable transfer size and inducing an error
if the
<EM CLASS="Ep">cnt</EM>
is too small.
<P>
While these functions could be used to read or write
a single pixel value with each invocation,
they are intended, and more efficient, for reading
or writing lines, columns, or entire images of pixel values.
<P>
Any data type,
''uchar'',
''ushort'',
or
''uint'',
and any
<EM CLASS="Ep">colorspace</EM>
can be chosen regardless of the image frame buffer's
actual format.
However, data type and color conversions
may require additional computational overhead.
<P>
Each pixel value component is copied from, or copied into,
a single
''uchar'',
''ushort'',
or
''uint'';
pixel values are not
''packed''.
If the data type
has fewer bits that the pixel value component,
the most significant bits of the pixel value component
are copied into the data type, or are copied from the data type
with lower order bits set to 0;
e.g. a 10 bit per pixel component value of 1023 is
stored in an 8 bit
''uchar''
as value 255.
If the data type has more bits than the pixel value
component, the pixel value component is copied into, or copied from,
the data type's least significant bits;
e.g. a 10 bit per pixel component value of 1023
is stored in an 16 bit
''ushort''
as value 1023.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>&ge;0<DD>
Returns the number of pixel value components copied into,
or copied from, the
<EM CLASS="Ep">membuf</EM>.
<BR><DT>PXERNOTOPEN<DD>
The library is not open for use.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXERTOOSMALL<DD>
The
<EM CLASS="Ep">cnt</EM>
is too small to contain the number of pixel value components
specified by
<EM CLASS="Ep">ulx</EM>,
<EM CLASS="Ep">uly</EM>,
<EM CLASS="Ep">lrx</EM>,
<EM CLASS="Ep">lry</EM>,
<EM CLASS="Ep">colorspace</EM>,
and
<EM CLASS="Ep">colormap.</EM>
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxaux.makeDIB NX713"CLASS="NX"></A>
<A NAME="::pxaux.makeDIB"CLASS="Sf"></A>
<A NAME="Windows: Make Device Independent Bitmap NX714"CLASS="NX"></A>
<A NAME="Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB"CLASS="Sf"></A>
<A NAME="Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB"></A>
<H6 CLASS="Sf">Windows: Make Device Independent Bitmap   ---   ::pxaux.makeDIB</H6>
<A NAME="::pxaux.freeDIB NX715"CLASS="NX"></A>
<A NAME="::pxaux.freeDIB"CLASS="Sg"></A>
<A NAME="Windows: Free Device Independent Bitmap NX716"CLASS="NX"></A>
<A NAME="Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB"CLASS="Sg"></A>
<A NAME="Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB"></A>
<H6 CLASS="Sg">Windows: Free Device Independent Bitmap   ---   ::pxaux.freeDIB</H6>
<A NAME="::makeDIB"CLASS="Tr"></A>
<A NAME="::freeDIB"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (pxaux.makeDIB) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,Hdibp);
int  (pxaux.freeDIB) (&amp;pxaux,options,unitmap,stateid,framebuf,ulx,uly,lrx,lry,Hdibp);
<BR>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
HANDLE              *Hdibp          // *NULL, becomes *HGLOBAL to DIB
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
An image frame buffer, or an area of interest within the image frame buffer,
is copied to a newly created Windows Device Independent Bitmap (DIB)
in global memory (e.g. using the Windows'
<CITE CLASS="Ec">GlobalAlloc</CITE>)
and the handle to the DIB returned.
<P>
The
<EM CLASS="Ep">::makeDIB</EM>
is identical to
<A HREF="#pxd_renderDIBCreate"CLASS="Er">pxd_renderDIBCreate</A>
except allowing use with an
explicit instance of the XCLIB
library via the
<EM CLASS="Ep">pxaux</EM>
parameter and using an explicit
video state id specified by
<EM CLASS="Ep">stateid</EM>,
previously defined by
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
against which the
<EM CLASS="Ep">framebuf</EM>
and other parameters are interpreted.
The
*<EM CLASS="Ep">Hdibp</EM>
must initially be NULL;
the handle to the DIB is
''returned''
at
*<EM CLASS="Ep">Hdibp</EM>.
<P>
The bitmap created must be freed by
<A HREF="#::freeDIB"CLASS="Er">::freeDIB</A>
when no longer needed.
The
<EM CLASS="Ep">options</EM>,
<EM CLASS="Ep">unitmap</EM>,
<EM CLASS="Ep">stateid</EM>,
<EM CLASS="Ep">framebuf</EM>,
<EM CLASS="Ep">ulx</EM>,
<EM CLASS="Ep">uly</EM>,
<EM CLASS="Ep">lrx</EM>,
and
<EM CLASS="Ep">lry</EM>
parameters are not used and must be 0.
After
<A HREF="#::freeDIB"CLASS="Er">::freeDIB</A>,
the
*<EM CLASS="Ep">Hdibp</EM>
is invalid, set to NULL, and must not be used with any function.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="::pxaux.StretchDIBits NX717"CLASS="NX"></A>
<A NAME="::pxaux.StretchDIBits"CLASS="Sf"></A>
<A NAME="Windows: Display Image Frame Buffer On Device Context NX718"CLASS="NX"></A>
<A NAME="Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits"CLASS="Sf"></A>
<A NAME="Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits"></A>
<H6 CLASS="Sf">Windows: Display Image Frame Buffer On Device Context   ---   ::pxaux.StretchDIBits</H6>
<A NAME="::StretchDIBits"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (pxaux.StretchDIBits) (&amp;pxaux, options, unitmap, stateid, framebuf, ulx, uly, lrx, lry,
                            winopts, hDC, nX, nY, nWidth, nHeight);
<BR>
struct pxauxservice pxaux;          // A pxauxservice instance
int                 options;        // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 stateid;        // Video state id
pxbuffer_t          framebuf;       // Image frame buffer
pxcoord_t           ulx;            // Upper left x coord. of area of interest
pxcoord_t           uly;            // Upper left y coord. of area of interest
pxcoord_t           lrx;            // Lower right x coord. exclusive of AOI
pxcoord_t           lry;            // Lower right y coord. exclusive of AOI
HDC                 hDC;            // Device context
uint                nX;             // Display x position in hDC
uint                nY;             // Display y position in hDC
uint                nWidth;         // Display width in hDC
uint                nHeight;        // Display height in hDC
int                 winoptions;     // Reserved, should be 0
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="Windows NX719"CLASS="NX"></A>
An image frame buffer, or an area of interest within the image frame buffer,
is copied-rendered-displayed to a Windows device context,
typically a display window or a printer context.
<P>
The
<EM CLASS="Ep">::StretchDIBits</EM>,
is identical to
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>
except allowing use with an
explicit instance of the XCLIB
library via the
<EM CLASS="Ep">pxaux</EM>
parameter and using an explicit
video state id specified by
<EM CLASS="Ep">stateid</EM>,
previously defined by
<A HREF="#::defineState"CLASS="Er">::defineState</A>,
against which the
<EM CLASS="Ep">framebuf</EM>
and other parameters are interpreted.
All other parameters of
<EM CLASS="Ep">::StretchDIBits</EM>,
correspond in name and meaning to the
parameters of
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
Same as
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>.
<HR SIZE="3">
<A NAME="Structured Style Interface - Camera Services"CLASS="Ch"></A>
<A NAME="10.  Structured Style Interface - Camera Services"></A>
<H1>10.  Structured Style Interface - Camera Services</H1>
<P>
<HR SIZE="1">
<A NAME="PXCam_SILICONVIDEO2112 NX720"CLASS="NX"></A>
<A NAME="PXCam_SILICONVIDEO2112"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 2112 NX721"CLASS="NX"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 2112   ---   PXCam_SILICONVIDEO2112"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 2112   ---   PXCam_SILICONVIDEO2112"></A>
<H6 CLASS="Sf">Camera Control: SILICON VIDEO&reg; 2112   ---   PXCam_SILICONVIDEO2112</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int PXCam_SILICONVIDEO2112(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV2112State_s *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV2112State_s *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<BR>
<A NAME="Struct PXCam_SV2112State NX722"CLASS="NX"></A>
<A NAME="PXCam_SV2112State, struct NX723"CLASS="NX"></A>
<A NAME="PXCam_SV2112State_s NX724"CLASS="NX"></A>
struct PXCam_SV2112State {
    struct  pxddch  ddch;
<BR>
    int         id;                 // chip id, as reported by camera
    int         frameMode;          // 's': still frame, 'v': video
    int         aoiLeft;            // AOI. These values are ..
    int         aoiTop;             // .. always relative to ..
    int         aoiWidth;           // .. full resolution and ..
    int         aoiHeight;          // .. independent of decimation
    int         testRamp;           // 0: off, 1: on
    int         pixelRegistration;  // 0: off, 1: on
    int         scanDirection;      // ('L'&lt;&lt;8)|'T': L-R/T-B
                                    // ('R'&lt;&lt;8)|'T': R-L/T-B
                                    // ('L'&lt;&lt;8)|'B': L-R/B-T
                                    // ('R'&lt;&lt;8)|'B': R-L/B-T
    int         decimation;         // 0x0101: none
                                    // 0x0202: 2x2
                                    // 0x0404: 4x4
    double      gain[3];            // for R,G,B respectively, in db
    double      exposure;           // in milliseconds
    int         rgbGainLock;        // 0: off, 1: on
    double      extendedLineTime;   // in microseconds
    double      pixelClkFreq;       // in MHz. Info only which must be supplied
<BR>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        double  framerate;          // Hz
        double  exposure;           // millisec
        int     trigger;            // 'n', '+', '-'
        int     strobe;             // 'n', 'p'
        int     bits;               // 8, 10
          ...                       // Internal use
    } adj;
};
typedef struct PXCam_SV2112State PXCam_SV2112State_s;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO 2112 NX725"CLASS="NX"></A>
The
<A HREF="#PXCam_SILICONVIDEO2112"CLASS="Er">PXCam_SILICONVIDEO2112</A>
allows controlling the various options of the SILICON VIDEO&reg; 2112
and SILICON VIDEO&reg; 2112C cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is initialized with camera default parameters.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is used to modify the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
is used to modify the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<EM CLASS="Ep">camstatep</EM>
which is different than the corresponding portions
of the camera state referenced
<EM CLASS="Ep">camstate2p</EM>
are uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
are downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMinimumValuesInCameraState
or
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<EM CLASS="Ep">camstatep</EM>.
Only the
<EM CLASS="Ep">exposure</EM>,
<EM CLASS="Ep">aoiWidth</EM>,
<EM CLASS="Ep">aoiHeight</EM>,
and
<EM CLASS="Ep">gain</EM>
members of the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
are currently set.
Other function arguments are not used.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
The following example adjusts the camera's exposure and gain.
It does not assume that the camera's current parameters are being
kept in a
<EM CLASS="Ep">PXCam_SV2112State_s</EM>
from one invocation to the next.
Should the programmer choose to maintain a copy of the camera's
current parameters, much of the following function could be simplified.
<BLOCKQUOTE>
<PRE>
int set2112ExposureAndGain(int unitmap, double exposure, double redgain, double grngain, double blugain)
{
    extern xclibs_s     xclib;          /* library instance, assumed opened */
    PXCam_SV2112State_s camstate;
    int r;
<BR>
    memset(&amp;camstate, 0, siz(camstate));
    camstate.ddch.len = siz(camstate));
    camstate.ddch.mos = PXMOS_CAMSV2112STATE;
    //
    // Must get camera clock frequency from video state!
    // Or the camera's downloaded exposure and other values
    // won't be computed properly!
    //
    {
        xclib_DeclareVidStateStructs(vidstate);
        xclib_InitVidStateStructs(vidstate);
        xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
        r = PXCam_SILICONVIDEO2112(PXCam_MapVideoStateToCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, &amp;vidstate);
        if (r &lt; 0)
            return(r);
    }
    //
    // Get camera's current state.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_DownloadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Modify the portions corresponding to gain and exposure.
    //
    camstate.gain[0]  = redgain;
    camstate.gain[1]  = grngain;
    camstate.gain[2]  = blugain;
    camstate.exposure = exposure;
    //
    // In case the caller had supplied invalid parameters, correct.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_SetCorrectValuesInCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Upload state to camera.
    // The frame grabber's video state isn't affected by changes
    // to exposure and gain, and need not be reflected back.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_UploadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    return(r);
}
</PRE>
</BLOCKQUOTE>
The following example adjusts the camera's area of interest.
Unlike the example above, the change of the camera area of interest must also
be reflected to the frame grabber.
<BLOCKQUOTE>
<PRE>
int set2112AOI(int unitmap, int ulx, int uly, int width, int height)
{
    extern xclibs_s     xclib;            /* library instance, assumed opened */
    PXCam_SV2112State_s camstate;
    int r;
    xclib_DeclareVidStateStructs(vidstate);
    xclib_InitVidStateStructs(vidstate);
<BR>
    memset(&amp;camstate, 0, siz(camstate));
    camstate.ddch.len = siz(camstate));
    camstate.ddch.mos = PXMOS_CAMSV2112STATE;
    //
    // Must get camera clock frequency from video state!
    // Or the camera's downloaded exposure and other values
    // won't be computed properly!
    //
    xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
    r = PXCam_SILICONVIDEO2112(PXCam_MapVideoStateToCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, &amp;vidstate);
    if (r &lt; 0)
        return(r);
    //
    // Get camera's current state.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_DownloadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Modify the portions corresponding to area of interest.
    //
    camstate.aoiLeft     = ulx;
    camstate.aoiTop      = uly;
    camstate.aoiWidth    = width;
    camstate.aoiHeight   = height;
    //
    // In case the caller had supplied invalid parameters, correct.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_SetCorrectValuesInCameraState, 0, 0, 0, NULL, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Video capture should have been turned off before
    // calling this service. Make sure, but don't wait for
    // end-of-frame termination.
    //
    r =  xclib.xcdev.setAbortLive(&amp;xclib.xcdev, unitmap, 0, PXMODE_DIGI, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Upload state to camera.
    // The frame grabber's video state isn't affected by changes
    // to exposure and gain, and need not be reflected back.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_UploadCameraStateViaHandle, 0, unitmap, PXCam_PortIspxdevservice, &amp;xclib.pxdev, &amp;camstate, NULL, NULL);
    if (r &lt; 0)
        return(r);
    //
    // Reflect AOI into video state.
    //
    r = PXCam_SILICONVIDEO2112(PXCam_MapCameraStateToVideoState, 0, unitmap, 0, NULL, &amp;camstate, NULL, &amp;vidstate);
    if (r &lt; 0)
        return(r);
    //
    // Load video state into frame grabber.
    //
    r = xclib.pxlib.defineState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate)
    if (r &lt; 0)
        return(r);
    r = xclib.xcdev.setVideoConfig(&amp;xclib.xcdev, unitmap, 0, PXMODE_DIGI, NULL, NULL);
    if (r &lt; 0)
        return(r);
    return(0);
}
</PRE>
</BLOCKQUOTE>
<HR SIZE="1">
<A NAME="PXCam_SILICONVIDEO1310 NX726"CLASS="NX"></A>
<A NAME="PXCam_SILICONVIDEO1310"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 1310 NX727"CLASS="NX"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 1310   ---   PXCam_SILICONVIDEO1310"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 1310   ---   PXCam_SILICONVIDEO1310"></A>
<H6 CLASS="Sf">Camera Control: SILICON VIDEO&reg; 1310   ---   PXCam_SILICONVIDEO1310</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int PXCam_SILICONVIDEO1310(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV1310State_s *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV1310State_s *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<BR>
<A NAME="Struct PXCam_SV1310State NX728"CLASS="NX"></A>
<A NAME="PXCam_SV1310State, struct NX729"CLASS="NX"></A>
<A NAME="PXCam_SV1310State_s NX730"CLASS="NX"></A>
struct PXCam_SV1310State {
    struct  pxddch  ddch;
<BR>
    int         id;                 // as reported
    int         negADCRef;          // mV
    int         posADCRef;          // mV
    int         power;              // 1 or 0
    int         videoMode;          // 'c': free-run, 's': controlled
    int         subsampleMode;      // 0: default: 'm': mono, 'b': bayer
    int         subsample;          // 0x101: none  0x102:  0x208:  0x802:
                                    // 0x202: 2x2   0x104:  0x401:  0x804:
                                    // 0x404: 4x4   0x108:  0x402:
                                    // 0x808: 8x8   0x201:  0x408:
                                    // etc.         0x204:  0x801:
    int         aoiLeft;            // AOI. these values are ..
    int         aoiTop;             // .. always relative to ..
    int         aoiWidth;           // .. full resolution and ..
    int         aoiHeight;          // .. independent of subsample
    int         readoutDirection;   // CC('L', 'T'): L-R/T-B
                                    // CC('R', 'T'): R-L/T-B
                                    // CC('L', 'B'): L-R/B-T
                                    // CC('R', 'B'): R-L/B-T
    int         offsetCorrection[64+1]; // mV * 10
    int         frameWidth;         // extended columns to increase frame period
    int         frameHeight;        // extended rows to increase frame period
    int         expGainMode;        // 0: raw, 1: lin1, 2: lin2
    int         clrGainMode;        // 0: raw, 1: lin1
    int         analogOffset;       // mV
    double      colorGain[4];       // gain for Bayer mosaic
    double      gain;               // common gain
    double      exposure;           // msec
    double      framePeriod;        // msec
    int         aoiFramePeriodMin;  // 1: auto set to fastest frame rate, for given AOI
                                    // 0: off
    int         strobeMode;         // 0:  disabled
                                    // '1': One Line
                                    // 'e': exposure
    int         shA;                // internal use
    int         shB;                // internal use
    int         sofDelay;           // internal use
    int         frameClampHeight;   // internal use
    int         frameClampTop;      // internal use
    int         frameClamp;         // 1: auto frame clamp on, 0: off
<BR>
    double      pixelClkFreq;       // in MHz. Info only which must
                                    // be supplied
<BR>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        double  framerate;          // Hz
        double  maxframerate;       // internal use
        int     trigger;            // 'n', '+', '-', 'b'
        int     strobe;             // 'n', 'p'
        int     bits;               // 8, 10
         ...                        // Internal use
    } adj;
};
typedef struct PXCam_SV1310State PXCam_SV1310State_s;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO 1310 NX731"CLASS="NX"></A>
The
<A HREF="#PXCam_SILICONVIDEO1310"CLASS="Er">PXCam_SILICONVIDEO1310</A>
allows controlling the various options of the SILICON VIDEO&reg; 1310
and SILICON VIDEO&reg; 1310C cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is initialized with camera default parameters.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is used to modify the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
is used to modify the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<EM CLASS="Ep">camstatep</EM>
which is different than the corresponding portions
of the camera state referenced
<EM CLASS="Ep">camstate2p</EM>
are uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
are downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMinimumValuesInCameraState
or
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<EM CLASS="Ep">camstatep</EM>.
Only the
<EM CLASS="Ep">colorGain</EM>,
<EM CLASS="Ep">aoiWidth</EM>,
and
<EM CLASS="Ep">aoiHeight</EM>
members of the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
are currently set.
Other function arguments are not used.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="PXCam_SILICONVIDEO1281 NX732"CLASS="NX"></A>
<A NAME="PXCam_SILICONVIDEO1281"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 1281 NX733"CLASS="NX"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 1281   ---   PXCam_SILICONVIDEO1281"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 1281   ---   PXCam_SILICONVIDEO1281"></A>
<H6 CLASS="Sf">Camera Control: SILICON VIDEO&reg; 1281   ---   PXCam_SILICONVIDEO1281</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int PXCam_SILICONVIDEO1281(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV1281State_s *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV1281State_s *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<BR>
<A NAME="Struct PXCam_SV1281State NX734"CLASS="NX"></A>
<A NAME="PXCam_SV1281State, struct NX735"CLASS="NX"></A>
<A NAME="PXCam_SV1281State_s NX736"CLASS="NX"></A>
struct PXCam_SV1281State {
    struct  pxddch  ddch;
<BR>
    int         productID1;         // as reported
    int         productID2;         // as reported
    int         productID3;         // as reported
    int         blacklevel;         // black level, 0 thru 62
    int         sleep;              // sleep mode. 0: off, 1: on
    int         videomode;          // CC('v','i'): video mode
                                    // CC('s','x'): controlled mode
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         extendHBlank;       // lengthen H blanking
    int         extendVBlank;       // lengthen V blanking
                                    // (no effect on current chips)
    double      gain;               // dB. log(1.5) thru log(39.375)
    double      exposure;           // msec
    double      frameperiod;        // rsvd
    double      pixelClkFreq;       // in MHz. Info only which must be supplied
<BR>
    //
    // Chip tweaks which are almost never changed.
    //
    int         bandgap;            // 0: internal, 1: external. reference
    int         clkSchmitt;         // Schmitt trigger. 0: off, 1: on
    int         autoblack;          // 0: internal, 1: external reference
    int         _1stcolamp_rst_cnt; // internal use
    int         _pre_int_rst_cnt;   // internal use
    int         _ds_rst_cnt;        // internal use
    int         _row_sel_wait_cnt;  // internal use
    int         _feed_thru_cnt;     // internal use
    int         rsvd[8];            // internal use
<BR>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
        double  framerate;          // Hz
        double  exposure;           // msec. not used
          ...                       // Internal use
    } adj;
};
typedef struct PXCam_SV1281State PXCam_SV1281State_s;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO 1281 NX737"CLASS="NX"></A>
The
<A HREF="#PXCam_SILICONVIDEO1281"CLASS="Er">PXCam_SILICONVIDEO1281</A>
allows controlling the various options of the SILICON VIDEO&reg; 1281M
and SILICON VIDEO&reg; 1281C cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is initialized with camera default parameters.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is used to modify the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
is used to modify the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<EM CLASS="Ep">camstatep</EM>
which is different than the corresponding portions
of the camera state referenced
<EM CLASS="Ep">camstate2p</EM>
are uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
are downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMinimumValuesInCameraState
or
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<EM CLASS="Ep">camstatep</EM>.
Only the
<EM CLASS="Ep">gain</EM>,
<EM CLASS="Ep">blacklevel</EM>,
<EM CLASS="Ep">aoiWidth</EM>,
and
<EM CLASS="Ep">aoiHeight</EM>
members of the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
are currently set.
Other function arguments are not used.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="PXCam_SILICONVIDEO9M001 NX738"CLASS="NX"></A>
<A NAME="PXCam_SILICONVIDEO9M001"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 9M001 NX739"CLASS="NX"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 9M001   ---   PXCam_SILICONVIDEO9M001"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 9M001   ---   PXCam_SILICONVIDEO9M001"></A>
<H6 CLASS="Sf">Camera Control: SILICON VIDEO&reg; 9M001   ---   PXCam_SILICONVIDEO9M001</H6>
<A NAME="PXCam_SILICONVIDEO9M001 NX740"CLASS="NX"></A>
<A NAME="PXCam_SILICONVIDEO9M001"CLASS="Sg"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 9T001 NX741"CLASS="NX"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 9T001   ---   PXCam_SILICONVIDEO9M001"CLASS="Sg"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 9T001   ---   PXCam_SILICONVIDEO9M001"></A>
<H6 CLASS="Sg">Camera Control: SILICON VIDEO&reg; 9T001   ---   PXCam_SILICONVIDEO9M001</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int PXCam_SILICONVIDEO9M001(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV9M001State_s *camstatep;    // Pointer to SILICON VIDEO parameters
PXCam_SV9M001State_s *camstate2p;   // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<BR>
<A NAME="Struct PXCam_SV9M001State NX742"CLASS="NX"></A>
<A NAME="PXCam_SV9M001State, struct NX743"CLASS="NX"></A>
<A NAME="PXCam_SV9M001State_s NX744"CLASS="NX"></A>
struct PXCam_SV9M001State {
    struct  pxddch  ddch;
<BR>
    int         ID;                 // chip ID as reported
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         subsample;          // 0x101: none  0x204: 2x4
                                    // 0x202: 2x2   0x208: 2x8
                                    // 0x404: 4x4   0x401: 4x1
                                    // 0x808: 8x8   0x402: 4x2
                                    // 0x102: 1x2   0x408: 4x8
                                    // 0x104: 1x4   0x801: 8x1
                                    // 0x108: 1x8   0x802: 8x2
                                    // 0x201: 2x1   0x804: 8x4
    int         subbinning;         // 0: subsample is subsampling
                                    // 1: subsample is binning
                                    // SV9T001 only
    int         scanDirection;      // CC('R','T'): L-R/T-B
                                    // CC('R','B'): L-R/B-T
                                    // SV9M001 only
    int         testdata;           // 1: on, 0: off
    int         chipenable;         // 1: on, 0: off
    int         videoMode;          // 'c': free-run, 's': controlled
    int         hBlank;             // lengthen H blanking - set via framePeriod
    int         vBlank;             // lengthen V blanking - set via framePeriod
    int         blackLevelMode;     // 'n': auto/ADC, 'c': auto (SV9M001 only)
                                    // 'm': manual, 'd': disabled (SV9M001 only)
    int         strobeMode;         // 0: disabled, 'e': exposure,
                                    // '1': one line
    int         microExposure;      // 1: allow short exposure less than 1 line,
                                    // 0: don't
                                    // SV9M001 only
    int         macroExposure;      // 1: allow long exposure
                                    // 0: don't
    int         blackrgb[4];        // rsvd. 0
    int         blacklevel;         // black level
                                    // SV9T001 only
        ...                         // Internal use
    double      gainrgb[4];         // Gb/B/R/Gr dB
    double      exposure;           // exposure period, msec
    double      shutterDelay;       // rsvd. 0
    double      framePeriod;        // frame period, msec
    double      pixelClkFreq;       // in MHz. Info only which must be supplied
    double      digitalgain;        // digital gain
                                    // SV9T001 only
        ...                         // Internal use
<BR>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
        double  framerate;          // Hz
        double  exposure;           // msec. not used
        int     bits;               // 8, 10
          ...                       // Internal use
    } adj;
};
typedef struct PXCam_SV9M001State PXCam_SV9M001State_s;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO 9M001 NX745"CLASS="NX"></A>
The
<A HREF="#PXCam_SILICONVIDEO9M001"CLASS="Er">PXCam_SILICONVIDEO9M001</A>
allows controlling the various options of the
SILICON VIDEO&reg; 9M001,
SILICON VIDEO&reg; 9M001C, and
SILICON VIDEO&reg; 9T001C,
cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
are downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
Because
<A HREF="#PXCam_SILICONVIDEO9M001"CLASS="Er">PXCam_SILICONVIDEO9M001</A>
is intended to operate
two similar, but different, cameras, the
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraIDStateViaHandle
must be used to obtain the camera ID so that other commands, below,
can adapt properly.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is initialized with camera default parameters.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is used to modify the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
is used to modify the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<EM CLASS="Ep">camstatep</EM>
which is different than the corresponding portions
of the camera state referenced
<EM CLASS="Ep">camstate2p</EM>
are uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMinimumValuesInCameraState
or
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<EM CLASS="Ep">camstatep</EM>.
Only the
<EM CLASS="Ep">gainrgb[]</EM>,
<EM CLASS="Ep">aoiWidth</EM>,
<EM CLASS="Ep">aoiHeight</EM>,
<EM CLASS="Ep">exposure</EM>,
and
<EM CLASS="Ep">digitalgain</EM>
members of the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
are currently set.
Other function arguments are not used.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="1">
<A NAME="PXCam_SILICONVIDEO642 NX746"CLASS="NX"></A>
<A NAME="PXCam_SILICONVIDEO642"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 642 NX747"CLASS="NX"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 642   ---   PXCam_SILICONVIDEO642"CLASS="Sf"></A>
<A NAME="Camera Control: SILICON VIDEO&reg; 642   ---   PXCam_SILICONVIDEO642"></A>
<H6 CLASS="Sf">Camera Control: SILICON VIDEO&reg; 642   ---   PXCam_SILICONVIDEO642</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int PXCam_SILICONVIDEO642(cmnd, rsvd, unitmap, porttype, port, camstatep, camstate2p, vidstatep);
int                 cmnd;           // A PXCam_ command verb
int                 rsvd;           // Reserved, should be 0
int                 unitmap;        // Unit selection bit map (1 for single unit)
int                 porttype;       // A PXCam_ port selection verb
void                *port;          // Point to port instance, dependent on porttype
PXCam_SV642State_s  *camstatep;     // Pointer to SILICON VIDEO parameters
PXCam_SV642State_s  *camstate2p;    // Pointer to SILICON VIDEO parameters
struct pxvidstate   *vidstatep;     // Pointer to video state
<BR>
<A NAME="Struct PXCam_SV642State NX748"CLASS="NX"></A>
<A NAME="PXCam_SV642State, struct NX749"CLASS="NX"></A>
<A NAME="PXCam_SV642State_s NX750"CLASS="NX"></A>
struct PXCam_SV642State {
    struct  pxddch  ddch;
<BR>
    int         aoiLeft;            // capture AOI
    int         aoiTop;             //  ..
    int         aoiWidth;           //  ..
    int         aoiHeight;          //  ..
    int         hBlank;             // lengthen H blanking - set via framePeriod
    int         vBlank;             // lengthen V blanking - set via framePeriod
    int         gainrange;          // 10: high range, 5: low range
    int         videoMode;          // CCC('m','c','i'): free-run
                                    // CCC('s','s','e'): controlled
                                    // CCC('m','c','e'): master/Cont/Seq
                                    // CCC('s','c','e'): slave/Cont/Seq
    int         interlaceMode;      // 0: progressive
                                    // 1: interlaced
                                    // 2: one field
    int         macroExposure;      // 1: allow long exposure
                                    // 0: don't
<BR>
    int         VLNAMP;             // voltage references and internal
    int         VLNOUT;             // default versus explicit selection
    int         VLN1;               //  ..
    int         VLN2;               //  ..
    int         VLN2BOOST;          //  ..
    int         VLP;                //  ..
    int         VREF;               //  ..
    int         VOFF;               //  ..
    int         VREF1;              //  ..
    int         VREF2;              //  ..
    int         vref;               //  ..
    int         vref2;              //  ..
    int         vref1;              //  ..
    int         voff;               //  ..
    int         rsvd1[8];
<BR>
    double      exposure;           // exposure period, msec
    double      framePeriod;        // frame period, msec
    double      gainrgb[4];         // Gb/B/R/Gr dB
    double      pixelClkFreq;       // in MHz. Info only which must
                                    // be supplied
        ...                         // Internal use
<BR>
    struct {                        // controlled mode:
        int     mode;               // 's', 'c'
        int     trigger;            // 'n', '+', '-', 'b'
        int     bits;               // 8, 10
        ...                         // Internal use
        double  framerate;          // Hz
        double  exposure;           // msec. not used
        double  maxframerate;
        ...                         // Internal use
    } adj;
<BR>
};
typedef struct PXCam_SV642State PXCam_SV642State_s;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
<A NAME="SILICON VIDEO 642 NX751"CLASS="NX"></A>
The
<A HREF="#PXCam_SILICONVIDEO642"CLASS="Er">PXCam_SILICONVIDEO642</A>
allows controlling the various options of the
SILICON VIDEO&reg; 642M
and
SILICON VIDEO&reg; 642C
cameras,
by downloading and uploading camera parameters.
It also allows mapping video state parameters into the camera parameters,
or vice versa, so that the PIXCI(rg state can be consistent with that
of the camera.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraIDStateViaHandle,
the ID portions of the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
are downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetDefaultValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is initialized with camera default parameters.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetCorrectValuesInCameraState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is corrected so that the parameters are valid and consistent.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapCameraStateToVideoState,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is used to modify the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified video state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_MapVideoStateToCameraState,
the video state referenced by
<EM CLASS="Ep">vidstatep</EM>
is used to modify the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
so as to be consistent.
This does not, by itself, implement the modified camera state.
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_UploadCameraStateDeltaViaHandle
those portions of the camera state referenced
by
<EM CLASS="Ep">camstatep</EM>
which is different than the corresponding portions
of the camera state referenced
<EM CLASS="Ep">camstate2p</EM>
are uploaded to the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_DownloadCameraStateViaHandle,
the camera state referenced by
<EM CLASS="Ep">camstatep</EM>
is downloaded from the camera.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_InitCameraStateViaHandle,
the camera is (re)initialized with standard defaults.
The
<EM CLASS="Ep">porttype</EM>
must be PXCam_PortIspxdevservice,
the
<EM CLASS="Ep">port</EM>
must be a (pxdevservice_s*).
Other function arguments are not used.
<P>
If
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMinimumValuesInCameraState
or
<EM CLASS="Ep">cmnd</EM>=PXCam_SetMaximumValuesInCameraState
the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
is filled with minimal or maximal allowed values, respectively,
relative to the current camera state referenced by
<EM CLASS="Ep">camstatep</EM>.
Only the
<EM CLASS="Ep">gainrgb[]</EM>,
<EM CLASS="Ep">aoiWidth</EM>,
and
<EM CLASS="Ep">aoiHeight</EM>
members of the camera state referenced by
<EM CLASS="Ep">camstate2p</EM>
are currently set.
Other function arguments are not used.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
<DL>
<BR><DT>0<DD>
Operation complete.
<BR><DT>PXERROR<DD>
Invalid parameters.
<BR><DT>PXER...<DD>
Other error codes as appropriate.
</DL>
<HR SIZE="3">
<A NAME="Device Independent Image Access Interface"CLASS="Ch"></A>
<A NAME="11.  Device Independent Image Access Interface"></A>
<H1>11.  Device Independent Image Access Interface</H1>
<P>
The
<EM CLASS="Ep">pximage</EM>
and
<EM CLASS="Ep">pximage3</EM>
interfaces support a variety of device independent services
to access image buffers.
They are device independent in that,
in conjunction with the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>,
a
<EM CLASS="Ep">pximage</EM>
or
<EM CLASS="Ep">pximage3</EM>
can be constructed to provide access to images in program memory buffers,
disk files, or other media;
using any pixel format, resolution, and bit depth
unconstrained by PIXCI(rg support.
All such images described by a
<EM CLASS="Ep">pximage</EM>
or
<EM CLASS="Ep">pximage3</EM>
can be accessed in the same manner, or processed by
<CITE CLASS="Ec">PXIPL</CITE>
functions.<A HREF="#Footnote 35"CLASS="Ff"><SUP>[35]</SUP></A>
<HR SIZE="1">
<A NAME="Struct pximage NX752"CLASS="NX"></A>
<A NAME="Struct pximage"CLASS="Sf"></A>
<A NAME="PXIMAGE: Image and Pixel Specifications NX753"CLASS="NX"></A>
<A NAME="PXIMAGE: Image and Pixel Specifications   ---   Struct pximage"CLASS="Sf"></A>
<A NAME="PXIMAGE: Image and Pixel Specifications   ---   Struct pximage"></A>
<H6 CLASS="Sf">PXIMAGE: Image and Pixel Specifications   ---   Struct pximage</H6>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
<A NAME="Type pxcoord_t NX754"CLASS="NX"></A>
<A NAME="pxcoord_t NX755"CLASS="NX"></A>
<A NAME="pxcoord_t"CLASS="Tr"></A>
typedef int pxcoord_t;      // a coordinate
<BR>
<A NAME="Struct pxy NX756"CLASS="NX"></A>
<A NAME="pxy, struct NX757"CLASS="NX"></A>
<A NAME="pxy_s NX758"CLASS="NX"></A>
<A NAME="pxypoint_s NX759"CLASS="NX"></A>
<A NAME="pxy"CLASS="Tr"></A>
<A NAME="pxy_s"CLASS="Tr"></A>
<A NAME="pxypoint_s"CLASS="Tr"></A>
struct pxy {                // a pair of coordinates
    pxcoord_t   x;
    pxcoord_t   y;
};
typedef struct pxy pxy_s;
typedef struct pxy pxypoint_s;
<BR>
<A NAME="Struct pxywindow NX760"CLASS="NX"></A>
<A NAME="pxywindow, struct NX761"CLASS="NX"></A>
<A NAME="pxywindow_s NX762"CLASS="NX"></A>
<A NAME="pxywindow"CLASS="Tr"></A>
<A NAME="pxywindow_s"CLASS="Tr"></A>
struct pxywindow {          // a pair of 2-d points
    struct  pxy nw;         // north west corner inclusive
    struct  pxy se;         // south east corner, usually exclusive
};
typedef struct pxywindow pxywindow_s;
<BR>
<A NAME="Struct pxyz NX763"CLASS="NX"></A>
<A NAME="pxyz, struct NX764"CLASS="NX"></A>
<A NAME="pxyz_s NX765"CLASS="NX"></A>
<A NAME="pxyzpoint_s NX766"CLASS="NX"></A>
<A NAME="pxyz"CLASS="Tr"></A>
<A NAME="pxyz_s"CLASS="Tr"></A>
<A NAME="pxyzpoint_s"CLASS="Tr"></A>
struct pxyz {               // a triplet of coordinates
    pxcoord_t   x;
    pxcoord_t   y;
    pxcoord_t   z;
};
typedef struct pxyz pxyz_s;
typedef struct pxyz pxyzpoint_s;
<BR>
<A NAME="Struct pxyzwindow NX767"CLASS="NX"></A>
<A NAME="pxyzwindow, struct NX768"CLASS="NX"></A>
<A NAME="pxyzwindow_s NX769"CLASS="NX"></A>
<A NAME="pxyzwindow"CLASS="Tr"></A>
<A NAME="pxyzwindow_s"CLASS="Tr"></A>
struct pxyzwindow {         // a pair of 3-d points
    struct  pxyz nw;        // north west inner corner inclusive
    struct  pxyz se;        // south east outer corner, usually exclusive
};
typedef struct pxyzwindow pxyzwindow_s;
<BR>
struct pximagedata {        // pixel and pixie data descriptor
    int     pixietype;      // pixel type: PXDATUCHAR, PXDATUSHORT, PXDATULONG, PXDATFLOAT, etc.
    int     pixies;         // samples/colors/components per pixel: 1, 2, 3, ...
    int     pixelhint;      // hints on pixel interpretation
<BR>
    union {
      struct {              //for (unsigned) integer pixels
        int bitsused;       //   significant bits per pixie: 8,12,...
        int bitsxsb;        //   PXDATMSB | PXDATLSB: significant bits @ lsb|msb
                            //                  both: all bits used
        uint16 dirtyread;   //   PXDATDIRTY: unused read bits may not be zero
                            //            0: unused read bits are zero
        uint16 dirtyrite;   //   PXDATDIRTY: unused written bits needn't be zero?
                            //            0: unused written bits must    be zero?
        uint16 endian;      //  PXDATENDIAN: has wrong byte endian for current
                            //            0: has correct byte endian for host
      } i;                  //for (unsigned) integer pixels
<BR>
      struct {              //for real (float) pixels
        float minvalue;     //   bottom of range
        float maxvalue;     //   top of range
      } r;                  //for real (float) pixels
    } u;
};
typedef struct pximagedata  pximagedata_s;
<BR>
struct pximagefacts {       // derived facts and other image status
                            // derived from pixies, pixietype
    int     pixiesize;      // bytes per component value
    int     pixelsize;      // bytes per pixel
<BR>
                            // derived from pixies, pixietype:
    uint    pixieuint: 1;   // - pixel components are positive ints
    uint    pixiereal: 1;   // - pixel components are real
<BR>
    ...
};
typedef struct pximagefacts pximagefacts_s;
<BR>
struct pximagehints {
    float   pixelwidth;     // X axis width of 1 pixel. 0 if unknown
    float   pixelheight;    // Y axis height of 1 pixel. 0 if unknown
    float   pixeldepth;     // Z axis depth of 1 pixel. 0 if unknown
    uchar   widthunits;     // PXUNIT* real world units
    uchar   heightunits;    // PXUNIT* real world units
    uchar   depthunits;     // PXUNIT* real world units
<BR>
    ...
};
typedef struct pximagehints pximagehints_s;
<BR>
struct pximage {
    struct pxywindow wind;      // size: subwindow within imdim
    pxcoord_t        pad2[2];
    struct pxywindow imdim;     // size: nw.x = nw.y = 0, se.x &amp; se.y is dimension of image
    pxcoord_t        pad1[2];
<BR>
    struct pximagedata  d;      // type: pixel descriptor
    struct pximagefacts f;      // type: derived &amp; other facts
    struct pximagehints h;      // interpretation hints
<BR>
    ... member functions (methods) ...
    ... private state ...
};
<BR>
struct pximage3 {
    struct pxyzwindow wind;     // size: subwindow within imdim
    struct pxyzwindow imdim;    // size: nw.x = nw.y = 0, se.x &amp; se.y is dimension of image
<BR>
    struct pximagedata  d;      // type: pixel descriptor
    struct pximagefacts f;      // type: derived &amp; other facts
    struct pximagehints h;      // interpretation hints
<BR>
    ... member functions (methods) ...
    ... private state ...
};
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
A
<EM CLASS="Ep">pximage</EM>
structure, after successful construction by
<A HREF="#::pxlib.initPximage"CLASS="Er">::pxlib.initPximage</A>,
<CITE CLASS="Ec">pximage_file</CITE>,
<CITE CLASS="Ec">pximage_memory</CITE><A HREF="#Footnote 36"CLASS="Ff"><SUP>[36]</SUP></A>,
or similar functions,
provides several members (fields)
with values of interest to the application program(er).
The public fields of interest,
excepting the member functions (methods), are shown above.
<P>
If using a prewritten image processing function on the
<EM CLASS="Ep">pximage</EM>,
only the
<EM CLASS="Ep">imdim</EM>
and
<EM CLASS="Ep">wind</EM>
are typically needed &mdash;
to set an area of interest to the full dimensions of the image,
or a subset thereof.
<P>
If writing custom image processing functions,
additional members which specify the type, precision, and dimensionality
of pixels are typically used.
<P>
Except where explicitly differentiated, this discussion applies
to both two-dimensional
<EM CLASS="Ep">pximage</EM>
as well as three-dimensional
<EM CLASS="Ep">pximage3</EM>
structures;
the
<EM CLASS="Ep">pximage3</EM>
differing with three-dimensional spatial coordinates.
<P>
Except for the
<EM CLASS="Ep">wind</EM>
member, and (rarely) the
<EM CLASS="Ep">pixelhint</EM>
and
<EM CLASS="Ep">h</EM>
members, discussed below, the various members of the
<EM CLASS="Ep">pximage</EM>
must never be directly modified by the application program.
<P>
The
<EM CLASS="Ep">imdim</EM>
specifies the image's dimensions;
the
<EM CLASS="Ep">imdim.se.x</EM>,
<EM CLASS="Ep">imdim.se.y</EM>,
and
<EM CLASS="Ep">imdim.se.z</EM>
(for
<EM CLASS="Ep">pximage3</EM>)
are the
''x''
(horizontal),
''y''
(vertical),
and
''z''
(depth for
<EM CLASS="Ep">pximage3</EM>)
dimensions.
The
<EM CLASS="Ep">imdim.nw.x</EM>,
<EM CLASS="Ep">imdim.nw.y</EM>,
and
<EM CLASS="Ep">imdim.nw.z</EM>
(for
<EM CLASS="Ep">pximage3</EM>)
are always 0,
and allow convenient use of the
<EM CLASS="Ep">imdim</EM>
as a
<EM CLASS="Ep">pxywindow</EM>
(or
<EM CLASS="Ep">pxyzwindow</EM>)
which specifies a full image window.
<P>
The
<EM CLASS="Ep">wind</EM>
specifies an area of interest, equal to or smaller than
the full image resolution.
The
<EM CLASS="Ep">imdim.nw.x</EM>,
<EM CLASS="Ep">imdim.nw.y</EM>,
and
<EM CLASS="Ep">imdim.nw.z</EM>
(for
<EM CLASS="Ep">pximage3</EM>)
are the
''x''
(horizontal),
''y''
(vertical),
and
''z''
(depth for
<EM CLASS="Ep">pximage3</EM>)
coordinates of the area of interest's upper left corner, inclusive;
the
<EM CLASS="Ep">imdim.se.x</EM>,
<EM CLASS="Ep">imdim.se.y</EM>,
and
<EM CLASS="Ep">imdim.se.z</EM>
(for
<EM CLASS="Ep">pximage3</EM>)
are coordinates of the area of interest's lower left corner, exclusive.
The choice of inclusive/exclusive coordinates allows a full image area
of interest to be specified by the same values as within
<EM CLASS="Ep">imdim</EM>.
For historical reasons, the
<EM CLASS="Ep">wind</EM>
members may be directly altered by the application program;
although such direct modification is not suggested for new applications
(use the
<EM CLASS="Ep">::xwind</EM>
service instead).
When modified directly, it is the application program's
responsibility to maintain legitimate values in
<EM CLASS="Ep">wind</EM>
&mdash; i.e. window dimensions larger than 0 and smaller than or equal to the
image dimensions.
<P>
The
<EM CLASS="Ep">d.pixies</EM>
is the number of numeric components
(i.e. ``pixies''),
or the dimensionality, of each pixel.
The
<EM CLASS="Ep">d.pixies</EM>
would be 1 for monochrome imagery,
2 for complex values (either real and imaginary or magnitude and phase),
and 3 or 4 for RGB, YIQ, CMYK, HSI, or other color spaces.
<P>
The
<EM CLASS="Ep">d.pixietype</EM>
is the fundamental, optimal, data type to be used for each pixie.
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
C Type                  
</TD>
<TD ALIGN="left" COLSPAN="1">
 pixietype
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
unsigned char           
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUCHAR
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
unsigned short          
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUSHORT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
unsigned int            
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
unsigned long           
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATULONG
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
float                   
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATFLOAT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
double                  
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATDOUBLE
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
 8 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT8
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
16 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT16
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
32 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT32
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(see NULL image, below) 
</TD>
<TD ALIGN="left" COLSPAN="1">
 0
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
Some of the above constants are synonymous,
as per the current programming environment.
For example, in typical 32 bit environments
PXDATUINT8 is identical both in meaning and value to PXDATUCHAR,
PXDATUINT16 is identical to PXDATUSHORT,
and
PXDATUINT32 is identical to PXDATUINT.
The PXDATULONG is not available in programming environments where a
''long''
is 64 bits.
Use of PXDATUINT8, PXDATUINT16, and PXDATUINT32
instead of PXDATUCHAR, PXDATUSHORT, PXDATUINT, and PXDATULONG
is recommended for easier portability between 16, 32, and 64 bit
programming environments.
<P>
Some
<EM CLASS="Ep">pximage</EM>
device drivers
may allow pixies to be read or written into types other than
<EM CLASS="Ep">d.pixietype</EM>,
but reading or writing into a data type matching
<EM CLASS="Ep">d.pixietype</EM>
would be more efficient.
<P>
For
<EM CLASS="Ep">d.pixietype</EM>'s
that are unsigned integer, the
<EM CLASS="Ep">f.pixieuint</EM>
will be one, and the
<EM CLASS="Ep">u.i</EM>
members provide additional interpretation
of the pixie's values.
The
<EM CLASS="Ep">u.i.bitsused</EM>
is the number of bits of each
<EM CLASS="Ep">d.pixietype</EM>
actually used.
When fewer
<EM CLASS="Ep">u.i.bitsused</EM>
are used than actually available in each
<EM CLASS="Ep">d.pixietype</EM>,
the
<EM CLASS="Ep">u.i.bitsxsb</EM>
is PXDATLSB to indicate the bits used are right justified
within the data type,
or PXDATMSB to indicate the bits used are left justified
within the data type.
When all bits of the
<EM CLASS="Ep">d.pixietype</EM>,
are used, the
<EM CLASS="Ep">u.i.bitsxsb</EM>
is PXDATMSB|PXDATLSB.
<P>
For example, on hosts where an
''unsigned short''
is 16 bits, if
<EM CLASS="Ep">u.i.bitsused</EM>=12
and
<EM CLASS="Ep">u.i.bitsxsb</EM>=PXDATLSB,
the range of pixel values is from 0 to 2<SMALL><SUP>12</SUP></SMALL>-1 (4095) in steps of 1.
If
<EM CLASS="Ep">u.i.bitsused</EM>=10
and
<EM CLASS="Ep">u.i.bitsxsb</EM>=PXDATMSB,
the range of pixel values is from 0 to 2<SMALL><SUP>16</SUP></SMALL>-1 (65535)
in steps of 2<SMALL><SUP>6</SUP></SMALL> (64).<A HREF="#Footnote 37"CLASS="Ff"><SUP>[37]</SUP></A>
<P>
When fewer
<EM CLASS="Ep">u.i.bitsused</EM>
are used than actually available in each
<EM CLASS="Ep">d.pixietype</EM>,
the
<EM CLASS="Ep">u.i.dirtyread</EM>
indicates whether the unused bits will be read as zero
or may contain random values.
Likewise, the
<EM CLASS="Ep">u.i.dirtyrite</EM>
indicates whether the unused bits must be written as zero,
or may contain random values.
<P>
For
<EM CLASS="Ep">d.pixietype</EM>'s
utilizing more than 1 byte,
the
<EM CLASS="Ep">u.i.endian</EM>
indicates whether the byte order, little endian or big endian,
matches the host's natural default.
<P>
For
<EM CLASS="Ep">d.pixietype</EM>'s
that are floating point,
the
<EM CLASS="Ep">f.pixiereal</EM>
will be one and the
<EM CLASS="Ep">u.r</EM>
members provide additional interpretation
of the pixie's values.
The
<EM CLASS="Ep">u.r.minvalue</EM>
and
<EM CLASS="Ep">u.r.maxvalue</EM>
specify the pixie's
minimum and maximum values, respectively.
<P>
The
<EM CLASS="Ep">d.pixelhint</EM>
is a hint to how the pixel, particularly multiple component pixels
(i.e. color), is to be interpreted.
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
pixelhint      
</TD>
<TD ALIGN="left" COLSPAN="1">
 Number of  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Interpretation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
               
</TD>
<TD ALIGN="left" COLSPAN="1">
 Components 
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTNONE (=0)
</TD>
<TD ALIGN="left" COLSPAN="1">
 unknown    
</TD>
<TD ALIGN="left" COLSPAN="1">
 Unknown
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTGREY     
</TD>
<TD ALIGN="left" COLSPAN="1">
 1          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Grey scale monochrome
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTINDEX    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Index into (unspecified) palette
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBAYER    
</TD>
<TD ALIGN="left" COLSPAN="1">
 1          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Bayer pattern RGB
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTCOMPLEX  
</TD>
<TD ALIGN="left" COLSPAN="1">
 2          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Complex, probably of monochrome data
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTCBYCRY   
</TD>
<TD ALIGN="left" COLSPAN="1">
 2          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cb,Y,Cr,Y,Cb,Y,Cr,Y,... (YCrCb,UYVY)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCBYCR   
</TD>
<TD ALIGN="left" COLSPAN="1">
 2          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Y,Cb,Y,Cr,Y,Cb,Y,Cr,... (YCrCb,YUY2)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTCRYCBY   
</TD>
<TD ALIGN="left" COLSPAN="1">
 2          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cr,Y,Cb,Y,Cr,Y,Cb,Y,... (YCrCb,VYUY)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRYCB   
</TD>
<TD ALIGN="left" COLSPAN="1">
 2          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Y,Cr,Y,Cb,Y,Cr,Y,Cb,... (YCrCb,YVYU)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGR      
</TD>
<TD ALIGN="left" COLSPAN="1">
 3          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue,Green,Red,... (RGB)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCB    
</TD>
<TD ALIGN="left" COLSPAN="1">
 3          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Y,Cr,Cb,Y,Cr,Cb,... (YCrCb)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBSH      
</TD>
<TD ALIGN="left" COLSPAN="1">
 3          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Brightness,Saturation,Hue,... (HSB)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGB      
</TD>
<TD ALIGN="left" COLSPAN="1">
 3          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red,Green,Blue,... (RGB)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTBGRX     
</TD>
<TD ALIGN="left" COLSPAN="1">
 4          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Blue,Green,Red,Pad,... (RGB)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTYCRCBX   
</TD>
<TD ALIGN="left" COLSPAN="1">
 4          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Y,Cr,Cb,Pad,Y,Cr,Cb,Pad,...  (YCrCb)
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTRGBX     
</TD>
<TD ALIGN="left" COLSPAN="1">
 4          
</TD>
<TD ALIGN="left" COLSPAN="1">
 Red,Green,Blue,Pad,... (RGB)
</TD>
</TR>
<TR><TD COLSPAN="3"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXHINTUSER     
</TD>
<TD ALIGN="left" COLSPAN="1">
 unknown    
</TD>
<TD ALIGN="left" COLSPAN="1">
 User-defined types: from PXHINTUSER
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
               
</TD>
<TD ALIGN="left" COLSPAN="1">
            
</TD>
<TD ALIGN="left" COLSPAN="1">
 thru PXHINTUSER+PXHINTUSERN
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
For example, PXHINTBGRX hints that the first pixie is the Blue value,
followed by values of Green, Red, and a fourth, unused, pixie value.<A HREF="#Footnote 38"CLASS="Ff"><SUP>[38]</SUP></A>
<P>
The
<EM CLASS="Ep">h.pixelwidth</EM>,
<EM CLASS="Ep">h.pixelheight</EM>
and
<EM CLASS="Ep">h.pixeldepth</EM>
provide a hint on the real-world width, height, and depth
of a pixel;
any may be 0 if no information is available.
The
<EM CLASS="Ep">h.widthunits</EM>,
<EM CLASS="Ep">h.heightunits</EM>,
and
<EM CLASS="Ep">h.depthunits</EM>
specify the units of the
<EM CLASS="Ep">h.pixelwidth</EM>,
<EM CLASS="Ep">h.pixelheight</EM>,
and
<EM CLASS="Ep">h.pixeldepth</EM>
values, respectively.
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
widthunits        
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
heightunits       
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
depthunits        
</TD>
<TD ALIGN="left" COLSPAN="1">
 Interpretation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITUNKNOWN (=0)
</TD>
<TD ALIGN="left" COLSPAN="1">
 Unknown
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITRATIO       
</TD>
<TD ALIGN="left" COLSPAN="1">
 Unitless, relative ratio
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITINCH        
</TD>
<TD ALIGN="left" COLSPAN="1">
 Inches
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITFOOT        
</TD>
<TD ALIGN="left" COLSPAN="1">
 Feet
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITMETER       
</TD>
<TD ALIGN="left" COLSPAN="1">
 Meters
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITMILLIMETER  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Millimeters
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITCENTIMETER  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Centimeters
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXUNITSECOND      
</TD>
<TD ALIGN="left" COLSPAN="1">
 Seconds
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
<P>
A
<EM CLASS="Ep">pximage</EM>
which has been unsuccessfully constructed will be a so-called NULL image.
All members shown above will be 0; thus the image dimensions
will be 0, as will the
<EM CLASS="Ep">d.pixietype</EM>.
The member functions (methods) can be safely invoked; they refer
to no-op functions which do nothing.
<HR SIZE="1">
<A NAME="pximage::xwind NX770"CLASS="NX"></A>
<A NAME="pximage::xwind"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set &amp; Get Area of Interest Window NX771"CLASS="NX"></A>
<A NAME="PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind"></A>
<H6 CLASS="Sf">PXIMAGE: Set &amp; Get Area of Interest Window   ---   pximage::xwind</H6>
<A NAME="::xwind NX772"CLASS="NX"></A>
<A NAME="::xwind"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
struct pxywindow * (ip-&gt;xwind)(ip, wp, mode);
struct pximage      *ip;            // Pointer to pximage instance
struct pxywindow    *wp;            // Pinter to area of interest, or NULL
int                 mode;           // 'i': Get full image dimensions
                                    // 'w': Det area of interest dimensions
                                    // 's': Set area of interest dimensions
<BR>
struct pxyzwindow * (ip3-&gt;xwind)(ip3, wp3, mode);
struct pximage3     *ip3;           // Pointer to pximage3 instance
struct pxyzwindow   *wp3;           // Pointer to area of interest, or NULL
int                 mode;           // As above
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The area of interest window associated with the
<EM CLASS="Ep">pximage</EM>
instance referenced by
<EM CLASS="Ep">ip</EM>,
or the
<EM CLASS="Ep">pximage3</EM>
instance referenced by
<EM CLASS="Ep">ip3</EM>,
is retrieved or modified.
<P>
If
<EM CLASS="Ep">mode</EM>='i',
the
<EM CLASS="Ep">ip</EM>'s
(<EM CLASS="Ep">ip3</EM>'s)
full image dimensions, expressed as a
<EM CLASS="Ep">pxywindow</EM>
(<EM CLASS="Ep">pxyzwindow</EM>)
structure are retrieved.
A pointer to the
<EM CLASS="Ep">pxywindow</EM>
(<EM CLASS="Ep">pxyzwindow</EM>)
dimensions is returned, and
if
<EM CLASS="Ep">wp</EM>&ne;NULL
(<EM CLASS="Ep">wp3</EM>&ne;NULL),
the
<EM CLASS="Ep">pxywindow</EM>
(<EM CLASS="Ep">pxyzwindow</EM>)
is also copied to
*<EM CLASS="Ep">wp</EM>
(*<EM CLASS="Ep">wp3).</EM>
<P>
If
<EM CLASS="Ep">mode</EM>='w',
the
<EM CLASS="Ep">ip</EM>'s
(<EM CLASS="Ep">ip3</EM>'s)
current area of interest dimensions, expressed as a
<EM CLASS="Ep">pxywindow</EM>
(<EM CLASS="Ep">pxyzwindow</EM>)
structure are retrieved.
A pointer to the
<EM CLASS="Ep">pxywindow</EM>
(<EM CLASS="Ep">pxyzwindow</EM>)
dimensions is returned, and
if
<EM CLASS="Ep">wp</EM>&ne;NULL
(<EM CLASS="Ep">wp3</EM>&ne;NULL),
the
<EM CLASS="Ep">pxywindow</EM>
(<EM CLASS="Ep">pxyzwindow</EM>)
is also copied to
*<EM CLASS="Ep">wp</EM>
(*<EM CLASS="Ep">wp3).</EM>
<P>
If
<EM CLASS="Ep">mode</EM>='s',
the
<EM CLASS="Ep">ip</EM>'s
(<EM CLASS="Ep">ip3</EM>'s)
area of interest is set to
*<EM CLASS="Ep">wp</EM>
(*<EM CLASS="Ep">wp3</EM>);
if
<EM CLASS="Ep">wp</EM>=NULL
(<EM CLASS="Ep">wp3</EM>=NULL),
the area of interest is set to the full image dimensions.
A pointer to the new area of interest dimensions is returned.
<P>
If the area of interest specified by
*<EM CLASS="Ep">wp</EM>
(*<EM CLASS="Ep">wp3</EM>)
is invalid, all members of the area of interest window
are set to 0 and the
<EM CLASS="Ep">pximage</EM>'s
(<EM CLASS="Ep">pximage3</EM>'s)
<EM CLASS="Ep">::ioset</EM>,
<EM CLASS="Ep">::bxts</EM>,
and
<EM CLASS="Ep">::imapset</EM>
services will not succeed
until a valid area of interest window is set.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<HR SIZE="1">
<A NAME="pximage::aeiou NX773"CLASS="NX"></A>
<A NAME="pximage::aeiou"CLASS="Sf"></A>
<A NAME="PXIMAGE: Get Advice, Errors, Info &amp; Options NX774"CLASS="NX"></A>
<A NAME="PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou"CLASS="Sf"></A>
<A NAME="PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou"></A>
<H6 CLASS="Sf">PXIMAGE: Get Advice, Errors, Info &amp; Options   ---   pximage::aeiou</H6>
<A NAME="::aeiou NX775"CLASS="NX"></A>
<A NAME="::aeiou"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
pximaeiou_t (ip-&gt;aeiou)(ip, service, int parm1, int parm2, parm3);
pximaeiou_t (ip3-&gt;aeiou)(ip3, service, int parm1, int parm2, parm3);
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 service;        // As described below
int                 parm1;          // Option
int                 parm2;          // Option
void                *parm3;         // Rsvd. should be NULL
<BR>
typedef ulong       pximaeiou_t;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
Advice, errors, and/or information
associated with activity on the
<EM CLASS="Ep">pximage</EM>
instance referenced by
<EM CLASS="Ep">ip</EM>,
or the
<EM CLASS="Ep">pximage3</EM>
instance referenced by
<EM CLASS="Ep">ip3</EM>,
is obtained.
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
Service 
</TD>
<TD ALIGN="left" COLSPAN="1">
 Return Value  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Meaning                                   
</TD>
<TD ALIGN="left" COLSPAN="1">
 Parm1  
</TD>
<TD ALIGN="left" COLSPAN="1">
 Parm2
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
        
</TD>
<TD ALIGN="left" COLSPAN="1">
 Cast Into     
</TD>
<TD ALIGN="left" COLSPAN="1">
                                           
</TD>
<TD ALIGN="left" COLSPAN="1">
        
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
'I'     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (uint)        
</TD>
<TD ALIGN="left" COLSPAN="1">
 Suggested access cnt, ioread()/iorite()   
</TD>
<TD ALIGN="left" COLSPAN="1">
 0      
</TD>
<TD ALIGN="left" COLSPAN="1">
 0
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
'B'     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (uint)        
</TD>
<TD ALIGN="left" COLSPAN="1">
 Suggested access cnt, bxta()              
</TD>
<TD ALIGN="left" COLSPAN="1">
 0      
</TD>
<TD ALIGN="left" COLSPAN="1">
 0
</TD>
</TR>
<TR><TD COLSPAN="5"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
'i'     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (ulong)       
</TD>
<TD ALIGN="left" COLSPAN="1">
 Relative access time, ioread()/iorite()   
</TD>
<TD ALIGN="left" COLSPAN="1">
 0      
</TD>
<TD ALIGN="left" COLSPAN="1">
 0
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
'b'     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (ulong)       
</TD>
<TD ALIGN="left" COLSPAN="1">
 Relative access time, bxta()              
</TD>
<TD ALIGN="left" COLSPAN="1">
 0      
</TD>
<TD ALIGN="left" COLSPAN="1">
 0
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
'm'     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (ulong)       
</TD>
<TD ALIGN="left" COLSPAN="1">
 Relative access time, imap()              
</TD>
<TD ALIGN="left" COLSPAN="1">
 0      
</TD>
<TD ALIGN="left" COLSPAN="1">
 0
</TD>
</TR>
<TR><TD COLSPAN="5"><HR NOSHADE SIZE="1"></TD></TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
'e'     
</TD>
<TD ALIGN="left" COLSPAN="1">
 (int)         
</TD>
<TD ALIGN="left" COLSPAN="1">
 Previous error, or 0                      
</TD>
<TD ALIGN="left" COLSPAN="1">
 clear  
</TD>
<TD ALIGN="left" COLSPAN="1">
 recurse
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
<P>
If
<EM CLASS="Ep">service</EM>='I',
the suggested, or optimal, access count for use with
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
is returned.
The returned value is never larger than UINT_MAX.
The
<EM CLASS="Ep">parm1</EM>
and
<EM CLASS="Ep">parm2</EM>
are ignored.
<P>
If
<EM CLASS="Ep">service</EM>='B',
the suggested, or optimal, access count for use with
<A HREF="#::bxta"CLASS="Er">::bxta</A>
is returned.
The returned value
is never larger than:
<BLOCKQUOTE>
<PRE>
UINT_MAX / sizeof(struct pximadrs)
</PRE>
</BLOCKQUOTE>
The
<EM CLASS="Ep">parm1</EM>
and
<EM CLASS="Ep">parm2</EM>
are ignored.
<P>
If
<EM CLASS="Ep">service</EM>='i',
the relative access time for pixels read or written via
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
is returned.
If
<EM CLASS="Ep">service</EM>='b',
the relative access time for pixels read, written, or modified via
<A HREF="#::bxta"CLASS="Er">::bxta</A>
is returned.
If
<EM CLASS="Ep">service</EM>='m',
the relative access time for pixels read or written via
a pointer provided by
<A HREF="#::imap"CLASS="Er">::imap</A>
is returned.<A HREF="#Footnote 39"CLASS="Ff"><SUP>[39]</SUP></A>
The
<EM CLASS="Ep">parm1</EM>
and
<EM CLASS="Ep">parm2</EM>
are ignored.
<P>
Relative access times are in nanoseconds,
or in units of wait states relative to accessing the fastest memory.
The relative access times are approximate values,
produced by quick approximation or guess work,
rather than time consuming, in-depth analysis.
They are intended solely for optional optimizations,
and have accuracy suitable only for such use.
For example, for an application program which must perform three passes
over an image, the access times support decisions as to
whether it is better to copy the image into local
memory and access the copy three times,
or just to access the original image three times.
Of course, the size of the image and availability of local memory
must also be taken into account by the application program.
<P>
If
<EM CLASS="Ep">service</EM>='e',
the last error code, if any, associated with activity on the
<EM CLASS="Ep">pximage</EM>
instance referenced by
<EM CLASS="Ep">ip</EM>,
or the
<EM CLASS="Ep">pximage3</EM>
instance referenced by
<EM CLASS="Ep">ip3</EM>,
is retrieved.
If
<EM CLASS="Ep">parm1</EM>&ne;0,
the error code is also cleared, so that a subsequent query
doesn't return the same code.
<P>
If
<EM CLASS="Ep">parm2</EM>&ne;0,
and the
<EM CLASS="Ep">ip</EM>
(<EM CLASS="Ep">ip3</EM>)
is a filter used in front of another
<EM CLASS="Ep">pximage</EM>
(<EM CLASS="Ep">pximage3</EM>),
the first error code found in the chain of
<EM CLASS="Ep">pximage</EM>'s
(<EM CLASS="Ep">pximage3</EM>'s),
is retrieved.
Further, if
<EM CLASS="Ep">parm1</EM>&ne;0,
the one error code, on the specific
<EM CLASS="Ep">pximage</EM>
(<EM CLASS="Ep">pximage3</EM>)
where it was found, is cleared.
<P>
Error codes typically report an error that occurred while
reading or writing pixels.
The values of error codes, cast to an
''int''
are interpreted as described in
<A HREF="#pxerrnomesg"CLASS="Er">pxerrnomesg</A>.
Some
<EM CLASS="Ep">pximage</EM>
(<EM CLASS="Ep">pximage3</EM>)
devices, such as those accessed via
<CITE CLASS="Ec">pximage_memory</CITE>,
never have error conditions.
Others, such as those accessed via
<CITE CLASS="Ec">pximage_file</CITE>
record errors if/when an I/O error occurs reading or writing the
underlying image file.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<HR SIZE="1">
<A NAME="pximage::ioset NX776"CLASS="NX"></A>
<A NAME="pximage::ioset"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set to Access Sequential Pixels NX777"CLASS="NX"></A>
<A NAME="PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset"></A>
<H6 CLASS="Sf">PXIMAGE: Set to Access Sequential Pixels   ---   pximage::ioset</H6>
<A NAME="pximage::ioread NX778"CLASS="NX"></A>
<A NAME="pximage::ioread"CLASS="Sg"></A>
<A NAME="PXIMAGE: Read Sequential Pixels NX779"CLASS="NX"></A>
<A NAME="PXIMAGE: Read Sequential Pixels   ---   pximage::ioread"CLASS="Sg"></A>
<A NAME="PXIMAGE: Read Sequential Pixels   ---   pximage::ioread"></A>
<H6 CLASS="Sg">PXIMAGE: Read Sequential Pixels   ---   pximage::ioread</H6>
<A NAME="pximage::iorite NX780"CLASS="NX"></A>
<A NAME="pximage::iorite"CLASS="Sg"></A>
<A NAME="PXIMAGE: Write Sequential Pixels NX781"CLASS="NX"></A>
<A NAME="PXIMAGE: Write Sequential Pixels   ---   pximage::iorite"CLASS="Sg"></A>
<A NAME="PXIMAGE: Write Sequential Pixels   ---   pximage::iorite"></A>
<H6 CLASS="Sg">PXIMAGE: Write Sequential Pixels   ---   pximage::iorite</H6>
<A NAME="pximage::iowait NX782"CLASS="NX"></A>
<A NAME="pximage::iowait"CLASS="Sg"></A>
<A NAME="PXIMAGE: Wait for Sequential Access Completion NX783"CLASS="NX"></A>
<A NAME="PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait"CLASS="Sg"></A>
<A NAME="PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait"></A>
<H6 CLASS="Sg">PXIMAGE: Wait for Sequential Access Completion   ---   pximage::iowait</H6>
<A NAME="pximage::iolen NX784"CLASS="NX"></A>
<A NAME="pximage::iolen"CLASS="Sg"></A>
<A NAME="PXIMAGE: Obtain Sequential Access Pixel Count NX785"CLASS="NX"></A>
<A NAME="PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen"CLASS="Sg"></A>
<A NAME="PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen"></A>
<H6 CLASS="Sg">PXIMAGE: Obtain Sequential Access Pixel Count   ---   pximage::iolen</H6>
<A NAME="::ioset NX786"CLASS="NX"></A>
<A NAME="::ioread NX787"CLASS="NX"></A>
<A NAME="::iorite NX788"CLASS="NX"></A>
<A NAME="::iowait NX789"CLASS="NX"></A>
<A NAME="::iolen NX790"CLASS="NX"></A>
<A NAME="::ioset"CLASS="Tr"></A>
<A NAME="::ioread"CLASS="Tr"></A>
<A NAME="::iorite"CLASS="Tr"></A>
<A NAME="::iowait"CLASS="Tr"></A>
<A NAME="::iolen"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (ip-&gt;ioset)(ip, mode, data, colormap);
uint (ip-&gt;ioread)(ip, mode, bufp, cnt, x, y);
uint (ip-&gt;iorite)(ip, mode, bufp, cnt, x, y);
int  (ip-&gt;iowait)(ip, wait, bufp);
uint (ip-&gt;iolen)(ip, cnt, x, y);
<BR>
int  (ip3-&gt;ioset)(ip3, mode, data, colormap);
uint (ip3-&gt;ioread)(ip3, mode, bufp, cnt, x, y, z);
uint (ip3-&gt;iorite)(ip3, mode, bufp, cnt, x, y, z);
int  (ip3-&gt;iowait)(ip3, wait, bufp);
uint (ip3-&gt;iolen)(ip3, cnt, x, y, z);
<BR>
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 mode;           // As described below
int                 data;           // PXDATUCHAR, PXDATUSHORT, etc.
                                    // or'ed with PXDATLSB or PXDATMSB
uint                colormap;       // Pixie selection bit map
void _far           *bufp;          // Host memory [16 bit environments]
void                *bufp;          // Host memory [32 bit environments]
uint                cnt;            // Number of pixels to access
pxcoord_t           x;              // Access x (horizontal) coordinate
pxcoord_t           y;              // Access y (vertical) coordinate
pxcoord_t           z;              // Access z (depth) coordinate
int                 wait;           // PXAWAIT,PXASYNC,PXABORT
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::ioset"CLASS="Er">::ioset</A>,
<A HREF="#::ioread"CLASS="Er">::ioread</A>,
<A HREF="#::iorite"CLASS="Er">::iorite</A>,
<A HREF="#::iowait"CLASS="Er">::iowait</A>,
and
<A HREF="#::iolen"CLASS="Er">::iolen</A>
provide access to sequences of pixels in the
<EM CLASS="Ep">pximage</EM>
instance referenced by
<EM CLASS="Ep">ip</EM>,
or the
<EM CLASS="Ep">pximage3</EM>
instance referenced by
<EM CLASS="Ep">ip3</EM>.
The
<A HREF="#::ioset"CLASS="Er">::ioset</A>
must be used before other functions in this group;
<A HREF="#::ioset"CLASS="Er">::ioset</A>
establishes various modes which affect how the other functions operate.
The
<EM CLASS="Ep">ip</EM>'s
(or
<EM CLASS="Ep">ip3</EM>'s)
area of interest window must not be changed
between setting an access mode with
<A HREF="#::ioset"CLASS="Er">::ioset</A>
and using the other functions in this group.
<P>
<BR>
<B CLASS="Hv">::ioset.</B>
The
<A HREF="#::ioset"CLASS="Er">::ioset</A>
establishes the sequence orientation (horizontal, vertical, depth),
and the data type for later
<A HREF="#::ioread"CLASS="Er">::ioread</A>
and
<A HREF="#::iorite"CLASS="Er">::iorite</A>.
<P>
If
<EM CLASS="Ep">mode</EM>=PXRXSCAN,
sequential access is in order of increasing
''x'',
then
increasing
''y''
(and then
increasing
''z'').
If
<EM CLASS="Ep">mode</EM>=PXRYSCAN,
sequential access is in order of increasing
''y'',
then
increasing
''x''
(and then
increasing
''z'').
(If
<EM CLASS="Ep">mode</EM>=PXRZSCAN,
sequential access is in order of increasing
''z'',
then increasing
''x'',
and then increasing
''y'').
<P>
If the
<EM CLASS="Ep">mode</EM>
is OR'ed with
PXIWRAP,
a single sequential access may
''wrap''
around at the end of the specified line (PXRXSCAN), column (PXRYSCAN),
or depth vector (PXRZSCAN),
allowing several lines, columns, or depth vectors to be transferred
at the same time.
Otherwise, a single
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
access will stop at the end of the specified
line (PXRXSCAN), column (PXRYSCAN) (or depth vector (PXRZSCAN)).
If the
<EM CLASS="Ep">mode</EM>
is OR'ed with PXIXYVALID, the
''x'',
''y'',
(or
''z'')
coordinates specified by
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
are assumed to be valid, requiring less overhead for checking.
<P>
The
<EM CLASS="Ep">data</EM>
specifies the data type that
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
will provide for pixel data.
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
C Type                      
</TD>
<TD ALIGN="left" COLSPAN="1">
 data
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) unsigned char    
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUCHAR
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) unsigned short   
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUSHORT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) unsigned int     
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) unsigned long    
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATULONG
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) float            
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATFLOAT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) double           
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATDOUBLE
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of)  8 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT8
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) 16 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT16
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
(array of) 32 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT32
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
For the unsigned integer types, the
<EM CLASS="Ep">data</EM>
may be OR'ed with PXDATLSB or PXDATMSB.
If the specified data type has the same number of bits as
<EM CLASS="Ep">ip</EM>-&gt;<EM CLASS="Ep">u.i.bitsused</EM>
(<EM CLASS="Ep">ip3</EM>-&gt;<EM CLASS="Ep">u.i.bitsused),</EM>
use of PXDATLSB or PXDATMSB has no effect.
Otherwise, PXDATLSB specifies that the significant bits are to be
read/written to/from the specified data type right justified,
PXDATMSB specifies that the significant bits are to be
read/written to/from the specified data type left justified.
If the data type has fewer bits than
<EM CLASS="Ep">ip</EM>-&gt;<EM CLASS="Ep">u.i.bitsused</EM>,
the most significant pixel bits are kept.
If neither PXDATLSB or PXDATMSB is used, the pixel data is not shifted;
the right most bits of the pixel are read/written to/from the specified data
type, and the least significant bits are kept.
<P>
For the unsigned integer types, the
<EM CLASS="Ep">data</EM>
may also be OR'ed with PXDATDIRTY.
If the specified data type has the same number of bits as
<EM CLASS="Ep">ip</EM>-&gt;<EM CLASS="Ep">u.i.bitsused</EM>
(<EM CLASS="Ep">ip3</EM>-&gt;<EM CLASS="Ep">u.i.bitsused),</EM>
use of PXDATDIRTY has no effect.
Otherwise, for
<A HREF="#::iorite"CLASS="Er">::iorite</A>
PXDATDIRTY indicates that the values being written
have random values in the unused bits, rather than zeros.
For
<A HREF="#::ioread"CLASS="Er">::ioread</A>
PXDATDIRTY indicates that the values being read
are allowed to have random values in the unused bits, rather than zeros.
<P>
The
<EM CLASS="Ep">colormap</EM>
specifies which pixie components are to be accessed;
bit 0x01 of
<EM CLASS="Ep">colormap</EM>
represent the first pixie component,
bit 0x02 the second pixie component, etc.
Multiple components may be accessed;
<EM CLASS="Ep">colormap</EM>=0x07
specifies access to three components.
Not all
<EM CLASS="Ep">pximage</EM>
(<EM CLASS="Ep">pximage3</EM>)
devices support access to arbitrary subsets of pixies.
For example, a
<EM CLASS="Ep">pximage</EM>
(<EM CLASS="Ep">pximage3</EM>)
device providing 4 pixies must support
<EM CLASS="Ep">colormap</EM>=0x1F,
and may, or may not, support (in decreasing order of likelihood):
(a)&nbsp;A
<EM CLASS="Ep">colormap</EM>
with a single bit set providing access to any one pixie,
(b)&nbsp;A
<EM CLASS="Ep">colormap</EM>
with a contiguous block of bits set (e.g. 0x18, 0x07, or 0x06)
providing access to a contiguous group of pixies,
or
(c) A
<EM CLASS="Ep">colormap</EM>
with an arbitrary pattern of bits set (e.g. 0x09)
providing access to a arbitrary group of pixies.
<P>
The
<A HREF="#::ioset"CLASS="Er">::ioset</A>
returns a value greater than 0 if successful, or less than 0 if the
image can't be accessed in the manner requested.
<P>
<BR>
<B CLASS="Hv">::ioread &amp; ::iorite.</B>
The
<A HREF="#::ioread"CLASS="Er">::ioread</A>
and
<A HREF="#::iorite"CLASS="Er">::iorite</A>
respectively read pixel data from the image to a host buffer and write
pixel data from a host buffer to the image.
The
<EM CLASS="Ep">cnt</EM>
is the maximum number of pixels (not pixies!) to be accessed,
starting at coordinates
<EM CLASS="Ep">x</EM>,
<EM CLASS="Ep">y</EM>,
(and
<EM CLASS="Ep">z</EM>)
relative to the current area of interest;
and proceeding in the PXRXSCAN, PXRYSCAN, (or
PXRZSCAN) order, as specified previously via
<A HREF="#::ioset"CLASS="Er">::ioset</A>.
Fewer than
<EM CLASS="Ep">cnt</EM>
pixels may actually be accessed;
access stops when the end of the image area of interest is reached,
or, if PXIWRAP was not previously specified via
<A HREF="#::ioset"CLASS="Er">::ioset</A>,
when the end of the current row, column, (or depth vector) is reached.
<P>
The return value of
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
indicates the number of pixels (not pixies!) transferred.
<P>
The
<EM CLASS="Ep">bufp</EM>
must reference
an array of the data type specified previously via
<A HREF="#::ioset"CLASS="Er">::ioset</A>,
with size no smaller than
<EM CLASS="Ep">cnt</EM>
times the number of pixies encoded in the
<EM CLASS="Ep">colormap</EM>
specified via
<A HREF="#::ioset"CLASS="Er">::ioset</A>.
The elements of
<EM CLASS="Ep">bufp</EM>
are filled in pixel by pixel, for each pixel the
lowest numbered pixie first, followed
by higher numbered pixies.
<P>
If
<EM CLASS="Ep">mode</EM>=PXIASYNC,
the pixel access is done asynchronously, if possible.
If the return value of
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
is non-zero, asynchronous operation isn't available
and the operation is complete.
A return value of zero indicates that the operation is pending
and may not be complete; the
<A HREF="#::iowait"CLASS="Er">::iowait</A>
must be used to wait or test for completion.
For each instance of a
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>,
only one asynchronous operation may be pending at any one time.
<P>
The
<EM CLASS="Ep">mode</EM>
may also be OR'ed with PXIMAYMOD.
The PXIMAYMOD has no effect for
<A HREF="#::ioread"CLASS="Er">::ioread</A>.
For
<A HREF="#::iorite"CLASS="Er">::iorite</A>,
PXIMAYMOD indicates that the (contents of)
<EM CLASS="Ep">bufp</EM>
array is disposable, and may be modified
at the whim of the
<EM CLASS="Ep">pximage</EM>
device driver.
<P>
<BR>
<B CLASS="Hv">::iowait.</B>
The
<A HREF="#::iowait"CLASS="Er">::iowait</A>
need be used only when PXIASYNC
is used with
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>.
The
<EM CLASS="Ep">bufp</EM>
must be the same value as used with
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>.
The
<EM CLASS="Ep">wait</EM>
must be either:
(a)&nbsp;PXAWAIT,
for which return is delayed until the previous operation is complete, returning the
value PXODONE;
(b)&nbsp;PXASYNC, for which return is immediate and the return
value is PXODONE to indicate the operation is complete or PXOPRUN
to indicate the operation is not yet complete;
or
(c)&nbsp;PXABORT, to prematurely terminate (if possible) the pending operation,
returning value PXODONE.
<P>
<BR>
<B CLASS="Hv">::iolen.</B>
The
<A HREF="#::iolen"CLASS="Er">::iolen</A>
returns the number of pixels that
<A HREF="#::ioread"CLASS="Er">::ioread</A>
or
<A HREF="#::iorite"CLASS="Er">::iorite</A>
would access, if given the same
<EM CLASS="Ep">cnt</EM>,
<EM CLASS="Ep">x</EM>,
<EM CLASS="Ep">y</EM>,
and
<EM CLASS="Ep">z</EM>
parameters.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Example</EM>
<P>
<BLOCKQUOTE>
<PRE>
/*
 * Read one and return one pixel value component.
 * The x &amp; y parameters are assumed relative to the window AOI, if any.
 * Note: Reading or writing one pixel or one pixel component
 * at a time is not efficient; this is provided as an educational
 * example, not as a recommendation for use. Reading or writing lines,
 * columns or the entire image at one time is supported and recommended.
 * Return is a signed long to accomodate errors.
 */
long imagepixie(struct pximage *ip, pxcoord_t x, pxcoord_t y, int pixie)
{
    union {
        uchar   c;
        ushort  s;
    } v;
<BR>
    if (!ip)
        return(-1);     // missing pximage*
    //
    // Following tests aren't really neccessary;
    // the ioset/ioread ends up doing the same.
    // They help illustrate use of the pximage fields.
    //
    if (x &lt; 0 || x &gt;= ip-&gt;imdim.se.x
     || y &lt; 0 || y &gt;= ip-&gt;imdim.se.y)
        return(-1);     // x or y out of image bounds
    if (pixie &lt; 0 || pixie &gt;= ip-&gt;d.pixies)
        return(-1);     // pixie out of bounds
    if (x &gt;= ip-&gt;wind.se.x-ip-&gt;wind.nw.x
     || y &gt;= ip-&gt;wind.se.y-ip-&gt;wind.nw.y)
        return(-1);     // x or y out of AOI bounds
<BR>
    //
    // Setup for read.
    //
    if ((*ip-&gt;ioset)(ip, PXRXSCAN, ip-&gt;d.pixietype, 1&lt;&lt;pixie) &lt; 0)
        return(-1);
    //
    // Read
    //
    #if 1
        //
        // On some architectures, depending on little vs big endian
        // and on how loose one wants to be with C, one can do
        // the following for both PXDATUCHAR and PXDATUSHORT.
        //
        if (ip-&gt;d.pixietype == PXDATUCHAR
         || ip-&gt;d.pixietype == PXDATUSHORT) {
            v.s = 0;
            if ((*ip-&gt;ioread)(ip, 0, &amp;v, 1, x, y) &lt; 0)
                return(-1);
            return(v.s);
        }
     #else
        //
        // The alternative is safe but verbose.
        //
        switch (ip-&gt;d.pixietype) {
          case PXDATUCHAR:
            if ((*ip-&gt;ioread)(ip, 0, &amp;v.c, 1, x, y) &lt; 0)
                return(-1)
            return(v.c);
          case PXDATUSHORT:
            if ((*ip-&gt;ioread)(ip, 0, &amp;v.s, 1, x, y) &lt; 0)
                return(-1)
            return(v.s);
        }
    #endif
    return(-1);     // data type unsupported by this example
}
</PRE>
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
<PRE>
/*
 * Read all one or three components of one pixel.
 * See comments above regarding efficiency.
 * Assumes that all components can be shifted and fit into a long.
 */
long imagepixel(struct pximage *ip, pxcoord_t x, pxcoord_t y)
{
    union {
        uchar   c[3];
        ushort  s[3];
        ulong   l;
    } v;
    int     i;
    long    l;
<BR>
    if (!ip)
        return(-1);     // missing pximage*
    //
    // Following tests aren't really neccessary;
    // the ioset/ioread ends up doing the same.
    // They help illustrate use of the pximage fields.
    //
    if (x &lt; 0 || x &gt;= ip-&gt;imdim.se.x
     || y &lt; 0 || y &gt;= ip-&gt;imdim.se.y)
        return(-1);     // x or y out of image bounds
    if (x &gt;= ip-&gt;wind.se.x-ip-&gt;wind.nw.x
     || y &gt;= ip-&gt;wind.se.y-ip-&gt;wind.nw.y)
        return(-1);     // x or y out of AOI bounds
<BR>
    //
    // Setup for read.
    // The last paramater to ::ioset is a bit map selecting
    // all pixel components, with a maximum of 3.
    //
    if ((*ip-&gt;ioset)(ip, PXRXSCAN, ip-&gt;d.pixietype, max(7, (1&lt;&lt;ip-&gt;d.pixies)-1)) &lt; 0)
        return(-1);
    //
    // Read
    //
    #if 1
        //
        // On some architectures, depending on little vs big endian
        // and on how loose one wants to be with C, one can do
        // the following for PXDATUCHAR.
        //
        if (ip-&gt;d.pixietype == PXDATUCHAR) {
            if ((*ip-&gt;ioread)(ip, 0, &amp;v.c[0], 1, x, y) &lt; 0)
                return(-1);
            return(v.l);
        }
    #endif
    //
    // The alternative is safe but verbose.
    //
    switch (ip-&gt;d.pixietype) {
      case PXDATUCHAR:
        if ((*ip-&gt;ioread)(ip, 0, &amp;v.c, 1, x, y) &lt; 0)
            return(-1);
        for (l = i = 0; i &lt; min(3, ip-&gt;d.pixies); i++)
            l = (l&lt;&lt;ip-&gt;d.u.i.bitsused) | v.c[i];
        return(l);
<BR>
      case PXDATUSHORT:
        if ((*ip-&gt;ioread)(ip, 0, &amp;v.s, 1, x, y) &lt; 0)
            return(-1);
        for (l = i = 0; i &lt; min(3, ip-&gt;d.pixies); i++)
            l = (l&lt;&lt;ip-&gt;d.u.i.bitsused) | v.s[i];
        return(l);
    }
    return(-1);     // data type unsupported by this example
}
</PRE>
</BLOCKQUOTE>
<HR SIZE="1">
<A NAME="pximage::bxts NX791"CLASS="NX"></A>
<A NAME="pximage::bxts"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set to Access Non-Sequential Pixels NX792"CLASS="NX"></A>
<A NAME="PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts"></A>
<H6 CLASS="Sf">PXIMAGE: Set to Access Non-Sequential Pixels   ---   pximage::bxts</H6>
<A NAME="pximage::bxtp NX793"CLASS="NX"></A>
<A NAME="pximage::bxtp"CLASS="Sg"></A>
<A NAME="PXIMAGE: Prepare for Non-Sequential Pixel Access NX794"CLASS="NX"></A>
<A NAME="PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp"CLASS="Sg"></A>
<A NAME="PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp"></A>
<H6 CLASS="Sg">PXIMAGE: Prepare for Non-Sequential Pixel Access   ---   pximage::bxtp</H6>
<A NAME="pximage::bxta NX795"CLASS="NX"></A>
<A NAME="pximage::bxta"CLASS="Sg"></A>
<A NAME="PXIMAGE: Access Non-Sequential Pixels NX796"CLASS="NX"></A>
<A NAME="PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta"CLASS="Sg"></A>
<A NAME="PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta"></A>
<H6 CLASS="Sg">PXIMAGE: Access Non-Sequential Pixels   ---   pximage::bxta</H6>
<A NAME="pximage::bxtw NX797"CLASS="NX"></A>
<A NAME="pximage::bxtw"CLASS="Sg"></A>
<A NAME="PXIMAGE: Wait for Non-Sequential Access Completion NX798"CLASS="NX"></A>
<A NAME="PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw"CLASS="Sg"></A>
<A NAME="PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw"></A>
<H6 CLASS="Sg">PXIMAGE: Wait for Non-Sequential Access Completion   ---   pximage::bxtw</H6>
<A NAME="::bxts NX799"CLASS="NX"></A>
<A NAME="::bxtp NX800"CLASS="NX"></A>
<A NAME="::bxta NX801"CLASS="NX"></A>
<A NAME="::bxtw NX802"CLASS="NX"></A>
<A NAME="::bxts"CLASS="Tr"></A>
<A NAME="::bxtp"CLASS="Tr"></A>
<A NAME="::bxta"CLASS="Tr"></A>
<A NAME="::bxtw"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (ip-&gt;bxts)(ip, mode, data, colormap);
int  (ip-&gt;bxtp)(ip, mode, bufp, adrsp, cnt, op);
uint (ip-&gt;bxta)(ip, mode, bufp, adrsp, cnt, op);
int  (ip-&gt;bxtw)(ip, wait, bufp, adrsp);
<BR>
int  (ip3-&gt;bxts)(ip3, mode, data, colormap);
int  (ip3-&gt;bxtp)(ip3, mode, bufp, adrsp, cnt, op);
uint (ip3-&gt;bxta)(ip3, mode, bufp, adrsp, cnt, op);
int  (ip3-&gt;bxtw)(ip3, wait, bufp, adrsp);
<BR>
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 mode;           // As described below
int                 data;           // PXDATUCHAR, PXDATUSHORT, etc.
                                    // or'ed with PXDATLSB or PXDATMSB
uint                colormap;       // Pixie selection bit map
void _far           *bufp;          // Host memory [16 bit environments]
void                *bufp;          // Host memory [32 bit environments]
struct pximadrs _far *adrsp;        // List of pixel locations [16 bit environments]
struct pximadrs      *adrsp;        // List of pixel locations [32 bit environments]
uint                cnt;            // Number of pixels to access
int                 op;             // Operation: PXPIXBLT, PXPIXBATN, PXPIXBRT, PXPIXBWT, PXPIXBXT
int                 wait;           // PXAWAIT,PXASYNC,PXABORT
<BR>
<A NAME="Struct pximadrs NX803"CLASS="NX"></A>
<A NAME="pximadrs, struct NX804"CLASS="NX"></A>
<A NAME="pximadrs_s NX805"CLASS="NX"></A>
<A NAME="pximadrs"CLASS="Tr"></A>
<A NAME="pximadrs_s"CLASS="Tr"></A>
struct pximadrs {                   // list of pixel locations
    union {
        struct  pxy  xy;            // x, y coordinates
        struct  pxyz xyz;           // x, y, z coordinates
<BR>
        ulong   devadrs;            // internal usage ...
        uint    devstate[3];        // .. device specific coordinates
    } adrs;
};
typedef struct pximadrs pximadrs_s;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::bxts"CLASS="Er">::bxts</A>,
<A HREF="#::bxtp"CLASS="Er">::bxtp</A>,
<A HREF="#::bxta"CLASS="Er">::bxta</A>,
and
<A HREF="#::bxtw"CLASS="Er">::bxtw</A>
provide access to a list of pixels in arbitrary locations in the
<EM CLASS="Ep">pximage</EM>
instance referenced by
<EM CLASS="Ep">ip</EM>,
or the
<EM CLASS="Ep">pximage3</EM>
instance referenced by
<EM CLASS="Ep">ip3</EM>.
The
<A HREF="#::bxts"CLASS="Er">::bxts</A>
must be used before other functions in this group;
<A HREF="#::bxts"CLASS="Er">::bxts</A>
establishes various modes which affect how the other functions operate.
The
<EM CLASS="Ep">ip</EM>'s
(or
<EM CLASS="Ep">ip3</EM>'s)
area of interest window must not be changed
between setting an access mode with
<A HREF="#::bxts"CLASS="Er">::bxts</A>
and using the other functions in this group.
<P>
<BR>
<B CLASS="Hv">Overview.</B>
Application programs prepare an array of
<EM CLASS="Ep">pximadrs</EM>
structures, one
<EM CLASS="Ep">pximadrs</EM>
for each pixel to be accessed.
The
<EM CLASS="Ep">adrs.xy</EM>
(or
<EM CLASS="Ep">adrs.xyz</EM>)
of each
<EM CLASS="Ep">pximadrs</EM>
is initialized with a pixel's coordinates
relative to the current area of interest.
For each pixel in the list, a pixel read, write,
or modify operation is performed;
reading pixel values into the
<EM CLASS="Ep">bufp</EM>,
writing pixel values from the
<EM CLASS="Ep">bufp</EM>,
or modifying pixel values with values from the
<EM CLASS="Ep">bufp</EM>.
<P>
<BR>
<B CLASS="Hv">::bxts.</B>
The
<A HREF="#::bxts"CLASS="Er">::bxts</A>
establishes the data type for later
<A HREF="#::bxta"CLASS="Er">::bxta</A>.
The
<EM CLASS="Ep">mode</EM>
is reserved, and should be PXIXYVALID.
The
<EM CLASS="Ep">data</EM>
and
<EM CLASS="Ep">colormap</EM>
of
<EM CLASS="Ep">::bxts</EM>
specifies the data type the
<EM CLASS="Ep">bufp</EM>
is expected to reference, and
which pixel components are to be accessed,
as described above for
<A HREF="#::ioset"CLASS="Er">::ioset</A>.
<P>
The
<A HREF="#::bxts"CLASS="Er">::bxts</A>
returns a value greater than 0 if successful, or less than 0 if the
image can't be accessed in the manner requested.
Some
<EM CLASS="Ep">pximage</EM>
(or
<EM CLASS="Ep">pximage3</EM>
device drivers may not support the
::bxt*
services.
<P>
<BR>
<B CLASS="Hv">::bxtp.</B>
If
<EM CLASS="Ep">mode</EM>&amp;PXIBXTC,
the
<A HREF="#::bxtp"CLASS="Er">::bxtp</A>
translates the
<EM CLASS="Ep">adrs.xy</EM>
(or
<EM CLASS="Ep">adrs.xyz</EM>)
of the
<EM CLASS="Ep">adrsp</EM>
list containing
<EM CLASS="Ep">cnt</EM>
elements of
<EM CLASS="Ep">pximadrs</EM>
structures into an internal, device dependent, form.
The
<EM CLASS="Ep">adrs.xy</EM>
(or
<EM CLASS="Ep">adrs.xyz)</EM>
coordinates are assumed valid!
The
<EM CLASS="Ep">op</EM>
is the operation to be performed, as described below
for
<A HREF="#::bxta"CLASS="Er">::bxta</A>.
(The
<EM CLASS="Ep">op</EM>
is currently ignored and may be 0).
<P>
The address translation
can be done when pixels are accessed with
<A HREF="#::bxta"CLASS="Er">::bxta</A>,
explicit translation and modification
allows reusing the same list with lower overhead.
<P>
The
<A HREF="#::bxtp"CLASS="Er">::bxtp</A>
return value is the
<EM CLASS="Ep">mode</EM>
with the PXIBXTC bit set if the
<EM CLASS="Ep">adrs.xy</EM>
(or
<EM CLASS="Ep">adrs.xyz)</EM>
were modified or overwritten,
otherwise the PXIBXTC bit is reset (if the device driver
chooses to work with the original
''x'',
''y'',
and
''z''
coordinates).
<P>
<BR>
<B CLASS="Hv">::bxta.</B>
The
<A HREF="#::bxta"CLASS="Er">::bxta</A>
reads, writes, or modifies the
<EM CLASS="Ep">cnt</EM>
pixels whose coordinates are specified by the
<EM CLASS="Ep">adrsp</EM>
list of
<EM CLASS="Ep">cnt</EM>
elements of
<EM CLASS="Ep">pximadrs</EM>
structures.
The
<EM CLASS="Ep">bufp</EM>
must reference
an array of the data type specified previously via
<A HREF="#::bxts"CLASS="Er">::bxts</A>,
with size no smaller than
<EM CLASS="Ep">cnt</EM>
times the number of pixies encoded in the
<EM CLASS="Ep">colormap</EM>
specified via
<A HREF="#::bxts"CLASS="Er">::bxts</A>;
successive pixies from
<EM CLASS="Ep">bufp</EM>
are associated with successive pixel addresses from
<EM CLASS="Ep">adrsp</EM>.
The
<EM CLASS="Ep">op</EM>
specifies the desired operation:
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
op value   
</TD>
<TD ALIGN="left" COLSPAN="1">
 operation
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXPIXBLT   
</TD>
<TD ALIGN="left" COLSPAN="1">
 exchange value in bufp[] with pixel
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXPIXBATN  
</TD>
<TD ALIGN="left" COLSPAN="1">
 add value in bufp[] with pixel
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXPIXBRT   
</TD>
<TD ALIGN="left" COLSPAN="1">
 read pixel value into bufp[]
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXPIXBWT   
</TD>
<TD ALIGN="left" COLSPAN="1">
 write value in bufp[] to pixel
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
PXPIXBXT   
</TD>
<TD ALIGN="left" COLSPAN="1">
 XOR value in bufp[] with pixel (unsigned integer pixels only)
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
For PXPIXBLT, PXPIXBATN, PXPIXBWT, and PXPIXBXT,
the pixels in the buffer referenced by
<EM CLASS="Ep">bufp</EM>
should be initialized with a value before using
<A HREF="#::bxta"CLASS="Er">::bxta</A>.
For PXPIXBLT and PXPIXBRT, the
pixels in the buffer referenced by
<EM CLASS="Ep">bufp</EM>
will be modified.
<P>
The
<EM CLASS="Ep">mode</EM>
should be 0, OR'ed with the following options.
If
<EM CLASS="Ep">mode</EM>
is OR'ed with PXIBXTC
<A HREF="#::bxta"CLASS="Er">::bxta</A>
also performs the effect of
<A HREF="#::bxtp"CLASS="Er">::bxtp</A>,
avoiding having to explicitly invoke
<A HREF="#::bxtp"CLASS="Er">::bxtp</A>.
<P>
The return value of
<A HREF="#::bxta"CLASS="Er">::bxta</A>
indicates the number of pixels accessed.
<P>
The
<EM CLASS="Ep">mode</EM>
may be OR'ed with PXIASYNC;
the pixel access is done asynchronously, if possible.
If the return value of
<A HREF="#::bxta"CLASS="Er">::bxta</A>
is non-zero, asynchronous operation isn't available
and the operation is complete.
A return value of zero indicates that the operation is pending
and may not be complete; the
<A HREF="#::bxtw"CLASS="Er">::bxtw</A>
must be used to wait or test for completion.
For each instance of a
<A HREF="#pximage"CLASS="Er">pximage</A>
or
<A HREF="#pximage3"CLASS="Er">pximage3</A>,
only one asynchronous operation may be pending at any one time.
<P>
<BR>
<B CLASS="Hv">::bxtw.</B>
The
<A HREF="#::bxtw"CLASS="Er">::bxtw</A>
need be used only when PXIASYNC
is used with
<A HREF="#::bxta"CLASS="Er">::bxta</A>.
The
<EM CLASS="Ep">bufp</EM>
and
<EM CLASS="Ep">adrsp</EM>
must be the same values as used with
<A HREF="#::bxta"CLASS="Er">::bxta</A>.
The
<EM CLASS="Ep">wait</EM>
must be either:
(a)&nbsp;PXAWAIT,
for which return is delayed until the previous operation is complete, returning the
value PXODONE;
(b)&nbsp;PXASYNC, for which return is immediate and the return
value is PXODONE to indicate the operation is complete or PXOPRUN
to indicate the operation is not yet complete;
or
(c)&nbsp;PXABORT, to prematurely terminate (if possible) the pending operation,
returning value PXODONE.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<HR SIZE="1">
<A NAME="pximage::imapset NX806"CLASS="NX"></A>
<A NAME="pximage::imapset"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set to Obtain Pointer to Pixels NX807"CLASS="NX"></A>
<A NAME="PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset"CLASS="Sf"></A>
<A NAME="PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset"></A>
<H6 CLASS="Sf">PXIMAGE: Set to Obtain Pointer to Pixels   ---   pximage::imapset</H6>
<A NAME="pximage::imap NX808"CLASS="NX"></A>
<A NAME="pximage::imap"CLASS="Sg"></A>
<A NAME="PXIMAGE: Obtain Pointer to Pixels NX809"CLASS="NX"></A>
<A NAME="PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap"CLASS="Sg"></A>
<A NAME="PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap"></A>
<H6 CLASS="Sg">PXIMAGE: Obtain Pointer to Pixels   ---   pximage::imap</H6>
<A NAME="pximage::imapr NX810"CLASS="NX"></A>
<A NAME="pximage::imapr"CLASS="Sg"></A>
<A NAME="PXIMAGE: Release Pointer to Pixels NX811"CLASS="NX"></A>
<A NAME="PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr"CLASS="Sg"></A>
<A NAME="PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr"></A>
<H6 CLASS="Sg">PXIMAGE: Release Pointer to Pixels   ---   pximage::imapr</H6>
<A NAME="::imapset NX812"CLASS="NX"></A>
<A NAME="::imap NX813"CLASS="NX"></A>
<A NAME="::imapr NX814"CLASS="NX"></A>
<A NAME="::imapset"CLASS="Tr"></A>
<A NAME="::imap"CLASS="Tr"></A>
<A NAME="::imapr"CLASS="Tr"></A>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Summary</EM>
<BLOCKQUOTE>
<PRE>
int  (ip-&gt;imapset)(ip, mode, data, colormap);
int  (ip-&gt;imap)(ip, mp, x, y);
void (ip-&gt;imapr)(ip, mp);
<BR>
int  (ip3-&gt;imapset)(ip3, mode, data, colormap);
int  (ip3-&gt;imap)(ip3, mp, x, y, z);
void (ip3-&gt;imapr)(ip3, pixp);
<BR>
struct pximage      *ip;            // Pointer to pximage instance
struct pximage3     *ip3;           // Pointer to pximage3 instance
int                 mode;           // As described below
int                 data;           // PXDATUCHAR, PXDATUSHORT, etc.
                                    // or'ed with PXDATLSB or PXDATMSB
uint                colormap;       // Pixie selection bit map
struct pximap       *mp;            // Pixel reference 'handle'
<BR>
pxcoord_t           x;              // Access x (horizontal) coordinate
pxcoord_t           y;              // Access y (vertical) coordinate
pxcoord_t           z;              // Access z (depth) coordinate
<BR>
<A NAME="Struct pximap NX815"CLASS="NX"></A>
<A NAME="pximap, struct NX816"CLASS="NX"></A>
<A NAME="pximap"CLASS="Tr"></A>
struct pximap
{
    int         valid;  // imap()'s return value, clr'ed by imapr()
    void _far   *p;     // pointer to image memory [segmented (i86) environments]
    void        *p;     // pointer to image memory [non-segmented environments]
<BR>
    size_t      inc;    // increment to next pixie, always in ..
                        // .. sizeof(char), regardless of pixie type
    size_t      len;    // number of following pixels that can be accessed ..
                        // .. at increasing x,y,z by using the inc
<BR>
                        // if imap() mode 2 (PXIMAP2): (future)
    size_t      xinc;   // increment to next pixel (X) in row
    size_t      yinc;   // increment to next row (Y) in image
    size_t      zinc;   // increment to next image (Z) in sequence (3-D)
                        // all in sizeof(char), regardless of pixie type
    size_t      xdim;   // # of accessible pixels at increasing X
    size_t      ydim;   // # of accessible pixels at increasing Y
    size_t      zdim;   // # of accessible pixels at increasing Z
};
typedef struct pximap pximap_s;
</PRE>
</BLOCKQUOTE>
<BR>
<BR>
<BR>
<EM CLASS="Ss">Description</EM>
<P>
The
<A HREF="#::imapset"CLASS="Er">::imapset</A>,
<A HREF="#::imap"CLASS="Er">::imap</A>,
and
<A HREF="#::imapr"CLASS="Er">::imapr</A>
provides direct pointer access to pixels in the
<EM CLASS="Ep">pximage</EM>
instance referenced by
<EM CLASS="Ep">ip</EM>,
or the
<EM CLASS="Ep">pximage3</EM>
instance referenced by
<EM CLASS="Ep">ip3</EM>.
Some
<EM CLASS="Ep">pximage</EM>
(or
<EM CLASS="Ep">pximage3</EM>)
device drivers do not support the
<A HREF="#::imap"CLASS="Er">::imap</A>
service, or may provide the service
under limited conditions.<A HREF="#Footnote 40"CLASS="Ff"><SUP>[40]</SUP></A>
<P>
The
<A HREF="#::imapset"CLASS="Er">::imapset</A>
must be used before other functions in this group;
<A HREF="#::imapset"CLASS="Er">::imapset</A>
establishes various modes which affect how the other functions operate.
The
<EM CLASS="Ep">ip</EM>'s
(or
<EM CLASS="Ep">ip3</EM>'s)
area of interest window must not be changed
between setting an access mode with
<A HREF="#::imapset"CLASS="Er">::imapset</A>
and using the other functions in this group.
<P>
<BR>
<B CLASS="Hv">Overview.</B>
The
<A HREF="#::imap"CLASS="Er">::imap</A>
requests access to the pixel at coordinates
<EM CLASS="Ep">x</EM>,
<EM CLASS="Ep">y</EM>,
(and
<EM CLASS="Ep">z</EM>),
relative to the image area of interest,
and as many of the following pixels as possible; the
<EM CLASS="Ep">mode</EM>
of
<EM CLASS="Ep">::imapset</EM>
specifies the sense of
''following pixels'';
in order of increasing
<EM CLASS="Ep">x</EM>,
<EM CLASS="Ep">y</EM>,
(or
<EM CLASS="Ep">z</EM>).
The
<EM CLASS="Ep">data</EM>
and
<EM CLASS="Ep">colormap</EM>
of
<EM CLASS="Ep">::imapset</EM>
specifies the data type the pointer is expected to reference, and
which pixel components are to be accessed.
If direct access is possible,
<EM CLASS="Ep">::imap</EM>
returns a suitable pointer,
which, after being cast to the correct data type, can read or write pixel values.
Also returned are the number of following pixels that can be accessed,
and the increment to be added to the pointer to access the following pixels.
When done, the direct access is released with
<EM CLASS="Ep">::imapr</EM>.
<P>
<BR>
<B CLASS="Hv">::imapset.</B>
The
<A HREF="#::imapset"CLASS="Er">::imapset</A>
establishes the sequence orientation (horizontal, vertical, depth),
and the data type for later use of
<A HREF="#::imap"CLASS="Er">::imap</A>.
<P>
The
<EM CLASS="Ep">mode</EM>
should be PXRXSCAN, PXRYSCAN, (or PXRZSCAN).
If
<EM CLASS="Ep">mode</EM>=PXRXSCAN,
the sense of
''following pixels''
is in order of increasing
''x'',
then
increasing
''y''
(and then
increasing
''z'').
If
<EM CLASS="Ep">mode</EM>=PXRYSCAN,
the sense is in order of increasing
''y'',
then
increasing
''x''
(and then
increasing
''z'').
(If
<EM CLASS="Ep">mode</EM>=PXRZSCAN,
the sense is in order of increasing
''z'',
then increasing
''x'',
and then increasing
''y'').
<P>
If
<EM CLASS="Ep">mode</EM>
is OR'ed with PXIWRAP,
the sense of
''following pixels''
''wraps''
around at the end of the specified line (PXRXSCAN), column (PXRYSCAN),
or depth vector (PXRZSCAN),
allowing several lines, columns, or depth vectors to be available
at the same time.
Otherwise,
the sense of
''following pixels''
stops at the end of the specified
line (PXRXSCAN), column (PXRYSCAN) (or depth vector (PXRZSCAN)).
<P>
If
<EM CLASS="Ep">mode</EM>
is not OR'ed with PXIMAPINC,
the returned
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">inc</EM>
(assuming direct access service is available at all)
is always the size of the data type specified by
<EM CLASS="Ep">data</EM>;
in other words, the assumptions expressed by:
<BLOCKQUOTE>
<PRE>
    struct  pximap  imap;
    ulong   _far    *lp;    // _far only in segmented environments
<BR>
    if ((ip-&gt;imapset)(ip, PXRXSCAN, PXDATULONG, 0x01) &gt; 0) {
        if ((ip-&gt;imap)(ip, &amp;imap, 0, 0)) {
            lp = imap.p;
            while (imap.len--)
                *lp++ = 0;
            (ip-&gt;imapr)(ip, &amp;imap);
        }
    }
</PRE>
</BLOCKQUOTE>
are valid.
If
<EM CLASS="Ep">mode</EM>
is OR'ed with PXIMAPINC, the
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">inc</EM>,
may not be the data size, but more pixels may thereby be accessible.
The above extract must be modified to:
<BLOCKQUOTE>
<PRE>
    struct  pximap  imap;
<BR>
    if ((ip-&gt;imapset)(ip, PXRXSCAN|PXIMAPINC, PXDATULONG, 0x01) &gt; 0)
        if ((ip-&gt;imap)(ip, &amp;imap, 0, 0)) {
            while (imap.len--) {
                *((ulong _far*)imap.p) = 0;     // _far only in segmented environments
                (uchar _far*) imap.p += imap.inc;
            }
            (ip-&gt;imapr)(ip, &amp;imap);
        }
</PRE>
</BLOCKQUOTE>
<BR>
<B CLASS="Hv">Note:</B>
The
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">inc</EM>
is always in units of
''uchars''!!!
<P>
If
<EM CLASS="Ep">mode</EM>
is OR'ed with PXIMAPNOTFAR, the
<A HREF="#::imapset"CLASS="Er">::imapset</A>
will succeed only if the pointer returned by
<EM CLASS="Ep">::imap</EM>
can have the
''_far''
adjective cast off;
the assumptions expressed by:
<BLOCKQUOTE>
<PRE>
    struct  pximap imap;
    ulong   *lp;    // a default pointer!! All environments!!
<BR>
    if ((ip-&gt;imapset)(ip, PXRXSCAN|PXIMAPNOTFAR, PXDATULONG, 0x01) &gt; 0)
        if ((ip-&gt;imap)(ip, &amp;imap, 0, 0)) {
            lp = imap.p;            // ignore compiler warning
            lp = (ulong*)(imap.p);  // or explicitly cast it
            while (imap.len--)
                *lp++ = 0;
            (ip-&gt;imapr)(ip, &amp;imap);
        }
</PRE>
</BLOCKQUOTE>
are valid.
In nonsegmented environments which do not require the
''_far''
adjective,
on in environments such as Microsoft 32 Bit C which doesn't support
''_far''
pointers, the
PXIMAPNOTFAR is ignored.
<P>
If
<EM CLASS="Ep">mode</EM>
is OR'ed with PXIXYVALID,
the
''x'',
''y'',
(and
''z'')
coordinates given to
<EM CLASS="Ep">::imap</EM>
are assumed valid,
requiring less overhead for checking.
<P>
The
<EM CLASS="Ep">data</EM>
specifies the intended data type of the returned pointer.
<DIV align="center">
<PRE>
<TABLE FRAME="box" RULES="groups">
<TR>
<TD ALIGN="left" COLSPAN="1">
pointer type            
</TD>
<TD ALIGN="left" COLSPAN="1">
 data
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
uchar                   
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUCHAR
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
ushort                  
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUSHORT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
uint                    
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
ulong                   
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATULONG
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
float                   
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATFLOAT
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
double                  
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATDOUBLE
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
8 bit unsigned integer  
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT8
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
16 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT16
</TD>
</TR>
<TR>
<TD ALIGN="left" COLSPAN="1">
32 bit unsigned integer 
</TD>
<TD ALIGN="left" COLSPAN="1">
 PXDATUINT32
</TD>
</TR>
</TABLE>
</PRE>
</DIV>
For the unsigned integer types, the
<EM CLASS="Ep">data</EM>
may also be OR'ed with PXDATMSB, PXDATLSB, and/or PXDATDIRTY.
These specifications are interpreted in a similar manner as the
<EM CLASS="Ep">data</EM>
parameter described for
<A HREF="#::ioset"CLASS="Er">::ioset</A>.
If PXDATMSB is used,
<A HREF="#::imapset"CLASS="Er">::imapset</A>
will succeed only if the unused bits, if any, are right justified.
If PXDATLSB is used,
<A HREF="#::imapset"CLASS="Er">::imapset</A>
will succeed only if the unused bits, if any, are left justified.
The PXDATMSB and PXDATLSB should not be used together.
If PXDATDIRTY is not used,
<A HREF="#::imapset"CLASS="Er">::imapset</A>
will succeed only if the unused bits, if any, are 0.
<P>
The
<EM CLASS="Ep">colormap</EM>
specifies which pixie components are to be accessed,
in the same manner as the
<EM CLASS="Ep">colormap</EM>
parameter described for
<A HREF="#::ioset"CLASS="Er">::ioset</A>.
<P>
The
<EM CLASS="Ep">::imapset</EM>
returns a value greater than 0 if successful; or
less than 0 if the service is not available,
or the requested/expected
<EM CLASS="Ep">data</EM>
and
<EM CLASS="Ep">colormap</EM>
is not consistent with the actual pixel data.
<P>
<BR>
<B CLASS="Hv">::imap.</B>
The
<EM CLASS="Ep">::imap</EM>
requests a direct access pointer to the pixel at
''x'',
''y'',
(and
''z'')
relative to the image area of interest,
and to following pixels;
where the orientation of
''following pixels'',
and the expected data type of the pointer
are as specified by the
<EM CLASS="Ep">mode</EM>,
<EM CLASS="Ep">data</EM>,
and
<EM CLASS="Ep">colormap</EM>
or
<EM CLASS="Ep">::imapset.</EM>
<P>
The
<EM CLASS="Ep">::imap</EM>
returns 1 if access is granted, and fills in the
<EM CLASS="Ep">pximap</EM>
structure referenced by
<EM CLASS="Ep">mp</EM>.
The
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">p</EM>
is the direct access pointer,
the
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">len</EM>
is the number of pixels that can be accessed with
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">p</EM>
by incrementing by
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">inc</EM>
''uchars''.
The
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">valid</EM>
is set to 1.
<P>
The
<EM CLASS="Ep">::imap</EM>
returns 0
if the access is denied, and sets
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">valid</EM>
to 0.
The
<EM CLASS="Ep">::imap</EM>
may fail even if
<EM CLASS="Ep">::imapset</EM>
succeeds.<A HREF="#Footnote 41"CLASS="Ff"><SUP>[41]</SUP></A>
<P>
Multiple, simultaneous, direct access pointers may be requested from
the same
<EM CLASS="Ep">pximage</EM>
(or
<EM CLASS="Ep">pximage3</EM>),
although hardware limitations may restrict ability of some device drivers
to fulfill the second or later requests.
<P>
Under environments other than real-mode DOS:
For
<EM CLASS="Ep">pximage</EM>'s
(or
<EM CLASS="Ep">pximage3</EM>'s),
which access buffers on imaging boards
(such as on the SILICON VIDEO&reg; MUX or the 4MEG VIDEO imaging boards),
the direct access pointer provided by
<EM CLASS="Ep">::imap</EM>
may be used by the requesting application,
but can not be passed to other applications or to system
services such as file I/O.
<P>
<BR>
<B CLASS="Hv">::imapr.</B>
The
<EM CLASS="Ep">::imapr</EM>
releases a direct access pointer provided by
<EM CLASS="Ep">::imap</EM>
and sets
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">valid</EM>
to 0.
For convenience, the
<EM CLASS="Ep">::imapr</EM>
may be called even if
<EM CLASS="Ep">::imap</EM>
failed (using the same
<EM CLASS="Ep">mp</EM>)
without ill effect.
Also, for convenience, the
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">p</EM>,
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">len</EM>,
and
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">cnt</EM>,
(but not
<EM CLASS="Ep">mp</EM>-&gt;<EM CLASS="Ep">valid</EM>)
may be altered between invocations of
<EM CLASS="Ep">::imap</EM>
and
<EM CLASS="Ep">::imapr</EM>.
<BR>
<BR>
<BR>
<EM CLASS="Ss">Returns</EM>
<P>
As described above.
<HR SIZE="3">
<A NAME="Application Notes"CLASS="Ch"></A>
<A NAME="12.  Application Notes"></A>
<H1>12.  Application Notes</H1>
<A NAME="Conversion of Application Programs from XCOBJ"CLASS="Ch"></A>
<A NAME="12.1.  Conversion of Application Programs from XCOBJ"></A>
<H2>12.1.  Conversion of Application Programs from XCOBJ</H2>
<P>
The following notes describe commonly used
functions in the XCOBJ Library,
and their SCF replacements in the XCLIB Library.
<P>
Several macros are provided to help automate the conversion.
These macros can be found in
<CODE CLASS="Em">xclibsc.h</CODE>.
They must be explicitly enabled by using:
<BLOCKQUOTE>
<PRE>
    #define XCOBJ_TO_XCLIB_MACROS  1
</PRE>
</BLOCKQUOTE>
before
<BLOCKQUOTE>
<PRE>
    #include &quot;xcliball.h&quot;
</PRE>
</BLOCKQUOTE>
in the application program.
<P>
The
<CITE CLASS="Ec">pxd_xcopen</CITE>
is replaced by
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>.
The first parameter of
<CITE CLASS="Ec">pxd_xcopen</CITE>,
which could be either a reserved format name
or a path name,
is replaced by individual parameters for each of these usages.
<P>
The
<CITE CLASS="Ec">pxd_close</CITE>
is replaced by
<A HREF="#pxd_PIXCIclose"CLASS="Er">pxd_PIXCIclose</A>.
<P>
The
<CITE CLASS="Ec">pxd_id</CITE>
and
<CITE CLASS="Ec">pxd_idstr</CITE>
are replaced by
<A HREF="#pxd_infoDriverId"CLASS="Er">pxd_infoDriverId</A>,
<A HREF="#pxd_infoLibraryId"CLASS="Er">pxd_infoLibraryId</A>,
and
<A HREF="#pxd_infoIncludeId"CLASS="Er">pxd_infoIncludeId</A>.
<P>
The
<CITE CLASS="Ec">pxd_xcmodel</CITE>,
<CITE CLASS="Ec">pxd_xcmodelcamera</CITE>,
<CITE CLASS="Ec">pxd_udim</CITE>,
<CITE CLASS="Ec">pxd_imsize</CITE>,
<CITE CLASS="Ec">pxd_xdim</CITE>,
<CITE CLASS="Ec">pxd_ydim</CITE>,
<CITE CLASS="Ec">pxd_ylace</CITE>,
<CITE CLASS="Ec">pxd_cdim</CITE>,
<CITE CLASS="Ec">pxd_bdim</CITE>,
and
<CITE CLASS="Ec">pxd_imbufs</CITE>,
are replaced by
<A HREF="#pxd_infoModel"CLASS="Er">pxd_infoModel</A>,
<A HREF="#pxd_infoSubmodel"CLASS="Er">pxd_infoSubmodel</A>,
<A HREF="#pxd_infoUnits"CLASS="Er">pxd_infoUnits</A>,
<A HREF="#pxd_infoMemsize"CLASS="Er">pxd_infoMemsize</A>
(note that the size in
<U CLASS="U">bytes</U>
is returned) ,
<A HREF="#pxd_imageXdim"CLASS="Er">pxd_imageXdim</A>,
<A HREF="#pxd_imageYdim"CLASS="Er">pxd_imageYdim</A>
(note that
the number of pixels in a column including
<U CLASS="U">all</U>
fields of the frame buffer is returned),
<A HREF="#pxd_imageIdim"CLASS="Er">pxd_imageIdim</A>
(note that the
<U CLASS="U">number</U>
of fields is returned),
<A HREF="#pxd_imageCdim"CLASS="Er">pxd_imageCdim</A>,
<A HREF="#pxd_imageBdim"CLASS="Er">pxd_imageBdim</A>
(note that the number of bits in a
<U CLASS="U">single</U>
color component is returned),
and
<A HREF="#pxd_imageZdim"CLASS="Er">pxd_imageZdim</A>.
<P>
The
<CITE CLASS="Ec">pxd_udim</CITE>
is replaced by
<A HREF="#pxd_infoUnits"CLASS="Er">pxd_infoUnits</A>.
The
<CITE CLASS="Ec">pxd_unit</CITE>
and
<CITE CLASS="Ec">pxd_units</CITE>,
which selected one or more units for
use by all following functions
until specified otherwise,
are replaced by a
<EM CLASS="Ep">unitmap</EM>
parameter added to the actual functions
that provide the desired service.
For example, instead of using:
<BLOCKQUOTE>
<PRE>
    pxd_unit(0x2);      // select unit
    pxd_snap(...);      // operate with selection
</PRE>
</BLOCKQUOTE>
the
<BLOCKQUOTE>
<PRE>
    pxd_doSnap(0x2, ...);
</PRE>
</BLOCKQUOTE>
allows direct selection.
<P>
The
<CITE CLASS="Ec">pxd_iopen</CITE>,
<CITE CLASS="Ec">pxd_iopencolor</CITE>,
<CITE CLASS="Ec">pxd_ioc</CITE>,
and
<CITE CLASS="Ec">pxd_ios</CITE>,
are replaced by
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>,
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>.
An explicit
<CITE CLASS="Ec">pxd_iopen</CITE>
or
<CITE CLASS="Ec">pxd_iopencolor</CITE>
followed by a transfer request is not necessary;
each of
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>,
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>
transfers pixels without requiring a preceding open.
<P>
The
<CITE CLASS="Ec">pxd_pixread</CITE>,
<CITE CLASS="Ec">pxd_pixwrite</CITE>,
<CITE CLASS="Ec">pxd_pixreadRGB</CITE>,
and
<CITE CLASS="Ec">pxd_pixwriteRGB</CITE>
were always documented to be an inefficient convenience,
To dissuade programmers against reading or writing single pixels,
they have not been replaced.
Of course, the
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>,
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>
can still used upon single pixels.
<P>
The
<CITE CLASS="Ec">pxd_defimage</CITE>
and
<CITE CLASS="Ec">pxd_defimagecolor</CITE>
are replaced by
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>.
The
<CITE CLASS="Ec">pxd_defimage3</CITE>
and
<CITE CLASS="Ec">pxd_defimage3color</CITE>
are replaced by
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>.
The XCOBJ suggested against saving the
<CITE CLASS="Ec">pxd_defimage</CITE>
result, such as:
<BLOCKQUOTE>
<PRE>
    struct pximage image;
<BR>
    image = *pxd_defimage();
</PRE>
</BLOCKQUOTE>
This practice is still prohibited.
<P>
The
<CITE CLASS="Ec">pxd_vidgenlock</CITE>,
<CITE CLASS="Ec">pxd_vidparm</CITE>,
<CITE CLASS="Ec">pxd_vidsize</CITE>,
and
<CITE CLASS="Ec">pxd_vidfield</CITE>
do not have direct replacements within the SCF style functions.
Instead, a Video Configuration Format, with suitable options set,
can be loaded by
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>.
<P>
The
<CITE CLASS="Ec">pxd_chkfault</CITE>
and
<CITE CLASS="Ec">pxerrnomesg</CITE>
are replaced by
<CITE CLASS="Ec">pxd_mesgFault</CITE>
and
<CITE CLASS="Ec">pxd_mesgErrorCode</CITE>.
The
<CITE CLASS="Ec">pxd_chkstack</CITE>
is obsolete and not replaced.
<P>
The
<CITE CLASS="Ec">pxd_bmpsave</CITE>,
<CITE CLASS="Ec">pxd_bmpload</CITE>,
<CITE CLASS="Ec">pxd_tgasave</CITE>,
<CITE CLASS="Ec">pxd_pcxsave</CITE>,
<CITE CLASS="Ec">pxd_pcxload</CITE>,
<CITE CLASS="Ec">pxd_tiffsave</CITE>,
and
<CITE CLASS="Ec">pxd_tiffload</CITE>
are replaced by
<A HREF="#pxd_saveBmp"CLASS="Er">pxd_saveBmp</A>,
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>,
<A HREF="#pxd_saveTga"CLASS="Er">pxd_saveTga</A>,
<A HREF="#pxd_savePcx"CLASS="Er">pxd_savePcx</A>,
<A HREF="#pxd_saveTiff"CLASS="Er">pxd_saveTiff</A>,
and
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>.
<P>
The
<CITE CLASS="Ec">pxd_StretchDIBits</CITE>,
<CITE CLASS="Ec">pxd_DIBCreate</CITE>,
and
<CITE CLASS="Ec">pxd_DIBFree</CITE>
are replaced by
<A HREF="#pxd_renderStretchDIBits"CLASS="Er">pxd_renderStretchDIBits</A>,
<A HREF="#pxd_renderDIBCreate"CLASS="Er">pxd_renderDIBCreate</A>,
and
<A HREF="#pxd_renderDIBFree"CLASS="Er">pxd_renderDIBFree</A>.
<P>
The
<CITE CLASS="Ec">pxd_DirectVideoInit</CITE>
and
<CITE CLASS="Ec">pxd_DirectVideoDone</CITE>
are replaced by
<A HREF="#pxd_renderDirectVideoInit"CLASS="Er">pxd_renderDirectVideoInit</A>
and
<A HREF="#pxd_renderDirectVideoDone"CLASS="Er">pxd_renderDirectVideoDone</A>.
The
<CITE CLASS="Ec">pxd_DirectVideo</CITE>
are replaced by
<A HREF="#pxd_renderDirectVideoUnLive"CLASS="Er">pxd_renderDirectVideoUnLive</A>
and
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>.
<P>
The
<CITE CLASS="Ec">pxd_extin</CITE>,
<CITE CLASS="Ec">pxd_extinreset</CITE>,
and
<CITE CLASS="Ec">pxd_extout</CITE>
are replaced by
<A HREF="#pxd_getGPIn"CLASS="Er">pxd_getGPIn</A>,
<A HREF="#pxd_setGPIn"CLASS="Er">pxd_setGPIn</A>,
and
<A HREF="#pxd_setGPOut"CLASS="Er">pxd_setGPOut</A>.
<P>
The
<CITE CLASS="Ec">pxd_vidmux</CITE>,
<CITE CLASS="Ec">pxd_contrastbrightness</CITE>,
and
<CITE CLASS="Ec">pxd_huesaturation</CITE>
used with the PIXCI&reg; SV2, SV3, and SV4
are replaced by
<A HREF="#pxd_setVidMux"CLASS="Er">pxd_setVidMux</A>,
<A HREF="#pxd_setContrastBrightness"CLASS="Er">pxd_setContrastBrightness</A>,
and
<A HREF="#pxd_setHueSaturation"CLASS="Er">pxd_setHueSaturation</A>.
The new functions have effect immediately,
rather than waiting for the end of a frame, stopping video capture,
and restarting.
<P>
The
<CITE CLASS="Ec">pxd_setDalsa01</CITE>,
<CITE CLASS="Ec">pxd_setKodak01</CITE>,
<CITE CLASS="Ec">pxd_setHitachi01</CITE>,
and
<CITE CLASS="Ec">pxd_setBasler01</CITE>
used with the PIXCI&reg; D, D24, D32, and A
are replaced by
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>.
The new function has effect immediately,
rather than waiting for the end of a frame, stopping video capture,
and restarting.
The new function provides for changing the
''exsync''
and
''prin''
values, typically integration time or line period,
but does not provide for changing camera modes;
instead, a Video Configuration Format, with suitable options set,
can be loaded by
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>.
Although the
<CITE CLASS="Ec">pxd_setDalsa01</CITE>,
<CITE CLASS="Ec">pxd_setKodak01</CITE>,
<CITE CLASS="Ec">pxd_setHitachi01</CITE>,
and
<CITE CLASS="Ec">pxd_setBasler01</CITE>
allowed setting bits corresponding to camera modes,
they were often misunderstood and misused; as corresponding parameters
in the video format also must be changed.
<P>
The
<CITE CLASS="Ec">pxd_snap</CITE>
is replaced by
<CITE CLASS="Ec">pxd_doSnap</CITE>.
The
<CITE CLASS="Ec">pxd_vidtime</CITE>
is replaced by
<A HREF="#pxd_videoFieldCount"CLASS="Er">pxd_videoFieldCount</A>.
<P>
The
<CITE CLASS="Ec">pxvid_snapbufa</CITE>
and
<CITE CLASS="Ec">pxvid_gobufa</CITE>
are replaced by
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>,
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>,
and
<A HREF="#pxd_goUnLive"CLASS="Er">pxd_goUnLive</A>.
The
<CITE CLASS="Ec">pxvid_snapbufw</CITE>
and
<CITE CLASS="Ec">pxvid_gobufw</CITE>
are replaced by using
<A HREF="#pxd_capturedBuffer"CLASS="Er">pxd_capturedBuffer</A>,
<A HREF="#pxd_capturedSysTicks"CLASS="Er">pxd_capturedSysTicks</A>,
and/or
<A HREF="#pxd_capturedFieldCount"CLASS="Er">pxd_capturedFieldCount</A>.
However, the
<CITE CLASS="Ec">pxvid_snapbufw</CITE>
and
<CITE CLASS="Ec">pxvid_gobufw</CITE>
functions were intended to be used
to wait until, or test whether, the previous
<CITE CLASS="Ec">pxvid_snapbufa</CITE>
and
<CITE CLASS="Ec">pxvid_gobufa</CITE>
had effect, with the intention that the application could then
''orchestrate''
''ping-pong''
or sequence capture.
In contrast
<A HREF="#pxd_capturedBuffer"CLASS="Er">pxd_capturedBuffer</A>,
<A HREF="#pxd_capturedSysTicks"CLASS="Er">pxd_capturedSysTicks</A>,
and/or
<A HREF="#pxd_capturedFieldCount"CLASS="Er">pxd_capturedFieldCount</A>
reports whether and when a new field or frame has been captured;
with the intention to track the progress of
<A HREF="#pxd_goLivePair"CLASS="Er">pxd_goLivePair</A>
or
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>
which initiate a
''ping-pong''
capture, or a sequence capture, respectively,
and proceeds without further
''orchestratation''
by the application.
<P>
The
<CITE CLASS="Ec">pxd_video</CITE>
is replaced by
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>
and
<A HREF="#pxd_goUnLive"CLASS="Er">pxd_goUnLive</A>;
although the latter functions always return immediately.
<A NAME="Using a Serial (RS-232) Configurable Camera with the PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI"CLASS="Ch"></A>
<A NAME="12.2.  Using a Serial (RS-232) Configurable Camera with the PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI"></A>
<H2>12.2.  Using a Serial (RS-232) Configurable Camera with the PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI</H2>
<P>
When used with a PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI imaging board,
the XCLIB identifies the camera for which the specific model of the
PIXCI&reg; imaging board is intended and
sets a default Video Format Configuration compatible with
that camera's default operating mode.
Typically, the camera's default operating mode is
for continuous, periodic (i.e free-running) video at maximum resolution.
The XCLIB
does not re-configure the camera through the computer's serial RS-232 port
or through the Camera Link serial port of the PIXCI&reg; CL1, CL2, E1, E4, E1DB, or CL3SD.<A HREF="#Footnote 42"CLASS="Ff"><SUP>[42]</SUP></A>
<BR>
<A NAME="Initialization"CLASS="Ch"></A>
<A NAME="12.2.1.  Initialization"></A>
<H3>12.2.1.  Initialization</H3>
<P>
To use the camera and PIXCI&reg; imaging board in other modes &mdash;
such as triggered capture with asynchronous reset,
binning, or integration &mdash;
requires that both the camera and the PIXCI&reg; imaging board
be reconfigured.
The camera's operating mode must be reconfigured
through the serial (RS-232 or Camera Link) port;
the PIXCI&reg; imaging board must be reconfigured through
the XCLIB library.
<P>
An easy method to perform these reconfigurations
is to take advantage of features provided in the
<CITE CLASS="Ec">XCAP</CITE>
application for this purpose.
The XCAP application is used only during program development;
it is
<U CLASS="U">not</U>
needed when the program being developed is run.
<P>
First, launch a compatible version of XCAP<A HREF="#Footnote 43"CLASS="Ff"><SUP>[43]</SUP></A>
and use its GUI to configure the camera's operating mode
and the PIXCI&reg; imaging board to the desired configuration.
After verifying the proper configuration (such as correct
triggering with externally provided signals, or sufficient
light sensitivity relative to binning and integration options):
<OL TYPE="1">
<P>
<LI>
Export the PIXCI&reg; imaging board Video Format
Configuration parameters to a file with:
<BLOCKQUOTE>
<PRE>
    PIXCI&reg;
    PIXCI&reg; Save Video Setup
</PRE>
</BLOCKQUOTE>
<P>
<LI>
Export the camera's current operating mode's serial
(RS-232 or Camera Link) commands to a file using the:
<BLOCKQUOTE>
<PRE>
    Export Commands
</PRE>
</BLOCKQUOTE>
button in the camera's
''Capture &amp; Adjust''
dialog box.
Each camera's
''Capture &amp; Adjust''
dialog differs, but typically:
a)&nbsp;The dialog has a left half devoted to the
PIXCI&reg; imaging board and a right half devoted to the
camera's serial (RS-232 or Camera Link) controlled parameters,
b)&nbsp;The
''Export Commands''
button is typically found under the
''Opt''
or
''Port''
tab of the right half of the dialog.
</OL>
XCAP can now be closed.
<P>
Second, in the application program being developed,
open the XCLIB library, specifying the previously
saved Video Format Configuration file as the third parameter of
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>.
This configures the PIXCI&reg; imaging board appropriately.
<P>
Third, in the application program being developed, send
the contents of the exported serial (RS-232) command file
through the appropriate serial (RS-232) port.
This configures the camera's operating mode appropriately and consistently
with the PIXCI&reg; imaging board configuration.
An example method follows for cameras connected via an RS-232 port under Windows:<A HREF="#Footnote 44"CLASS="Ff"><SUP>[44]</SUP></A>:
<BLOCKQUOTE>
<PRE>
    #include &lt;windows.h&gt;
    #include &lt;stdio.h&gt;
<BR>
    FILE    *fp;
    HANDLE  fd;
    DCB     dcb;
    char    *name = &quot;COMx&quot;;
    int     i, n, l;
    //
    // Open access to COM port.
    //
    name[3] = 1 + '0';  // for COM1
    name[3] = 2 + '0';  // for COM2
    name[3] = 3 + '0';  // for COM3, etc
    fd = CreateFile(name, GENERIC_READ|GENERIC_WRITE, OF_SHARE_COMPAT,
                    0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (fd == INVALID_HANDLE_VALUE)
        exit(1);    // can't open COM port - produce suitable error message
    memset(&amp;dcb, 0, siz(dcb));
    if (!GetCommState(fd, &amp;dcb)) {
        CloseHandle(fd);
        exit(1);    // can't get COM port state - produce suitable error message
    }
    dcb.fBinary         = TRUE;
    dcb.fDtrControl     = DTR_CONTROL_ENABLE;
    dcb.fDsrSensitivity = FALSE;
    dcb.fNull           = FALSE;
    dcb.fRtsControl     = RTS_CONTROL_ENABLE;
    dcb.BaudRate        = 9600;     // replace with camera's baud rate
    dcb.ByteSize        = 8;        // assume camera with 8 bits per word
    dcb.Parity          = 0;        // assume no parity used
    dcb.StopBits        = 2;        // camera may spec fewer stop bits, more doesn't hurt!
    dcb.fOutX = dcb.fInX = 0;       // assume camera w/out RS-232 flow control
    dcb.fOutxCtsFlow = dcb.fOutxDsrFlow = FALSE;
    SetCommState(fd, &amp;dcb);
    SetupComm(fd, 4096, 4096);
    //
    // Open exported file with camera's RS-232 data stream.
    //
    fp = fopen(&quot;camera.dat&quot;, &quot;rb&quot;);
    if (!fp) {
        CloseHandle(fd);
        exit(1);    // can't find file - produce suitable error message
    }
    //
    // Send each command from file through COM port.
    // For most cameras, we should wait until the camera
    // has finished processing one command before sending
    // the next. A sophisticated method would be to wait for
    // the camera's response to each command - and even
    // to check whether the response indicates an error.
    // For simplicity, and because this code is used only
    // during initialization - so overall elapsed time should
    // not be critical - we simply pause after each command.
    //
    for (n = 0; (i = fgetc(fp)) != EOF; ) {
        DWORD   w = 0;
        uchar   buf[1];
<BR>
        //
        // Send byte of command.
        //
        buf[0] = i;
        WriteFile(fd, buf, 1, &amp;w, NULL);
<BR>
        //
        // Is the last byte sent the end of a command?
        // The test is camera specific!
        //
        #if 1                       // for DVC, older Basler, Hamamatsu, Uniq
            if (i == '\r')         // Dalsa
                Sleep(1000);
        #elif 0                     // for Pulnix, Cohu
            if (i == '\x03')
                Sleep(1000);
        #elif 0                     // for newer Basler, which ends w. 0x03
            if (n++ == 2)           // but may also have embedded 0x03,
                l = (i&amp;0x7F)+5;     // utilize the command's length count
            if (n &gt; 2 &amp;&amp; n == l) {
                Sleep(1000);
                n = 0;
            }
        #elif 0                     // for Hitachi
            if (i == '\x05')
                Sleep(50);
            if (i == '\x03')
                Sleep(1000);
        #elif 0                     // for Kodak/Roper MASD
            if (i == '\n')         // Some ES 4.0 commands may
                Sleep(1000);        // require delay of several seconds!
        #endif
    }
    //
    // All done. Clean up.
    //
    fclose(fp);
    CloseHandle(fd);
</PRE>
</BLOCKQUOTE>
<P>
Alternately, for cameras connected via Camera Link, send
the contents of the exported serial (RS-232) command file
through the PIXCI&reg; CL1, CL2, E1, E4, E1DB, or CL3SD Camera Link serial port:
<BLOCKQUOTE>
<PRE>
    FILE    *fp;
    int     i, n, l;
    //
    // Configure serial port for the Camera Link standard
    // of 9600 baud, 8 bits, 1 stop bit, no parity.
    //
    pxd_serialConfigure(0x01, 0, 9600, 8, 0, 1, 0, 0, 0);
    //
    // Open exported file with camera's RS-232 data stream.
    //
    fp = fopen(&quot;camera.dat&quot;, &quot;rb&quot;);
    if (!fp)
        exit(1);    // can't find file - produce suitable error message
    //
    // Send each command from file through serial port.
    //
    for (n = 0; (i = fgetc(fp)) != EOF; ) {
        char buf[1];
        buf[0] = i;
        pxd_serialWrite(0x01, 0, buf, 1);
        //
        // Is the last byte sent the end of a command?
        // The test is camera specific!
        //
        #if 1                       // for Silicon Imaging, Uniq, Dalsa
            if (i == '\r')
                Sleep(1000);
        #elif 0                     // for Pulnix, Cohu
            if (i == '\x03')
                Sleep(1000);
        #elif 0                     // for newer Basler, which ends w. 0x03
            if (n++ == 2)           // but may also have embedded 0x03,
                l = (i&amp;0x7F)+5;     // utilize the command's length count
            if (n &gt; 2 &amp;&amp; n == l) {
                Sleep(1000);
                n = 0;
            }
        #endif
    }
    //
    // All done. Clean up.
    //
    fclose(fp);
</PRE>
</BLOCKQUOTE>
<P>
For selected Camera Link cameras,
the Video Format Configuration files saved by
XCAP include the serial commands needed to restore
the camera's operating mode.
XCLIB loads the serial commands contained
in the Video Format Configuration file specified as the third parameter of
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>,
eliminating having to follow part three of the instructions above.
This integrated support is currently provided for
selected Adimec, Atmel, Basler, Cohu, Dalsa, DVC,
EG&amp;G Reticon, Hitachi, Illunis, Imperx,
Jai, Redlake, Silicon Imaging, Sony, SVS Vistek, and Uniq
cameras, and may be added (or have been added)
for other cameras post-publication
of this application note.<A HREF="#Footnote 45"CLASS="Ff"><SUP>[45]</SUP></A>
<P>
To determine whether this integrated support is available for
a specific camera, in XCAP:
<BLOCKQUOTE>
<PRE>
    PIXCI&reg; (in Main Window
    PIXCI&reg; Open/Close
    Close (if open)
    Camera &amp; Format
    Open w. Default Video Setup
    OK
    Open
    PIXCI&reg; (in Main Window
    PIXCI&reg; Save Video Setup
</PRE>
</BLOCKQUOTE>
If the
<BLOCKQUOTE>
<PRE>
    Include Camera Link Serial Commands
</PRE>
</BLOCKQUOTE>
checkbox is active, then integrated support
for XCLIB loading of serial commands
is available for the current camera.
<P>
(The SILICON VIDEO&reg; cameras, although they are technically not
configured via serial (RS-232) commands and
not a proper subject of this application note,
are configured via serial-like commands sent through the PIXCI&reg;
imaging board.
It is therefore worthwhile noting that
the Video Format Configuration files saved by
XCAP include the serial-like commands needed to restore
the SILICON VIDEO&reg; camera's operating mode).
<BR>
<A NAME="Adjustments"CLASS="Ch"></A>
<A NAME="12.2.2.  Adjustments"></A>
<H3>12.2.2.  Adjustments</H3>
<P>
In addition to the
initialization described above,
the application program may wish to adjust the camera -
such as the gain, exposure, black level -
via serial commands during program execution.
These types of adjustments do not affect the PIXCI&reg; imaging board configuration.
In contrast, adjusting the camera's trigger mode, binning, bit-depth,
or area of interest features do reflect upon the PIXCI&reg; imaging board's
configuration, and a new set of Video Format Configuration
parameters should be saved via
<CITE CLASS="Ec">XCAP</CITE>.
<P>
Adjusting the camera's gain, exposure, black level, and similar parameters
could be done by using
<CITE CLASS="Ec">XCAP</CITE>'s
''Export Commands''
feature for each unique combination of gain, exposure, etc.,
if the application only needs a relatively small number of
adjustment combinations.
<P>
Alternately, adjusting the camera's gain, exposure,
black level, and similar parameters
requires familiarity with the camera's unique serial commands,
as described in the camera's manufacturer's documentation.
<CITE CLASS="Ec">XCAP</CITE>
can assist in learning about a specific camera's serial commands.
By activating the RS-232 Log (or Serial Log), typically found under the
''Port''
tab, XCAP will log and display each serial command sent as the camera's GUI
controls are modified.
The programmer can be read these as examples of the commands necessary to be
sent via the computer's COM port for RS-232
or via
<CITE CLASS="Ec">pxd_serialWrite</CITE>
for Camera Link.
<A NAME="Using a Video Format Configuration Exported by XCAP"CLASS="Ch"></A>
<A NAME="12.3.  Using a Video Format Configuration Exported by XCAP"></A>
<H2>12.3.  Using a Video Format Configuration Exported by XCAP</H2>
<P>
<A NAME="Video Format Configuration NX817"CLASS="NX"></A>
The Video Format Configuration
is a group of dozens of parameters
that defines the video format
(i.e. whether NTSC, RS-170, PAL, or CCIR
for applicable imaging boards,
or camera manufacturer and model for other
imaging boards),
the resolution (i.e. capturing more or fewer pixels
per line or column),
and other settings related to the imaging board's hardware.
<P>
The XCLIB provides a suitable default Video Format Configuration
for each PIXCI(rg imaging board, model, and submodel.
<P>
The easiest and suggested method of creating an
alternate Video Format Configuration is to use
<CITE CLASS="Ec">XCAP</CITE>.
XCAP uses an identical and compatible<A HREF="#Footnote 46"CLASS="Ff"><SUP>[46]</SUP></A>
Video Format Configuration,
although XCAP uses the term
''Video Setup''.
In XCAP, use:
<BLOCKQUOTE>
<PRE>
    PIXCI&reg;
    PIXCI&reg; Video Setup
    .. adjust video configuration followed by OK ..
    PIXCI&reg;
    PIXCI&reg; Save Video Setup
</PRE>
</BLOCKQUOTE>
After running XCAP, simply specify the
path name of the saved video setup file
as the third parameter to
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
(with the second parameter set to NULL)
or as the fifth parameter to
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>
(with the fourth parameter set to NULL)
to configure XCLIB to the same Video Format Configuration.
<P>
However, for application programs which are to be distributed,
the saved video setup file must be distributed as well.
This can be advantageous - substituting a different video setup file
may allow the application to work with other cameras
or in other camera modes without recompilation - or
disadvantageous when the video setup file is lost or accidentally modified.
<P>
Alternatively, the Video Format Configuration
can be integrated into the application,
preventing loss of, or accidental changes to, a file required at run time,
as well as providing slightly quicker switching between different
Video Format Configurations.
The saved video setup file is readable text with the
syntax of several
''C''
structure initializers;
it can be directly compiled by simply including it
within the application's C/C++
program.
<P>
If using the SCF Style Interface, the
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
macro can be used as:
<BLOCKQUOTE>
<PRE>
    {
        #include &quot;format.fmt&quot;           // a saved video setup file
        pxd_videoFormatAsIncluded(0); // configure as per the above
    }
</PRE>
</BLOCKQUOTE>
to configure XCLIB as per the included video setup file.
Of course, the contents of the
''format.fmt''
file could instead be copied and pasted into the application
instead of being included; both methods result
in the Video Format Configuration
being integrated into the application.<A HREF="#Footnote 47"CLASS="Ff"><SUP>[47]</SUP></A>
<A NAME="Capture into Devices"CLASS="Ch"></A>
<A NAME="12.4.  Capture into Devices"></A>
<H2>12.4.  Capture into Devices</H2>
<P>
The architecture of the
PIXCI&reg; SV2, SV3, SV4, SV5, SV5A, D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, SI, and A imaging boards
allows capturing image data by use of PCI Bus Mastering.
Typically, image data is transferred into the reserved
image frame buffer memory &mdash; a pre-allocated pool of host memory.
However, the image data can instead be transferred to
any block of consecutive addresses in PCI address space.
<P>
The
<EM CLASS="Ep">pxvidphys</EM>
structure completely specifies the capture target address space
(see
<CODE CLASS="Em">pxlibvs.h</CODE>).
<P>
When capturing into image frame buffer memory, the XCLIB
provides a simplified means of specifying the capture target address space &mdash;
the image frame buffer number.
Based on the memory size required for each image buffer
and on the total size of image frame buffer memory,
XCLIB partitions the image frame buffer memory
into one or more image frame buffers.
A function such as
<A HREF="#::setSnapBuf"CLASS="Er">::setSnapBuf</A>
specifies the capture target as a single, simple, image frame buffer number;
XCLIB then translates the specified frame buffer number to a memory specification
and fills in the
<EM CLASS="Ep">pxvidphys</EM>
appropriately.
<P>
By explicitly filling the
<EM CLASS="Ep">pxvidphys</EM>
rather than using an image frame buffer number,
and by using the
<A HREF="#::setLivePhys"CLASS="Er">::setLivePhys</A>
instead of the
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>
service,
images can be captured to targets in PCI address space
other than the image frame buffer memory.
<P>
If
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">upatita</EM>=0
the addresses are interpreted as being relative to frame buffer memory.
Alternately, addresses may also be interpreted as being in user space, or
as being bus physical; the
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">upatita</EM>
for these interpretations
<U CLASS="U">must</U>
be set by using
<A HREF="#::signStateCopy"CLASS="Er">::signStateCopy</A>
to
''sign''
the
<EM CLASS="Ep">pxvidphys</EM>
instance after all other fields have been set.<A HREF="#Footnote 48"CLASS="Ff"><SUP>[48]</SUP></A>
<P>
When using an image frame buffer number, the
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">buffer</EM>,
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">stateid</EM>,
and
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">tracker</EM>,
are automatically set to the buffer number, the video state id,
and an arbitrary tracker number provided by
<A HREF="#::setLiveBuf"CLASS="Er">::setLiveBuf</A>.
When using
<A HREF="#::setLivePhys"CLASS="Er">::setLivePhys</A>
these are arbitrary values; the values provided
are later reported by
<A HREF="#::getLiveStatus"CLASS="Er">::getLiveStatus</A>.
<P>
The use and constraints of the
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">startadrs</EM>,
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">endadrs</EM>,
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">linelength</EM>,
<EM CLASS="Ep">pxvidphys</EM>.<EM CLASS="Ep">linestride</EM>,
are dependent on the specific imaging board;
see examples below.
<P>
If multiple image boards are in use, the
<BLOCKQUOTE>
<PRE>
    xcdev.setLiveBuf(0x03, ..., 1);
</PRE>
</BLOCKQUOTE>
which commands imaging boards one and two to both begin
capturing into frame buffer number 1,
does not cause conflict or overwriting of image data;
each board is assigned its own, unique, buffer number 1.
When using
<A HREF="#::setLivePhys"CLASS="Er">::setLivePhys</A>,
each selected imaging board is provided with its own
<EM CLASS="Ep">pxvidphys</EM>.
Thus,
<A HREF="#::setLivePhys"CLASS="Er">::setLivePhys</A>
allows for an array of
<EM CLASS="Ep">pxvidphys</EM>
specifications, one per selected imaging board.
<BR>
<A NAME="PIXCI&reg; SV4 SV5, or SV5A and DirectDraw"CLASS="Ch"></A>
<A NAME="12.4.1.  PIXCI&reg; SV4 SV5, or SV5A and DirectDraw"></A>
<H3>12.4.1.  PIXCI&reg; SV4 SV5, or SV5A and DirectDraw</H3>
<P>
The following example is an extract of
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>,
and assumes familiarity with DirectDraw.
For the sake of brevity, the example assumes that
the PXMODE_DIGI video state has already been defined
with a pixel format compatible to the graphics display (S/VGA) secondary surface<A HREF="#Footnote 49"CLASS="Ff"><SUP>[49]</SUP></A>
(such as YUYV rather than RGB),
and that the resolution has been set
to match the display window's size.
<BLOCKQUOTE>
<PRE>
    DDSURFACEDESC       surface2;   // a DirectDraw struct
    pxvidphys_s         vidphys;
    xclib_DeclareVidStateStructs(vidstate);
    //
    // Create different state, copy of PXMODE_DIGI
    //
    xclib_InitVidStateStructs(vidstate);
    xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
    //
    // Setup to send video to overlay plane.
    // We assume the 'surface2' has already been specified and
    // acquired from DirectDraw.
    //
    memset(&amp;vidphys, 0, siz(vidphys));
    vidphys.ddch.mos     = PXMOS_VIDPHYS;
    vidphys.ddch.len     = siz(pxvidphys_s);
    vidphys.bufxdim      = vidstate.vidres-&gt;x.datsamples;
    vidphys.bufydim      = vidstate.vidres-&gt;y.datsamples;
    vidphys.bufidim      = vidstate.vidres-&gt;datfields;
    vidphys.bufadrs      = (uint32)surface2.lpSurface;
    vidphys.startadrs[0][0]  = (uint32)surface2.lpSurface;
    vidphys.startadrs[1][0]  = (uint32)surface2.lpSurface;
    vidphys.linelength[0][0] = vidstate.vidres-&gt;x.datsamples*2;   // assumes YUV!
    vidphys.linelength[1][0] = vidstate.vidres-&gt;x.datsamples*2;   // assumes YUV!
    vidphys.linestride[0][0] = surface2.lPitch-vidphys.linelength[0][0];
    vidphys.linestride[1][0] = surface2.lPitch-vidphys.linelength[1][0];
    if (vidstate.vidres-&gt;datfields == 2) {
        vidphys.startadrs[0][0]  += surface2.lPitch;
        vidphys.linestride[0][0] += surface2.lPitch;
        vidphys.linestride[1][0] += surface2.lPitch;
    }
    vidphys.buffer    = 0;  // optional, so capture of this is never confused with a real buffer
    //
    // Sign the vidphys. Addresses provided by
    // DirectDraw are in user space, not physical!
    //
    vidstate.vidphys = &amp;vidphys;
    if (xclib.xclib.signStateCopy(&amp;xclib.xclib, 0, 0, &amp;vidstate, 'u', 's') &lt; 0)
        return; // error!
    //
    // If the new state changed the resolution or the pixel format, we must ..
    //
    if (xclib.xcdev.setVideoConfig(&amp;xclib.xcdev, unitmap, 0, 0, &amp;vidstate, NULL))
        return; // error!
    //
    // Start live video
    //
    if (xclib.xcdev.setLivePhys(&amp;xclib.xcdev, unitmap, 0, 0, &amp;vidstate, NULL, &amp;vidphys))
        return; // error!
</PRE>
</BLOCKQUOTE>
This example is not intended to show
how to specify and acquire a DirectDraw surface,
how to overlay the DirectDraw
secondary surface onto the primary surface, and how to
optionally activate chroma keying; these topics are described in
the DirectDraw documentation.
<BR>
<A NAME="PIXCI&reg; and StreamStor"CLASS="Ch"></A>
<A NAME="12.4.2.  PIXCI&reg; and StreamStor"></A>
<H3>12.4.2.  PIXCI&reg; and StreamStor</H3>
<P>
The following example is an extract of the XCAP
''Video to StreamStor''
feature; it assumes familiarity
with the StreamStor XLR API.
<BLOCKQUOTE>
<PRE>
    HANDLE      hXLR;
    xclib_DeclareVidStateStructs(vidstate);
    //
    // Get video state in use.
    //
    xclib_InitVidStateStructs(vidstate);
    xclib.pxlib.getState(&amp;xclib.pxlib, 0, PXMODE_DIGI, &amp;vidstate);
    //
    // Build the pxvidphys.
    //
    memset(&amp;vidphys, 0, siz(vidphys));
    vidphys.ddch.mos = PXMOS_VIDPHYS;
    vidphys.ddch.len = siz(pxvidphys_s);
    vidphys.startadrs[0][0] = XLRGetBaseAddr(hXLR);
    vidphys.startadrs[1][0] = XLRGetBaseAddr(hXLR);
    //
    // Sign the vidphys. Addresses provided
    // by XLR are physical, not user space!
    //
    vidstate.vidphys = &amp;vidphys;
    if (xclib.xclib.signStateCopy(&amp;xclib.xclib, 0, 0, &amp;vidstate, 'p', 's') &lt; 0)
        return; // error!
    //
    // Start XLR recording then start live video
    //
    XLRRecord(hXLR, FALSE, 1);
    if (xclib.xcdev.setLivePhys(&amp;xclib.xcdev, unitmap, 0, 0, &amp;vidstate, NULL, &amp;vidphys))
        return; // error!
</PRE>
</BLOCKQUOTE>
<A NAME="Adjusting White Balance of a Bayer Output Camera with the PIXCI&reg; Imaging Board"CLASS="Ch"></A>
<A NAME="12.5.  Adjusting White Balance of a Bayer Output Camera with the PIXCI&reg; Imaging Board"></A>
<H2>12.5.  Adjusting White Balance of a Bayer Output Camera with the PIXCI&reg; Imaging Board</H2>
<P>
When a Bayer output camera is used with a
PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI imaging board, the XCLIB
performs Bayer to RGB conversion and white balancing in software.
As for all color cameras, white balancing is subject to the
current illuminate's color spectrum, and should be adjusted
for different illumination.
A simple method of white balancing follows.
<P>
<OL TYPE="1">
<P>
<LI>
Capture an image of a white or grey target:
<BLOCKQUOTE>
<PRE>
    pxd_doSnap(1, 1, 0);
</PRE>
</BLOCKQUOTE>
<P>
<LI>
Obtain
<U CLASS="U">true</U>
average red, green, and blue values of the
<U CLASS="U">captured</U>
grey target image.
Thus, we turn off software white balancing before obtaining
average values:
<BLOCKQUOTE>
<PRE>
    unsigned int reference[3] = {0,0,0};
    unsigned int target[3]    = {0,0,0};
    pxd_setImageBrightBalance(1, reference, target, 0.00);
</PRE>
</BLOCKQUOTE>
<P>
<LI>
Obtain average pixel values.
This is slightly simpler if the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
is available:
<BLOCKQUOTE>
<PRE>
    double  masses[] = {0, 0, 0};
    double  xcenter, ycenter;
<BR>
    pxip8_masscenter(NULL,pxd_defineImage(1, 1, 0, 0, -1, -1, &quot;RofRGB&quot;), &amp;masses[0], &amp;xcenter, &amp;ycenter);
    pxip8_masscenter(NULL,pxd_defineImage(1, 1, 0, 0, -1, -1, &quot;GofRGB&quot;), &amp;masses[1], &amp;xcenter, &amp;ycenter);
    pxip8_masscenter(NULL,pxd_defineImage(1, 1, 0, 0, -1, -1, &quot;BofRGB&quot;), &amp;masses[2], &amp;xcenter, &amp;ycenter);
    reference[0] = masses[0]/(double)pxd_imageXdim()*pxd_imageYdim();
    reference[1] = masses[1]/(double)pxd_imageXdim()*pxd_imageYdim();
    reference[2] = masses[2]/(double)pxd_imageXdim()*pxd_imageYdim();
</PRE>
</BLOCKQUOTE>
Or can be done by directly reading pixel values:
<BLOCKQUOTE>
<PRE>
    double  masses[] = {0, 0, 0};
    ushort  pixels[9*9];
    int     midx, midy, i;
<BR>
    midx = pxd_imageXdim()/2;
    midy = pxd_imageYdim()/2;
    pxd_readushort(1,1,midx-9/2,midy-9/2,midx+1+9/2,midy+1+9/2,pixels,9*9,&quot;RofRGB&quot;);
    for (i = 0; i &lt; 9*9; i++)
        masses[0] += pixels[i];
    pxd_readushort(1,1,midx-9/2,midy-9/2,midx+1+9/2,midy+1+9/2,pixels,9*9,&quot;GofRGB&quot;);
    for (i = 0; i &lt; 9*9; i++)
        masses[1] += pixels[i];
    pxd_readushort(1,1,midx-9/2,midy-9/2,midx+1+9/2,midy+1+9/2,pixels,9*9,&quot;BofRGB&quot;);
    for (i = 0; i &lt; 9*9; i++)
        masses[2] += pixels[i];
    reference[0] = masses[0]/(9*9);
    reference[1] = masses[1]/(9*9);
    reference[2] = masses[2]/(9*9);
</PRE>
</BLOCKQUOTE>
Whether it is best to obtain the average values from the whole image or an AOI
is debatable; the former example does the entire image, the later does
a small 9&times;9 AOI; either method can be changed to any size AOI.
<P>
<LI>
Determine suitable target pixel values.
This is often the lowest, highest, or mean of the reference
values - but should typically be the same for all three colors:
<BLOCKQUOTE>
<PRE>
    target[0] = target[1] = target[2]
                 = max(max(reference[0], reference[1]), reference[2]);
</PRE>
</BLOCKQUOTE>
And invoke:
<BLOCKQUOTE>
<PRE>
    pxd_setImageBrightBalance(1, reference, target, 0.60);
</PRE>
</BLOCKQUOTE>
using the preferred gamma correction coefficient
to apply the new coefficients to images accessed
via
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>.
<A NAME="Processing Images from a Bayer Output Camera with the PIXCI&reg; CL, D, or E Series"CLASS="Ch"></A>
<A NAME="12.6.  Processing Images from a Bayer Output Camera with the PIXCI&reg; CL, D, or E Series"></A>
<H2>12.6.  Processing Images from a Bayer Output Camera with the PIXCI&reg; CL, D, or E Series</H2>
<P>
When a Bayer output camera is used with a
PIXCI&reg; D, D24, D32, D2X, D3X, CL1, CL2, E1, E4, E1DB, CL3SD, or SI imaging board, the XCLIB
performs Bayer to RGB conversion and white balancing in software.
The RGB and white balancing is done automatically, and only on demand.
Thus, capture may be done with any of the standard
<A HREF="#pxd_doSnap"CLASS="Er">pxd_doSnap</A>,
<A HREF="#pxd_goSnap"CLASS="Er">pxd_goSnap</A>,
<A HREF="#pxd_goLive"CLASS="Er">pxd_goLive</A>
or similar functions, and corrected RGB (or BGR)
pixel values may be read via any of the standard
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>,
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
or similar functions.
Conversion to RGB is automatic and, for most applications,
completely transparent.
<P>
For the sake of overall efficiency,
the frame buffer's contents are not converted
en-masse and saved internally
as RGB values.
Rather, the frame buffer remains in Bayer format
and the Bayer values are converted only if, and when, they are requested.
A side effect is that
re-reading the same pixels from the same buffer requires
re-doing the Bayer conversion.
Also, any pixel values written into the frame buffer, such as by
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>,
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>,
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
or similar functions,
requires converting the RGB (or BGR) values
<U CLASS="U">into</U>
Bayer format;
a process which, when inverted, may not yield
the precise, original, pixel values.
<P>
Applications which need to re-read the same pixel
values repeatedly may benefit from copying the RGB
values from the Bayer frame buffer into a (true) RGB buffer once,
and re-reading values from the copy.
Applications which need to perform image modifications
will also benefit from copy RGB values from the Bayer
frame buffer into a (true) RGB buffer once,
and henceforth processing the copy.
<P>
A true RGB buffer that can be accessed by PXIPL
functions, can be created using
<CITE CLASS="Ec">pximage_memmalloc</CITE>
or
<CITE CLASS="Ec">pximage_memmalloc2</CITE>.
Or, an existent array or
<CITE CLASS="Ec">malloc'ed</CITE>
memory can be accessed by PXIPL
functions by creating a
<A HREF="#pximage"CLASS="Er">pximage</A>
descriptor with
<CITE CLASS="Ec">pximage_memory</CITE>.
These are similar, the former allocates space for
the pixels and creates the
<A HREF="#pximage"CLASS="Er">pximage</A>
descriptor,
the latter assumes use of previously allocated memory
and creates the
<A HREF="#pximage"CLASS="Er">pximage</A>
descriptor.
<P>
For example:
<BLOCKQUOTE>
<PRE>
    //
    // Create the RGB image buffer and pximage descriptor
    //
    void    *imagemem = NULL;
    struct  pximage image;
    struct  pxy dim;
    int     r;
<BR>
    dim.x = pxd_imageXdim();
    dim.y = pxd_imageYdim();
    r = pximage_memmalloc(&amp;image, &amp;imagemem, &amp;dim,
                         pxd_imageBdim()&lt;=8?PXDATUCHAR:PXDATUSHORT,
                         pxd_imageBdim(), 3, PXHINTRGB);
    if (r &lt; 0)
        ;   // announce error
<BR>
    //
    // Copy image from frame buffer 1, converting to RGB
    // and saving it in the 'true' RGB image buffer.
    //
    r = pxip8_copy(NULL, pxd_defineImage(0x1,1,0,0,-1,-1,&quot;RGB&quot;), &amp;image);
    //
    // We can now perform desired operations upon true RGB values,
    // writing RGB results.
    //
    r = pxip8_pixneg(NULL, &amp;image, &amp;image);
        ...
        ...
    //
    // When done, the memory allocated for the RGB image buffer
    // must be freed.
    //
    pximage_memfree(&amp;image, &amp;imagemem);
</PRE>
</BLOCKQUOTE>
or the slightly simpler and easier to use from non-C/C++
environments:
<BLOCKQUOTE>
<PRE>
    //
    // Create the RGB image buffer and pximage descriptor
    //
    struct  pximage *ip;
    int     r;
<BR>
    ip = pximage_memmalloc2(pxd_imageBdim()&lt;=8?PXDATUCHAR:PXDATUSHORT,
                            pxd_imageBdim(), 3, PXHINTRGB,
                            pxd_imageXdim(), pxd_imageYdim(),
                            0, 0, 0);
    if (ip == NULL)
        ;   // announce error
<BR>
    //
    // Copy image from frame buffer 1, converting to RGB
    // and saving it in the 'true' RGB image buffer.
    //
    r = pxip8_copy(NULL, pxd_defineImage(0x1,1,0,0,-1,-1,&quot;RGB&quot;), ip);
    //
    // We can now perform desired operations upon true RGB values,
    // writing RGB results.
    //
    r = pxip8_pixneg(NULL, ip, ip);
        ...
        ...
    //
    // When done, the memory allocated for the RGB image buffer
    // must be freed.
    //
    pximage_memfree2(ip, NULL;
</PRE>
</BLOCKQUOTE>
<HR SIZE="3">
<A NAME="Release Notes"CLASS="Ch"></A>
<A NAME="13.  Release Notes"></A>
<H1>13.  Release Notes</H1>
<BR>
<BR>
<B CLASS="Hv">RELEASE NOTES: XCLIB  &mdash; Version 2.2</B>
<OL TYPE="1">
<P>
<LI>
This release adds support for Windows XP.
(03-Dec-2001).
<P>
<LI>
Added Feature:
Function
<A HREF="#pxd_SV2112_setExposureAndGain"CLASS="Er">pxd_SV2112_setExposureAndGain</A>
allows setting the current exposure and gain
for the SILICON VIDEO&reg; 2112 and 2112C cameras.
Function
<A HREF="#pxd_SV2112_setResolutionAndTiming"CLASS="Er">pxd_SV2112_setResolutionAndTiming</A>
allows setting the current decimation, AOI, scan direction,
and pixel clock frequency for the SILICON VIDEO&reg; 2112 and 2112C cameras.
Functions
<A HREF="#pxd_SV2112_getExposure"CLASS="Er">pxd_SV2112_getExposure</A>,
<A HREF="#pxd_SV2112_getGain"CLASS="Er">pxd_SV2112_getGain</A>,
<A HREF="#pxd_SV2112_getDecimation"CLASS="Er">pxd_SV2112_getDecimation</A>,
<A HREF="#pxd_SV2112_getAoiTop"CLASS="Er">pxd_SV2112_getAoiTop</A>,
<A HREF="#pxd_SV2112_getAoiLeft"CLASS="Er">pxd_SV2112_getAoiLeft</A>,
<A HREF="#pxd_SV2112_getPixelClock"CLASS="Er">pxd_SV2112_getPixelClock</A>,
and
<A HREF="#pxd_SV2112_getScanDirection"CLASS="Er">pxd_SV2112_getScanDirection</A>
allow obtaining the eponymous setting
for the SILICON VIDEO&reg; 2112 and 2112C cameras.
(03-Dec-2001).
<P>
<LI>
Added Feature:
A SILICON VIDEO&reg; 2112 and 2112C specific example program,
XCLIBEXC.CPP, demonstrates capture, display, adjustment of
the camera's settings.
(03-Dec-2001).
<P>
<LI>
Fixed Feature:
The new
<A HREF="#::goingBufStatus"CLASS="Er">::goingBufStatus</A>
service may cause system termination
when used with multiple boards,
and when used on any but the first board.
(13-Dec-2001).
<P>
<LI>
Added Feature:
For SILICON IMAGING 3170 cameras, video setup files
saved by XCAP now contain the necessary serial
commands to (re)configure the camera.
Upon open, XCLIB now reconfigures the camera
with these serial commands.
(18-Jan-2002).
<P>
<LI>
Added Feature:
New functions
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>,
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>,
and
<A HREF="#pxd_eventGPTriggerClose"CLASS="Er">pxd_eventGPTriggerClose</A>
provide SCF level access to the software detectable
trigger provided on PIXCI&reg; D, D24, D32, D2X, and D3X
image boards.
These functions are not needed
when using a camera which itself is in trigger mode.
Rather, they can be used to detect a trigger with cameras in continuous mode
where the PIXCI&reg; trigger input
has no direct effect on camera or PIXCI&reg; imaging board.
(01-Feb-2002).
<P>
<LI>
Fixed Feature:
The
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
with some combinations of imaging boards and cameras
would produce a program fault.
(08-Feb-2002).
<P>
<LI>
Fixed Feature:
On PIXCI&reg; and cameras which produce
more than one pixel per clock, the
''vidres.x.vidoffset''
was interpreted in units of pixel clocks, instead of pixels.
(13-Feb-2002).
<P>
<LI>
Fixed Feature:
The PIXCI&reg; Windows VXD and SYS files, the XCLIB DLL files,
and the PXIPL DLL files did not have correct, or did not have any,
version information shown with the files' properties
(such as via the Windows Explorer).
(20-Feb-2002).
<P>
<LI>
Fixed/Added Feature:
The
<A HREF="#pxd_getFieldCount"CLASS="Er">pxd_getFieldCount</A>
function mentioned in the
<A HREF="#Conversion of Application Programs from XCOBJ"CLASS="Er">Conversion of Application Programs from XCOBJ</A>
was not documented.
It has been renamed to
<A HREF="#pxd_videoFieldCount"CLASS="Er">pxd_videoFieldCount</A>
(a function under the old name persists for compatibility)
and documented.
The
<A HREF="#pxd_getFieldsPerFrame"CLASS="Er">pxd_getFieldsPerFrame</A>,
never mentioned or documented,
has been renamed to
<A HREF="#pxd_videoFieldsPerFrame"CLASS="Er">pxd_videoFieldsPerFrame</A>
and documented.
(27-Feb-2002).
<P>
<LI>
Improved/Fixed Feature:
The maximum number of bits per pixel value component
was limited to 14, and has been changed to 16.
(09-Apr-2002).
<P>
<LI>
Fixed Feature:
When switching the SV2112 camera from controlled back to continuous
video mode, the
<A HREF="#pxd_SV2112_setVideoAndTriggerMode"CLASS="Er">pxd_SV2112_setVideoAndTriggerMode</A>
had to be called twice (with the same parameters).
(02-May-2002).
<P>
<LI>
Improved Feature:
The XCLIBEXC.CPP example program for use with SV2112 and SV2112C
cameras now also demonstrates the implementation
of automatic gain control (AGC).
(05-Jul-2002)
<P>
<LI>
Fixed Feature:
Using Forceful Memory allocation under Windows NT/2000/XP,
and selecting the wrong boot.ini selection when prompted
during Windows' boot, may prevent Windows from starting.
(09-Aug-2002).
<P>
<LI>
Fixed Feature:
Using multiple PIXCI&reg; D2X, D3X, CL1 under Windows 2000/XP,
where the cameras are tightly synchronized may cause
the PC to lockup until rebooted or the cameras powered down.
(12-Aug-2002).
<P>
<LI>
Added Feature:
XCLIB now supports additional features of newer PIXCI&reg; D2X, D3X
imaging boards for line scan cameras, increasing the maximum
number of lines per image from 65535 to 16777216.
(15-Aug-2002).
<P>
<LI>
Fixed Feature:
When using multiple PIXCI&reg; CL1 imaging boards with certain cameras,
the
<A HREF="#pxd_videoFieldCount"CLASS="Er">pxd_videoFieldCount</A>
<A HREF="#pxd_getFieldCount"CLASS="Er">pxd_getFieldCount</A>
<A HREF="#pxd_getGPTrigger"CLASS="Er">pxd_getGPTrigger</A>
functions always returned the status of unit 1, not the
selected
<EM CLASS="Ep">unitmap</EM>,
and the events created by
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
were signalled by activity on either unit.
(22-Aug-2002).
<P>
<LI>
Fixed Feature:
On newer machines under Windows XP, the
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
may cause system death (i.e.
''blue-screen'').
(23-Aug-2002).
<P>
<LI>
New Feature:
XCLIB and XCLIB-IPL for Windows now includes static link libraries,
as an alternative to using the dynamic link library (DLL).
For OEM application programs that are to be redistributed,
using the static link libraries minimizes the number of
files that must be redistributed.
(09-Sep-2002).
<P>
<LI>
Improved Feature:
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
and
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
now allow selecting rising, falling, or either
edge of the general purpose input, when
used with PIXCI&reg; SV4, SV5, D2X, D3X, and CL1
imaging boards.
Previously, those features always used either edge.
(09-Sep-2002).
<P>
<LI>
Improved Feature:
For
PIXCI&reg; D2X, D3X, or CL1
and line scan cameras running in
''vertical mastered''
mode (i.e. no external VDRIVE signal),
XCLIB now allows snapping an image starting
at the next line, in contrast to snapping when
the internal line counters
''roll over''.
(25-Sep-2002).
<P>
<LI>
Fixed Feature:
In the current release of XCLIB, the
''controlled''
mode parameters of
<A HREF="#pxd_SV2112_setVideoAndTriggerMode"CLASS="Er">pxd_SV2112_setVideoAndTriggerMode</A>
and
<A HREF="#pxd_SV2112_setCtrlExposureAndRate"CLASS="Er">pxd_SV2112_setCtrlExposureAndRate</A>
may not work as intended.
(04-Oct-2002).
<P>
<LI>
Added Feature:
A new example, XCLIBEX4.CPP, demonstrates
sequence capture and display with any PIXCI&reg;
imaging board.
(11-Oct-2002)
<P>
<LI>
Fixed Feature:
The
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>,
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>
as well as the similar
<A HREF="#::imageWriteUShort"CLASS="Er">::imageWriteUShort</A>,
<A HREF="#::imageReadUShort"CLASS="Er">::imageReadUShort</A>,
<A HREF="#::imageWriteUChar"CLASS="Er">::imageWriteUChar</A>,
and
<A HREF="#::imageReadUChar"CLASS="Er">::imageReadUChar</A>
functions would return 0 and read/write nothing
if the specified AOI were invalid, such as larger
than the frame buffer.
(15-Oct-2002).
<P>
<LI>
Fixed Feature:
The
<A HREF="#::bufferSaveStream"CLASS="Er">::bufferSaveStream</A>
and
<A HREF="#::bufferLoadStream"CLASS="Er">::bufferLoadStream</A>
functions may cause program death when the
<EM CLASS="Ep">alignsector</EM>
parameter is non-zero in conjunction with certain combinations
of cameras, imaging boards, and operating systems.
(16-Oct-2002).
<P>
<LI>
Improved Feature:
The
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>,
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>,
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>,
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>
now accept a
<EM CLASS="Ep">colorspace</EM>
of
''CbYCrY''
to access pixel data in UYVY format, supported
only with  a PIXCI&reg; SV2, SV3, SV4, or SV5
which has been set to capture in that format.
(28-Oct-2002).
<P>
<LI>
New Feature:
A beta version of XCLIB for the Linux 2.4.8 kernel is released.
(01-Nov-2002)
<P>
<LI>
Modified Feature:
The default frame buffer memory size under Windows NT, 2000, and XP
has been increased from 4 Mbyte to 16 Mbyte.
(05-Nov-2002).
<P>
<LI>
Fixed Feature:
For some combinations of PIXCI&reg; imaging boards and cameras,
use of
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
selecting fewer than all frame buffers,
combined with
<CITE CLASS="Ec">pxio8_binreadseq</CITE>,
<CITE CLASS="Ec">pxio8_binwriteseq</CITE>,
<CITE CLASS="Ec">pxio8_bin1writeseq</CITE>,
and
<CITE CLASS="Ec">pxio8_bin1readseq</CITE>
would result saving or loading more frame buffers than specified.
(13-Nov-2002).
<P>
<LI>
Improved Feature:
Under Windows NT, 2000, or XP the
''-WT''
driver configuration parameter now allows selecting
a high resolution kernel timer for time stamping
events.
(28-Nov-2002)
<P>
<LI>
Fixed Feature:
On some machines and cameras under Windows 2000 and XP, the
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
<A HREF="#pxd_eventGPTriggerCreate"CLASS="Er">pxd_eventGPTriggerCreate</A>
may cause system death.
(16-Dec-2002).
<P>
<LI>
Added Feature:
The Camera Link serial API has been added to XCLIB, with functions
<A HREF="#clSerialInit"CLASS="Er">clSerialInit</A>,
<A HREF="#clSerialClose"CLASS="Er">clSerialClose</A>,
<A HREF="#clSerialRead"CLASS="Er">clSerialRead</A>,
and
<A HREF="#clSerialWrite"CLASS="Er">clSerialWrite</A>.
These allow access to a PIXCI&reg; imaging board
which was already opened by XCLIB.
A separate DLL,
<CODE CLASS="Em">clSerPIXCI.dll</CODE>
which has only the Camera Link Serial API,
and can be distributed w/out XCLIB's licensing
restrictions, can be used to access the serial port
PIXCI&reg; imaging boards w/out XCLIB.
(24-Dec-2002)
<P>
<LI>
Fixed Feature:
When using 3 or more PIXCI&reg; imaging boards
that are combinations of at least 2 different models
(such as D vs SV4 vs D2X),
certain combinations of selected boards (via -DM)
when installed in certain order on the PCI bus may cause errors upon open.
(13-Jan-2003)
<P>
<LI>
Fixed Feature:
The
<A HREF="#pxd_setExsyncPrin"CLASS="Er">pxd_setExsyncPrin</A>,
<A HREF="#pxd_setExsyncPrincMode"CLASS="Er">pxd_setExsyncPrincMode</A>
and related functions were not enabled for use with the
PIXCI&reg; CL3SD.
(31-Jan-2003)
<P>
<LI>
Fixed Feature:
For the SILICON VIDEO&reg; 2112(C) when used in Controlled mode,
the maximum frame rate allowed such as via
<A HREF="#pxd_SV2112_setCtrlExposureAndRate"CLASS="Er">pxd_SV2112_setCtrlExposureAndRate</A>
has been corrected (increased).
(04-Feb-2003).
<P>
<LI>
Fixed Feature:
Driver installation under Windows XP has been improved,
eliminating the problem under some PC configurations
whereby the initial Plug&amp;Play installation run's
''forever'',
requiring a reboot and a second installation.
(20-Feb-2003).
<P>
<LI>
Added Feature:
Functions
<A HREF="#pxd_SV1310_setExposureGainOffset"CLASS="Er">pxd_SV1310_setExposureGainOffset</A>,
<A HREF="#pxd_SV1310_setResolutionAndTiming"CLASS="Er">pxd_SV1310_setResolutionAndTiming</A>
and other related functions provide camera specific controls
for the SILICON VIDEO&reg; 1310 and 1310C cameras.
(28-Feb-2003)
<P>
<LI>
Improved Feature:
The
<A HREF="#pxd_SV2112"CLASS="Er">pxd_SV2112</A>
functions, and especially the
<A HREF="#pxd_SV2112_get"CLASS="Er">pxd_SV2112_get</A>
functions,
have been improved and are now faster
by virtue of caching the camera's state rather than
having to re-read the information from the camera.
(05-Mar-2003).
<P>
<LI>
Fixed Feature:
When the PIXCI&reg; D2X, D3X, or CL1 is used in (video) triggered
mode combined with pxd_goLive, the first triggered image is
now captured, rather than capture starting with the second
triggered image.
(05-Apr-2003).
<P>
<LI>
Fixed Feature:
The
<EM CLASS="Ep">subsample</EM>
parameter to the new
<A HREF="#pxd_SV1310_setResolutionAndTiming"CLASS="Er">pxd_SV1310_setResolutionAndTiming</A>
function had the horizontal and vertical subsampling components exchanged.
Thus
<EM CLASS="Ep">subsample</EM>=0x0402
would have implemented horizontal subsampling by a factor of two
and vertical subsampling by a factor of four, rather than the documented
horizontal subsampling by a factor of four
and vertical subsampling by a factor of two.
(11-Apr-2003).
<P>
<LI>
Improved Feature:
For the SILICON VIDEO&reg; 1310 camera,
the frame rate can now be increased by using subsampling
and/or using a smaller AOI.
Previously, only a smaller AOI would increase the frame rate.
(11-Apr-2003)
<P>
<LI>
Fixed Feature:
Using a
''struct pximage3''
with operations that read or write across
image boundaries with a single read or write,
the result may be incorrect.
The only known library function that this affected
is
<CITE CLASS="Ec">pxio8_binreadseq</CITE>.
(11-Jun-2003)
<P>
<LI>
Added Feature:
A new example program,
<CODE CLASS="Em">xclibex5.cpp</CODE>,
demonstrates use of non pxd_
functions to operate two
imaging boards at different resolutions.
(06-Jun-2003)
<P>
<LI>
Fixed Feature:
For the PIXCI&reg; CL3SD, under Windows 2000, XP,
the improved driver installation file,
<CODE CLASS="Em">epixxcw2.inf</CODE>,
set
<BLOCKQUOTE>
<PRE>
    PIXCI= ... -WT -0x20
</PRE>
</BLOCKQUOTE>
to activate high resolution timestamps.
The superfluous
''-''
causes software to believe the board has 4 Gbytes
of memory, regardless of the amount of memory actually installed.
(27-Jun-2003).
<P>
<LI>
Fixed Feature:
The
<EM CLASS="Ep">pximage</EM>'s
optional PXUNIT* constants
(which describe the image's real-world dimensional units)
have been corrected;
the old values did not fit within the
<EM CLASS="Ep">uchar</EM>
fields provided, namely
<EM CLASS="Ep">widthunits</EM>,
<EM CLASS="Ep">heightunits</EM>,
and
<EM CLASS="Ep">depthunits</EM>.
(13-Jul-2003)
<P>
<LI>
Added Feature:
The
<A HREF="#pxd_goSnapPair"CLASS="Er">pxd_goSnapPair</A>
has been added as an SCF version of
<A HREF="#::setSnapPairBuf"CLASS="Er">::setSnapPairBuf</A>;
both intended for use with cameras that
output two images with a single trigger.
(29-Jul-2003)
<P>
<LI>
Added Feature:
The
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
allows initiating or terminating sequence capture in
response to a general purpose input or trigger,
with less latency than possible with previously available techniques.
(03-Aug-2003)
<P>
<LI>
Fixed Feature:
For
PIXCI&reg; D, D24, D32, D2X, and D3X imaging boards, the
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
and
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
optional parameters
<EM CLASS="Ep">delay60</EM>
and
<EM CLASS="Ep">delay70</EM>
would implement the stated delay plus 1, rather than
the stated delay.
These functions are rarely used with those imaging
boards, as they are only used with cameras
that don't implement triggering within the camera.
(07-Aug-2003).
<P>
<LI>
Modified Feature:
Due to lack of apparent interest, the
static link libraries for Windows
are no longer distributed with XCLIB and
XCLIB-IPL.
(19-Aug-2003).
<P>
<LI>
Improved Feature:
XCLIB now performs a power-up initialization
for SILICON VIDEO&reg; 2112 and 1310 cameras
upon calling pxd_PIXCIopen.
Previously, the cameras were initialized only by PC power-up.
(12-Sep-2003)
<P>
<LI>
Fixed Feature:
Under Windows NT, 2000, and XP,
when using multiple instances of XCLIB
(via multiple calls to
<A HREF="#xclib_open"CLASS="Er">xclib_open</A>),
the
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>,
<A HREF="#pxd_eventFieldClose"CLASS="Er">pxd_eventFieldClose</A>,
and
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
could not be used in more than one instance.
(13-Sep-2003).
<P>
<LI>
Added Feature:
Functions
<A HREF="#pxd_SV1281_setExposureGainOffset"CLASS="Er">pxd_SV1281_setExposureGainOffset</A>,
<A HREF="#pxd_SV1281_setResolutionAndTiming"CLASS="Er">pxd_SV1281_setResolutionAndTiming</A>
and other related functions provide camera specific controls
for the SILICON VIDEO&reg; 1281 and 1281C cameras.
(16-Sep-2003).
<P>
<LI>
Fixed Feature:
On some PC's, the SILICON VIDEO&reg; 1310(C)
would not initialize properly after power up,
outputting a grey image, unless either
(a)&nbsp;XCAP was run, or
(b)&nbsp;The XCLIB application was run twice.
(29-Sep-2003).
<P>
<LI>
Improved Feature:
The PIXCI&reg; SV5A is now supported distinct from
PIXCI&reg; SV5; the default SV5A video setup is
NTSC, not the SV5's NTSC/YC.
(30-Sep-2003).
<P>
<LI>
Improved Feature:
For all currently supported Uniq, Basler, Hitachi, and Cohu
CameraLink cameras and the Jai CV-M4+CL/CV-M7+CL CameraLink cameras
video setup files saved by
XCAP now include the serial commands needed to restore
the camera to the operating mode as set in XCAP.
XCLIB now loads those serial commands during
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>,
eliminating having to follow the instructions in the
<CITE CLASS="Ec">Using a Serial (RS-232) Configurable Camera with the PIXCI(R) D, D24, D32, D2X, D3X, CL1, or CL3SD</CITE>
application note.
The same improvement has always been provided for
Silicon Imaging and Redlake ES-1020 cameras, but not explicitly noted.
(27-Oct-2003).
<P>
<LI>
Improved Feature:
Under Linux, the
''Use Polling Rather than Interrupts (-QU)''
option is now available.
(12-Nov-2003).
<P>
<LI>
Fixed Feature:
Under Linux, closing the library may cause the
wrong (library internal) file
''handle''
to the driver to be closed, adversely affecting any file or device opened after XCLIB.
Under Linux, the
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>
does not work properly.
(09-Dec-2003).
<P>
<LI>
Added Feature:
Functions
<A HREF="#pxd_definePximage"CLASS="Er">pxd_definePximage</A>
and
<A HREF="#pxd_definePximage3"CLASS="Er">pxd_definePximage3</A>
and similar to the existing
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
and
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>,
but more convenient in multi-threaded
and a few other, rare, applications.
(06-Jan-2004)
<P>
<LI>
Fixed Feature:
Under Linux, on some motherboards,
interrupts, and thus notification about end-of-capture,
may not work properly.
(14-Jan-2004)
<P>
<LI>
Added Feature:
A new example program,
<CODE CLASS="Em">XCLIBEX6.TXT</CODE>,
illustrates use of XCLIB with VB.NET.
(16-Jan-2004).
<P>
<LI>
Added Feature:
New functions
<A HREF="#pxd_saveRawBuffers"CLASS="Er">pxd_saveRawBuffers</A>
and
<A HREF="#pxd_loadRawBuffers"CLASS="Er">pxd_loadRawBuffers</A>
have been added as an SCF version of
<A HREF="#::bufferLoadStream"CLASS="Er">::bufferLoadStream</A>
and
<A HREF="#::bufferSaveStream"CLASS="Er">::bufferSaveStream</A>.
(02-Feb-2004)
<P>
<LI>
Fixed Feature:
When using XCLIBEXC.CPP and a SILICON VIDEO&reg; 1310(C) with
a video setup file saved by XCAP which sets a small
capture AOI, the captured image is garbled
as the camera is set to one resolution while the
SILICON VIDEO&reg; 1310(C) specific functions invoked by
XCLIBEXC.CPP set the PIXCI&reg; imaging board to a different
resolution.
(The same video setup file works correctly in XCLIBEX2.CPP
which does not make use of SILICON VIDEO&reg; 1310(C) specific functions).
(31-Mar-2004).
<P>
<LI>
Improved Feature:
New function
<A HREF="#pxd_mesgFaultText"CLASS="Er">pxd_mesgFaultText</A>
allows obtaining the text describing a fault
from a SCF style function, avoiding
<A HREF="#pxd_mesgFault"CLASS="Er">pxd_mesgFault</A>'s
implied creation of a message box.
(12-Apr-2004).
<P>
<LI>
Fixed Feature:
For Camera Link cameras where a previously saved video setup
file contains serial commands with which to initialize the camera, XCLIB's
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
may fail with a
''timeout''
error.
The problem is most likely to occur under Linux, but might occur under
other operating systems.
(30-Apr-2004).
<P>
<LI>
Improved Feature:
The XCLIB release now includes the full XCLIB C/C++ Reference Manual
in HTML format.
(07-May-2004).
<P>
<LI>
Fixed Feature:
For rare combinations of frame buffer sizes versus frame buffer memory
allocation parameters, the per-buffer capture information
reported by
<A HREF="#pxd_buffersFieldCount"CLASS="Er">pxd_buffersFieldCount</A>,
<A HREF="#pxd_buffersSysTicks"CLASS="Er">pxd_buffersSysTicks</A>,
and
<A HREF="#pxd_buffersGPIn"CLASS="Er">pxd_buffersGPIn</A>
may be destroyed by capturing into the last, or last few, frame buffers.
(11-May-2004).
<P>
<LI>
Fixed Feature:
For the SILICON VIDEO&reg; 1281 and 1281C cameras, in some combinations
of AOI, pixel clock and other parameters, too large a value of
exposure is allowed, causing the captured image to be extremely dark
or extremely bright.
Also, under Visual Basic or Delphi a divide by zero error may occur
when the camera was not previously used by a
''C''
application or XCAP.
(27-May-2004).
<P>
<LI>
Fixed Feature:
For SILICON VIDEO&reg; 1281 and 1281C cameras, the maximum exposure
as a function of other parameters, and some internal
''tweaks''
governing timing was not consistent with XCAP.
(17-Jun-2004).
<P>
<LI>
Improved Feature:
For all currently supported DVC CameraLink cameras
video setup files saved by
XCAP now include the serial commands needed to restore
the camera to the operating mode as set in XCAP.
See entry for 27-Oct-2003 for additional information.
(11-Aug-2004).
<P>
<LI>
Added Feature:
Supports the SILICON VIDEO&reg; 9M001 and 9M001C
cameras, including utilizing video setup files saved by
XCAP to restore the camera state.
But does not yet have camera specific API functions.
(19-Sep-2004).
<P>
<LI>
Added Feature:
Access to color pixel values now supports CMY (cyan, magenta, yellow)
color space.
(21-Sep-2004).
<P>
<LI>
Corrected.
Documentation for
<A HREF="#pxd_loadBmp"CLASS="Er">pxd_loadBmp</A>
and
<A HREF="#pxd_loadTiff"CLASS="Er">pxd_loadTiff</A>
has been corrected to describe the existing 0x100 option to
<EM CLASS="Ep">loadmode</EM>.
(25-Oct-2004).
<P>
<LI>
Added Feature:
Functions
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>,
<A HREF="#pxd_SV9M001_setResolutionAndTiming"CLASS="Er">pxd_SV9M001_setResolutionAndTiming</A>
and other related functions provide camera specific controls
for the SILICON VIDEO&reg; 9M001 and 9M001C cameras.
(25-Oct-2004).
<P>
<LI>
Improved Feature:
XCLIB now recognizes and supports Windows Server 2003.
(29-Nov-2004)
<P>
<LI>
Fixed Feature:
For the SILICON VIDEO&reg; 1281 and 1281C cameras and when using a
video setup file in non-free run mode.
The call to the first
<CITE CLASS="Ec">pxd_SV1281_*()</CITE>
function may change the video setup.
Previous workaround was to call
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
after the
<CITE CLASS="Ec">pxd_SV1281_*()</CITE>
function.
(09-Dec-2004)
<P>
<LI>
Fixed Feature:
For SILICON VIDEO&reg; and other cameras configured for
per-pixel offset and gain corrections, when
a)&nbsp;Using forceful memory allocation,
b)&nbsp;Driver configuration parameter -MB non-zero,
and
c)&nbsp;Frame buffer mmeory mapped into application space,
the per-pixel corrections may not be applied correctly.
(22-Dec-2004)
<P>
<LI>
Improved Documentation:
For the
<CITE CLASS="Ec">pxd_SV2112_</CITE>,
<CITE CLASS="Ec">pxd_SV1310_</CITE>,
<CITE CLASS="Ec">pxd_SV1281_</CITE>,
and
<CITE CLASS="Ec">pxd_SV9M001_</CITE>
functions, documentation now notes that
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
performs partial, quick initialization of XCLIB;
initialization for these camera
functions is delayed until the first such function is called.
Time sensitive applications should call
any of these camera functions once
before entering the application's time critical phase.
(23-Dec-2004)
<P>
<LI>
Fixed Feature:
Use of clserPIXCI.DLL (the stand-alone Camera Link API) failed under Windows 95, 98
if the PIXCI&reg; was not previously opened by XCLIB or XCAP.
(06-Jan-2005)
<P>
<LI>
Added Feature:
Functions
<A HREF="#pxd_SV9M001_setExposureAndGain"CLASS="Er">pxd_SV9M001_setExposureAndGain</A>,
<A HREF="#pxd_SV9M001_setResolutionAndTiming"CLASS="Er">pxd_SV9M001_setResolutionAndTiming</A>
and other related functions provide camera specific controls
for the SILICON VIDEO&reg; 9T001C camera.
(27-Feb-2005).
<P>
<LI>
Improved Feature:
The clserPIXCI.DLL (the stand-alone Camera Link API) has been renamed to
clserEPX.dll, and is now compliant with the Camera Link V1.1 specification.
(12-May-2005).
<P>
<LI>
Improved Feature:
The
<A HREF="#pxd_xclibEscape"CLASS="Er">pxd_xclibEscape</A>
now returns NULL if the library is not open.
(12-May-2005)
<P>
<LI>
Fixed Feature:
The Linux version of the PIXCI&reg; driver did not work
with the (very) old PIXCI&reg; SV2 and SV3 imaging boards.
(25-Jun-2005)
<P>
<LI>
Fixed Feature:
In beta releases of XCLIB w. support for the PIXCI&reg; CL2,
the
<A HREF="#pxd_serialConfigure"CLASS="Er">pxd_serialConfigure</A>
would ONLY work with the CL2, not the older CL1, CL3SD, etc.
(27-Jun-2005).
<P>
<LI>
Improved Feature:
The data rate of the I<SUB><SMALL>2</SMALL></SUB>C or two wire serial bus
used to control SILICON VIDEO&reg; camera heads can now be
increased via the
''-I2C''
<A HREF="#Device Configuration Parameters"CLASS="Er">Device Configuration Parameters</A>
so as to allow faster control of gain and other camera head features
when used with shorter cables.
This feature is particularly useful with 9T001C cameras,
whose camera head's control involves more I<SUB><SMALL>2</SMALL></SUB>C or two wire serial bus
activity than other SILICON VIDEO&reg; camera heads.
(04-Aug-2005).
<P>
<LI>
Added Feature:
Now supports Linix 2.6.x kernels.
(03-Oct-2005).
<P>
<LI>
Added Feature:
Supports the SILICON VIDEO&reg; 642M and 642C
cameras, including utilizing video setup files saved by
XCAP to restore the camera state.
Functions
<A HREF="#pxd_SV640_setExposureAndGain"CLASS="Er">pxd_SV640_setExposureAndGain</A>,
<A HREF="#pxd_SV640_setResolutionAndTiming"CLASS="Er">pxd_SV640_setResolutionAndTiming</A>
and other related functions provide camera specific controls
for the SILICON VIDEO&reg; 642M and 642C cameras.
(23-Nov-2005).
<P>
<LI>
Fixed Feature:
The pxd_readuchar and pxd_readushort functions,
when used to read an AOI of the image
with one function call,
under some memory configurations
may return incorrect pixel data.
(22-Dec-2005).
.&quot; .LI
.&quot; API Tweak:
.&quot; The
.&quot; .Eq cnt
.&quot; parameter of
.&quot; .Er ::imageReadUChar ,
.&quot; .Er ::imageWriteUChar ,
.&quot; .Er ::imageReadUShort ,
.&quot; .Er ::imageWriteUShort ,
.&quot; .Er ::imageReadUInt ,
.&quot; and
.&quot; .Er ::imageWriteUInt
.&quot; has beenb tweaked from
.&quot; .Eq int
.&quot; to
.&quot; .Eq size_t .
.&quot; This has no effect on (current) 32 bit applications.
.&quot; (18-Jan-2006).
<P>
<LI>
Modified Feature:
The file name of 32 bit Linux drivers has been changed from
<CODE CLASS="Em">pixcii86.o</CODE>
or
<CODE CLASS="Em">pixcii86.ko</CODE>
to
<CODE CLASS="Em">pixci_i386.o</CODE>
or
<CODE CLASS="Em">pixci_i386.ko</CODE>.
This will avoid confusion with new 64 bit Linux drivers, to be named
<CODE CLASS="Em">pixci_x86_64.ko</CODE>.
Similarly, the file names of 32 bit Linux drivers has changed from
<CODE CLASS="Em">xclibi86.a</CODE>
and
<CODE CLASS="Em">pxipli86.a</CODE>
to
<CODE CLASS="Em">xclib_i386.a</CODE>
and
<CODE CLASS="Em">pxipl_i386.a</CODE>
(The
<CODE CLASS="Em">i386</CODE>
or
<CODE CLASS="Em">x86_64</CODE>
file name components are consistent with
''uname -i'').
(30-Jan-2006).
<P>
<LI>
Improved Feature:
XCLIB now supports the PIXCI&reg; CL1 Rev. 3.
An older XCLIB used with a PIXCI&reg; CL1 Rev. 3
is not be able to correctly program the Camera Link
serial baud rate.
(07-Feb-2006)
<P>
<LI>
Improved Feature:
XCLIB now supports the PIXCI&reg; E1,
PCI Express imaging board.
(20-Feb-2006)
<P>
<LI>
Modified Feature:
High resolution time stamping for Windows NT, 2000, XP
is now the default for all PIXCI&reg; imaging boards.
Previously it was the default only for the PIXCI&reg; CL3SD.
(07-Apr-2006)
</OL>
<BR>
<BR>
<BR>
<B CLASS="Hv">RELEASE NOTES: XCLIB  &mdash; Version 2.1</B>
<OL TYPE="1">
<P>
<LI>
This release supports the PIXCI&reg;&nbsp;SV2, SV3, SV4, D, D24, D32, and A models,
in Watcom+Tenberry extended 32 bit DOS, and Windows 95/98/NT/2000 environments.
Though not documented, the 95/98 driver and library also works in Windows ME.
(28-Aug-2000).
<P>
<LI>
Added feature:
An additional forceful memory allocation method added for Windows ME
using the -IA driver configuration parameter in similar manner as for Windows NT.
(01-Sep-2000).
<P>
<LI>
Fixed feature:
The default format (pixels per clock) for the Pulnix TMC-9700 is incorrect.
(04-Sep-2000)
<P>
<LI>
Fixed feature:
Using
<A HREF="#pxd_getGPOut"CLASS="Er">pxd_getGPOut</A>
or its non-SCF counterpart
with a PIXCI&reg;&nbsp;D, D24, D32, or A
and certain Kodak 10 bit cameras may cause
loss of the 2 least significant bits.
(7-Sep-2000).
<P>
<LI>
Fixed documentation:
Documentation for
<A HREF="#pxd_renderDirectVideoInit"CLASS="Er">pxd_renderDirectVideoInit</A>,
<A HREF="#pxd_renderDirectVideoDone"CLASS="Er">pxd_renderDirectVideoDone</A>,
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>,
and
<A HREF="#pxd_renderDirectVideoUnLive"CLASS="Er">pxd_renderDirectVideoUnLive</A>
showed these functions as being named
<A HREF="#pxd_DirectVideoInit"CLASS="Er">pxd_DirectVideoInit</A>,
<A HREF="#pxd_DirectVideoDone"CLASS="Er">pxd_DirectVideoDone</A>,
<A HREF="#pxd_DirectVideoLive"CLASS="Er">pxd_DirectVideoLive</A>,
and
<A HREF="#pxd_DirectVideoUnLive"CLASS="Er">pxd_DirectVideoUnLive</A>.
The library and .h files are not affected.
(15-Sep-2000).
<P>
<LI>
Fixed feature:
The default format for the Dalsa CA-D4
was incorrectly set as if for a line scan camera.
(19-Sep-2000).
<P>
<LI>
Fixed documentation:
The documentation for
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>
also referred to a
''pxd_goSnapSeq''
function; the
''pxd_goSnapSeq''
was a typographical error
and should have been
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>.
(28-Sep-2000).
<P>
<LI>
Added feature:
Support for using interlace cameras with the
PIXCI&reg;&nbsp;D, D24, D32 added with support
for snap, live, and sequence capture.
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
does not yet support interlace modes.
(29-Sep-2000)
<P>
<LI>
Fixed release:
Versions of XCLIB for Windows NT w/out PXIPL
did not included the EPIXXCWT.SYS driver
and related files.
These files can be obtained from the XCAP release.
(03-Nov-2000)
<P>
<LI>
Added feature:
XCLIB now supports the PIXCI&reg;&nbsp;D2X
series of imaging boards.
(06-Nov-2000)
<P>
<LI>
Fixed documentation:
The documentation for the reserved
<EM CLASS="Ep">period</EM>
parameter of
<A HREF="#::setLivePairBuf"CLASS="Er">::setLivePairBuf</A>
specified that its value should be 0.
The value should be 1.
(09-Nov-2000).
<P>
<LI>
Added feature:
The
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>,
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>,
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_readushort"CLASS="Er">pxd_readushort</A>,
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>,
and
<A HREF="#pxd_writeushort"CLASS="Er">pxd_writeushort</A>
now accept
''GRAY''
and
''Gray''
as a synonyms for
''Grey'',
and now accept
''Bayer''
for use in conjunction with cameras
that actually output raw Bayer pattern values, and where the
library would otherwise be responsible for
converting the values to RGB(x) or BGR(x).
(22-Dec-2000).
<P>
<LI>
Modified feature:
For Bayer output cameras, the
''Default''
pixel format is now BGR rather than RGB,
for better display performance when
''Default''
is requested.
(Does not affect code that explicitly requested
BGR format).
(01-Jan-2001).
<P>
<LI>
Fixed feature:
A Driver Configuration Parameter of
''-XM''=0
(a non-default value)
did not work properly with multiple boards installed.
<P>
With multiple boards, one of which having a configuration error
while others are selected for actual use, may result in a spurious
''Can't allocate frame buffer memory''
error.
(02-Jan-2001).
<P>
<LI>
Fixed Feature:
The
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
did not accept a
<EM CLASS="Ep">colorspace</EM>
of
''Default''
(the
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
was not affected).
(13-Jan-2001).
<P>
<LI>
Fixed Feature:
The
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
and
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
area of interest selection may or may not
have the correct effect, depending upon the function
with which the
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
or
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
result is used (a new bug only in previous release).
(13-Jan-2001).
<P>
<LI>
Added Feature:
The
<A HREF="#pxd_defineImage"CLASS="Er">pxd_defineImage</A>
and
<A HREF="#pxd_defineImage3"CLASS="Er">pxd_defineImage3</A>
now accept a
<EM CLASS="Ep">colorspace</EM>
of
''Display'',
which provides the most efficient color space
for display of the frame buffer through
<CITE CLASS="Ec">pxio8_GDIDisplay</CITE>
or similar functions.
(13-Jan-2001).
<P>
<LI>
Fixed Feature:
Using forceful memory allocation under Windows NT, Windows 2000, or DOS
with a PIXCI&reg; SV4 would result in unpredictable
behavior the second time (since booting) that the board is opened.
(16-Jan-2001).
<P>
<LI>
Fixed Feature:
Calling
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>
or
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>
while a previous
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>
or
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>
was in operation did not alter the
<EM CLASS="Ep">numbuf</EM>
setting .
(17-Jan-2001)
<P>
<LI>
Added Feature:
XCLIB now supports the two G.P In and two G.P Out bits
for the PIXCI&reg;&nbsp;D2X
series of imaging boards.
(24-Jan-2001).
<P>
<LI>
Fixed Feature:
For PIXCI&reg; SV4 imaging boards in
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>
mode, a
<A HREF="#::getLiveStatus"CLASS="Er">::getLiveStatus</A>
using
<EM CLASS="Ep">PXVIST_RUNNING</EM>
always returned 0.
(31-Jan-2001).
<P>
<LI>
Added Feature:
The
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
and
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
allow the application to be signalled
via a Windows event at the start of each field,
and/or at the end of each captured field.
Under Tenberry+DOS,
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
and
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
allow specifying a
''callback''
function to be invoked
at the start of each field,
and/or at the end of each captured field.
(06-Feb-2001).
<P>
<LI>
Improved Feature:
A new EPIXXCW2.SYS driver for Windows 2000
provides better compatibility with newer motherboards.
In particular, it resolves a problem with motherboards
using early 800 series chipsets, which would not provide
interrupts.
The older EPIXXCWT.SYS driver for Windows NT
may still be used under Windows 2000 on all previously supported
motherboards.
(20-Feb-2001).
<P>
<LI>
Fixed feature:
The default format for the SMD 4M15 was incorrect.
(27-Mar-2001).
<P>
<LI>
Added Feature:
New function
<A HREF="#pxd_setExsyncPrincMode"CLASS="Er">pxd_setExsyncPrincMode</A>,
<A HREF="#pxd_getExsyncMode"CLASS="Er">pxd_getExsyncMode</A>,
and
<A HREF="#pxd_getPrincMode"CLASS="Er">pxd_getPrincMode</A>
allow setting camera configuration bits,
but not suggested for
use in favor of loading a new video configuration format.
<P>
New service
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>
allows configuring XCLIB as per a
video configuration format
that has been compiled into the application, and
without re-opening XCLIB.
(01-Apr-2001).
<P>
<LI>
Fixed Feature:
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
used with a PIXCI&reg; SV4 imaging board
did not always set the
''gpout60value''
or
''gpout80value''
correctly.
(08-May-2001)
<P>
<LI>
Added Feature:
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
is now supported for the
PIXCI&reg; D2X imaging boards.
(09-May-2001).
<P>
<LI>
Added feature:
XCLIB now supports the PIXCI&reg;&nbsp;CL1
series of imaging boards for Camera Link cameras.
New functions
<A HREF="#pxd_serialConfigure"CLASS="Er">pxd_serialConfigure</A>,
<A HREF="#pxd_serialRead"CLASS="Er">pxd_serialRead</A>,
and
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
support reading and writing data through the
PIXCI&reg;&nbsp;CL1.
(15-May-2001).
<P>
<LI>
Fixed feature:
Under Windows NT and 2000, the event created by
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>
and
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
is initially signalled; thus the first
<CITE CLASS="Ec">WaitForSingleObject</CITE>
would always return immediately.
For PIXCI&reg; D2X imaging boards, the event created by
<A HREF="#pxd_eventCapturedFieldCreate"CLASS="Er">pxd_eventCapturedFieldCreate</A>
behaved the same as an event created by
<A HREF="#pxd_eventFieldCreate"CLASS="Er">pxd_eventFieldCreate</A>.
(18-May-2001).
<P>
<LI>
Added Feature:
The XCLIB now supports the PIXCI&reg;&nbsp;SV5 imaging board.
(29-May-2001).
<P>
<LI>
Fixed Feature:
Under Windows 2000, the PIXCI&reg;&nbsp;SV5 would appear
as two devices, (1)&nbsp;The SV5, and (2)&nbsp;A
''can't identify imaging board model''.
(18-Jun-2001).
<P>
<LI>
Added Feature:
The XCLIB now support opening multiple, simultaneous, instances of the library;
allowing use of multiple, non-identical, PIXCI&reg; imaging boards.
The multiple instances must be opened from the same process,
with multi-thread synchronization provided by the application program.
(01-Jul-2001).
<P>
<LI>
Fixed Feature:
The new
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
did not function correctly.
(03-Jul-2001).
<P>
<LI>
Modified feature:
For PIXCI&reg; SV2, SV3, SV4, and SV5, for PAL and CCIR,
the default video setup has been changed to avoid capturing black
lines at the top of the image.
(06-Jul-2001).
<P>
<LI>
Fixed Feature:
When using Forceful Memory allocation under Windows NT or 2000,
the frame buffer memory would not be cleared when Windows booted.
Rather, the memory, or a portion of the memory,
would be cleared each time the library/driver was opened.
(18-Jul-2001).
<P>
<LI>
Fixed Feature:
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
did not work with the PIXCI&reg; D2X,
causing program or PC hang-ups.
(20-Jul-2001).
<P>
<LI>
Modified feature:
The size of the serial data buffers for
<A HREF="#pxd_serialRead"CLASS="Er">pxd_serialRead</A>
and
<A HREF="#pxd_serialWrite"CLASS="Er">pxd_serialWrite</A>
have been increased from 32 bytes to 1024 bytes.
(28-Jul-2001).
<P>
<LI>
Fixed Feature:
For PIXCI&reg; D, D24, D32, D2X, or CL1,
specifying video resolution
''setmaxdatsamples''
or
''setmaxvidsamples''
with insufficient frame buffer memory to achieve maximum resolution
would (correctly) cause the
''setmax...samples''
to be overridden and a less than maximum resolution to be used.
However, the X &amp; Y resolution used, trading X resolution for Y resolution,
would not be consistent.
(05-Aug-2001).
<P>
<LI>
Fixed Feature:
Trying to open a imaging board while already in use
by an earlier application
correctly produced an error, but incorrectly
closed the imaging board and deprived the earlier application
of its use.
(13-Aug-2001).
<P>
<LI>
Fixed Feature:
Support for opening multiple, non-identical, PIXCI&reg; imaging boards
was not fully included in Windows NT/2000 versions.
(17-Aug-2001).
<P>
<LI>
Added Feature:
New functions
<A HREF="#pxd_buffersFieldCount"CLASS="Er">pxd_buffersFieldCount</A>
<A HREF="#pxd_buffersGPIn"CLASS="Er">pxd_buffersGPIn</A>
<A HREF="#pxd_buffersSysTicks"CLASS="Er">pxd_buffersSysTicks</A>
provide the time and value of the general purpose
inputs for each captured buffer.
(16-Sep-2001).
<P>
<LI>
Added Feature:
New function
<A HREF="#pxd_goLiveTrig"CLASS="Er">pxd_goLiveTrig</A>
allows using
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
within the SCF functions.
(25-Sep-2001).
<P>
<LI>
Fixed Feature:
The
<A HREF="#::setLiveTrigBuf"CLASS="Er">::setLiveTrigBuf</A>
did not work with the PIXCI&reg; D2X,
causing the
''wait for g.p. input''
to never be satisfied.
(05-Oct-2001).
<P>
<LI>
Fixed Feature:
The
<EM CLASS="Ep">colorspace</EM>
parameter of
<A HREF="#pxd_readuchar"CLASS="Er">pxd_readuchar</A>,
<A HREF="#pxd_writeuchar"CLASS="Er">pxd_writeuchar</A>
and similar functions is documented as allowing
a selection of
''YCrCb'',
''YofYCrCb'',
''RofYCrCb'',
and
''BofYCrCb'',
but the library instead required
''YCRCB'',
''YofYCRCB'',
''RofYCRCB'',
and
''BofYCRCB''.
Either
''YCRCB''
or
''YCrCb'',
and their variants,
are now allowed.
(05-Oct-2001)
<P>
<LI>
Fixed Feature:
The
<A HREF="#::importStateCopy"CLASS="Er">::importStateCopy</A>
and
<A HREF="#::exportStateCopy"CLASS="Er">::exportStateCopy</A>,
and the third parameter of
<A HREF="#pxd_PIXCIopen"CLASS="Er">pxd_PIXCIopen</A>
did not always work properly under Watcom+Tenberry.
(24-Oct-2001).
<P>
<LI>
Modified Feature:
A twelfth parameter,
<EM CLASS="Ep">trackers</EM>
has been added to
<A HREF="#::setLiveSeqBuf"CLASS="Er">::setLiveSeqBuf</A>;
existing code should simply add a final parameter of 0.
(28-Oct-2001).
<P>
<LI>
Added feature:
XCLIB now supports the PIXCI&reg;&nbsp;D3X
series of imaging boards.
(Oct-2001)
<P>
<LI>
Added Feature:
XCLIB now supports the G.P. In and G.P. Out bits
that have been added to newer released of PIXCI&reg; CL1 boards.
(12-Nov-2001).
</OL>
<BR>
<BR>
<BR>
<B CLASS="Hv">RELEASE NOTES: XCLIB  &mdash; Version 0.0 Beta</B>
<OL TYPE="1">
<P>
<LI>
Fixed Feature.
The
<EM CLASS="Ep">pxd_readuchar</EM>,
<EM CLASS="Ep">pxd_writeuchar</EM>,
<EM CLASS="Ep">pxd_readushort</EM>,
<EM CLASS="Ep">pxd_writeushort</EM>,
as well as their
<A HREF="#::imageReadUChar"CLASS="Er">::imageReadUChar</A>,
<A HREF="#::imageWriteUChar"CLASS="Er">::imageWriteUChar</A>
<A HREF="#::imageReadUShort"CLASS="Er">::imageReadUShort</A>,
<A HREF="#::imageWriteUShort"CLASS="Er">::imageWriteUShort</A>
equivalents do not work properly on an image AOI.
(27-Jun-2000).
</OL>
<HR SIZE="3">
<A NAME="Distribution Contents"CLASS="Ch"></A>
<A NAME="14.  Distribution Contents"></A>
<H1>14.  Distribution Contents</H1>
<PRE>
DISTRIBUTION KIT:
<BR>
        C/C++ Library for the PIXCI&reg; Imaging Boards
        XCLIB &amp; XCLIB-Lite - Version 2.2
<BR>
The XCLIB or XCLIB-Lite distribution contains one or more of:
<BR>
1a) EPIXXCW5.VXD        Windows 95/98/ME 32 bit driver.
    EPIXXCW5.INF        Windows 95/98/ME 32 bit driver installer.
    EPIXXC.SYS          Large image memory reservoir driver for Windows 95/98.
<BR>
1b) EPIXXCWT.SYS        Windows NT 32 bit driver (formerly also for Windows 2000).
    EPIXXCWT.INF        Windows NT 32 bit driver installer.
<BR>
1c) EPIXXCW2.SYS        Windows 2000/XP/Server2003 32 bit driver.
    EPIXXCW2.INF        Windows 2000/XP/Server2003 32 bit driver installer.
<BR>
1d) pixci_i386.o        Loadable device driver for Linux w. 2.4 32 bit kernel
                        and Intel 386 and newer processors.
<BR>
1e) pixci_i386.ko       Loadable device driver for Linux w. 2.6 32 bit kernel
                        and Intel 386 and newer processors.
<BR>
1f) pixci_x86_64.ko     Loadable device driver for Linux w. 2.6 64 bit kernel
                        and Intel ??? and newer processors.
<BR>
2a) XCLIBW95.DLL        XCLIB DLL and Import library for Windows 95/98/ME.
    XCLIBW95.LIB        (Compiler independent).
    XCLIBW95.EXP
<BR>
2b) XCLIBWNT.DLL        XCLIB DLL and Import library for Windows NT V4.0,
    XCLIBWNT.LIB        2000, XP, and Server 2003 (Compiler independent).
    XCLIBWNT.EXP
<BR>
2c) XCLYBW95.DLL        XCLIB-Lite DLL and Import library for Windows 95/98/ME.
    XCLYBW95.LIB        (Compiler independent).
    XCLYBW95.EXP
<BR>
2d) XCLYBWNT.DLL        XCLIB-Lite DLL and Import library for Windows NT V4.0,
    XCLYBWNT.LIB        2000, XP, and Server 2003 (Compiler independent).
    XCLYBWNT.EXP
<BR>
2e) XCLBW0DF.LIB        XCLIB Library, F model, for Tenberry+DOS,
                        Watcom 32 Bit C/C++ V10.0.
<BR>
2f) XCLBW1DF.LIB        XCLIB Library, F model, for Tenberry+DOS,
                        Watcom 32 Bit C/C++ V11.0.
<BR>
2g) xclib_i386.a        XCLIB Library, static link, for Linux,
                        Intel 80x86, and GNU 'C'.
<BR>
3a) xcliball.h          Master C include file for programs using XCLIB.
<BR>
3b) pxlibsv.h   cext.h             Various C include files for XCLIB.
    pxlibvs.h   cext_hp1.h         Included by inclusion of XCLIBALL.H
    xclibsc.h   cext_hp2.h
    xclibsv.h   cext_hp4.h
    xclibvs.h   cext_hps.h
    pximage.h   cext_hpe.h
    pxerrno.h
    pxlibcam.h
<BR>
4a) XCLIBEX1.C          Source of example program demonstrating capture
                        and video display on S/VGA and other features
                        under Tenberry+DOS and Windows command line.
<BR>
4b) XCLIBEX2.CPP        Source of example programs demonstrating capture
    XCLIBEX2.RC         and video display on S/VGA and other features
    XCLIBEX2.H          under Windows.
    XCLIBEX4.CPP        See comments in file(s) for compilation instructions.
    XCLIBEX4.RC
    XCLIBEX5.CPP
    XCLIBEXP.CPP
<BR>
4c) XCLIBEXC.CPP        Source of example program demonstrating
    XCLIBEXC.RC         capture, video display, and control of the
                        SILICON VIDEO&reg; 2112, 2112C, 1310, 1310C,
                        1281, 1281C, 9M001, 9M001C, and 9T001C
                        cameras under Windows.
<BR>
4d) XCLIBEX3.TXT        Source of example program for Visual Basic and VB.NET.
    XCLIBEX6.TXT        Comments in file provide usage instructions.
<BR>
4e) xclibel1.c          Source of example programs demonstrating capture,
    xclibel3.c          access to pixel data and other features
                        under Linux. See comments in file(s) for compilation
                        instructions.
<BR>
 5) CTOBAS.EXE          Utility to convert .h files into Visual Basic
                        declarations.
<BR>
 6) *.txt               One or more ASCII text files containing distribution
                        information, release notes, manual updates, etc.
<BR>
 7) xclib.htm           Complete XCLIB C/C++ Library Reference Manual, in HTML format.
<BR>
 A) XCLIB C/C++ Library Reference Manual.
                        Not included with XCLIB-Lite.
<BR>
Items 1 through 7 distributed on diskettes or CD.
Item A distributed on paper.
</PRE>
<HR SIZE="3">
<A NAME="Footnotes"></A>
<H1>15.  Footnotes</H1>
<DL>
<DT>
<A NAME="Footnote 1"></A>
[1]
<DD>
The XCLIB-Lite supports only a single imaging board
with a single functional unit.

<DT>
<A NAME="Footnote 2"></A>
[2]
<DD>
Under Watcom V10.0, there is a well known bug in the ``C'' library's
<CITE CLASS="Ec">realloc</CITE>;
the
<CITE CLASS="Ec">pxrealloc</CITE>
is defined differently, and avoids calling
<CITE CLASS="Ec">realloc</CITE>.

<DT>
<A NAME="Footnote 3"></A>
[3]
<DD>
The include file(s) attempt to automatically identify
C++ environments and thereby eliminate the need
of using
''extern'',
but the automatic detection may not work with all compilers
or all compiler options.
Inclusion of the explicit
''extern''
is recommended.

<DT>
<A NAME="Footnote 4"></A>
[4]
<DD>
The XCLIB-Lite does not provide a pointer into the actual image frame buffer.

<DT>
<A NAME="Footnote 5"></A>
[5]
<DD>
The XCLIB-Lite allows opening only a single imaging board,
but does allow selecting which of several imaging boards is
to be opened.

<DT>
<A NAME="Footnote 6"></A>
[6]
<DD>
Compatibility requires that the XCAP and XCLIB
be using the same version libraries.

<DT>
<A NAME="Footnote 7"></A>
[7]
<DD>
The XCLIB-Lite does not support the Structured Style Interface.

<DT>
<A NAME="Footnote 8"></A>
[8]
<DD>
The XCLIB-Lite does not support the
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>.

<DT>
<A NAME="Footnote 9"></A>
[9]
<DD>
Aficionados of C++ will recognize this description as a
''virtual class'',
and may think of it as such.
However, for compatibility with
''C''
programs, the
<EM CLASS="Ep">pximage</EM>
is implemented as a
structure from which member functions are called via function pointers.
Unlike typical class objects, the
<EM CLASS="Ep">pximage</EM>
may be freely copied and destroyed;
there are no class destructors.

<DT>
<A NAME="Footnote 10"></A>
[10]
<DD>
E.g. must be
''constructed'',
for C++ aficionados.

<DT>
<A NAME="Footnote 11"></A>
[11]
<DD>
Also referred to as a video setup file.

<DT>
<A NAME="Footnote 12"></A>
[12]
<DD>
The XCLIB-Lite supports only a single imaging board
with a single functional unit.

<DT>
<A NAME="Footnote 13"></A>
[13]
<DD>
The XCLIB-Lite does not provide
<A HREF="#pxd_xclibEscape"CLASS="Er">pxd_xclibEscape</A>
and
<A HREF="#pxd_xclibEscaped"CLASS="Er">pxd_xclibEscaped</A>.

<DT>
<A NAME="Footnote 14"></A>
[14]
<DD>
The time provided by the operating system is recorded
by software after the frame is captured, and provided on request.
No claim is made regarding the operating system clock's
accuracy, repeatability, or resolution,
nor the latency between the end of frame capture
and software's recording of the time.

<DT>
<A NAME="Footnote 15"></A>
[15]
<DD>
The time provided by the operating system is recorded
by software after the frame is captured, and provided on request.
No claim is made regarding the operating system clock's
accuracy, repeatability, or resolution,
nor the latency between the end of frame capture
and software's recording of the time.

<DT>
<A NAME="Footnote 16"></A>
[16]
<DD>
Obviously these functions take some non-zero
amount of time to execute.
The term
''immediately''
is used relative to video timing and events;
these functions return without waiting
for video events.

<DT>
<A NAME="Footnote 17"></A>
[17]
<DD>
For all imaging boards, triggered sequence capture
can also be implemented by the application:
Record current value of the General Purpose Input or Trigger,
wait for the value to change, and invoke
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>.
Or, record current value of the General Purpose Input or Trigger,
invoke
<A HREF="#pxd_goLiveSeq"CLASS="Er">pxd_goLiveSeq</A>,
wait for the value to change and invoke
<A HREF="#pxd_goUnLive"CLASS="Er">pxd_goUnLive</A>.
<P>
The integrated
<A HREF="#pxd_goLiveSeqTrig"CLASS="Er">pxd_goLiveSeqTrig</A>
function is particularly beneficial when used with very high speed
cameras so as to eliminate the application's
latency in responding to the General Purpose Input or Trigger.

<DT>
<A NAME="Footnote 18"></A>
[18]
<DD>
Unlike the similar
<CITE CLASS="Ec">pxd_bdim()</CITE>
of the XCOBJ library,
the number of bits in a
<U CLASS="U">single</U>
color component is returned.

<DT>
<A NAME="Footnote 19"></A>
[19]
<DD>
Unlike the similar
<CITE CLASS="Ec">pxd_ylace()</CITE>
of the XCOBJ library,
the number of fields is returned, not a boolean
as to whether the image frame buffer provides
storage for both fields.

<DT>
<A NAME="Footnote 20"></A>
[20]
<DD>
Unlike the similar
<CITE CLASS="Ec">pxd_ydim()</CITE>
of the XCOBJ library,
the number of pixels in a column including
<U CLASS="U">all</U>
fields of the frame buffer is returned.

<DT>
<A NAME="Footnote 21"></A>
[21]
<DD>
A reminder regarding file names:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<CITE CLASS="Ec">The C Programming Language</CITE>
by Kernighan &amp; Ritchie or
<CITE CLASS="Ec">The C++ Programming Language</CITE>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which current versions of DOS and Windows accept in liu of a backslash.

<DT>
<A NAME="Footnote 22"></A>
[22]
<DD>
A reminder regarding file names:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<CITE CLASS="Ec">The C Programming Language</CITE>
by Kernighan &amp; Ritchie or
<CITE CLASS="Ec">The C++ Programming Language</CITE>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which current versions of DOS and Windows accept in liu of a backslash.

<DT>
<A NAME="Footnote 23"></A>
[23]
<DD>
A reminder regarding file names:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<CITE CLASS="Ec">The C Programming Language</CITE>
by Kernighan &amp; Ritchie or
<CITE CLASS="Ec">The C++ Programming Language</CITE>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which current versions of DOS and Windows accept in liu of a backslash.

<DT>
<A NAME="Footnote 24"></A>
[24]
<DD>
The
<A HREF="#pxd_renderDirectVideoInit"CLASS="Er">pxd_renderDirectVideoInit</A>
and related functions currently support only
a single imaging board.

<DT>
<A NAME="Footnote 25"></A>
[25]
<DD>
The
<A HREF="#pxd_renderDirectVideoLive"CLASS="Er">pxd_renderDirectVideoLive</A>
and related functions currently supports only
a single imaging board.

<DT>
<A NAME="Footnote 26"></A>
[26]
<DD>
The stated use of
<EM CLASS="Ep">lrx</EM>-<EM CLASS="Ep">ulx</EM>
and
<EM CLASS="Ep">lry</EM>-<EM CLASS="Ep">uly</EM>
is not complete and precise, as it doesn't take into account the
<EM CLASS="Ep">lrx</EM>=-1
or
<EM CLASS="Ep">lry</EM>=-1
option.

<DT>
<A NAME="Footnote 27"></A>
[27]
<DD>
For monochrome images and S/VGA adapters providing 8 bits per pixel and a palette,
the rendering could be improved by using the Windows
<CITE CLASS="Ec">CreatePalette</CITE>,
<CITE CLASS="Ec">SelectPalette</CITE>,
and
<CITE CLASS="Ec">RealizePalette</CITE>
functions to define more
grey levels, at the expense of colors used elsewhere on the desktop.

<DT>
<A NAME="Footnote 28"></A>
[28]
<DD>
See the Camera Link V1.1 specification for a detailed description
of these functions' parameters.

<DT>
<A NAME="Footnote 29"></A>
[29]
<DD>
The XCLIB-Lite does not support the Structured Style Interface.

<DT>
<A NAME="Footnote 30"></A>
[30]
<DD>
A reminder regarding file names:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<CITE CLASS="Ec">The C Programming Language</CITE>
by Kernighan &amp; Ritchie or
<CITE CLASS="Ec">The C++ Programming Language</CITE>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which current versions of DOS and Windows accept in liu of a backslash.

<DT>
<A NAME="Footnote 31"></A>
[31]
<DD>
A reminder regarding file names:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<CITE CLASS="Ec">The C Programming Language</CITE>
by Kernighan &amp; Ritchie or
<CITE CLASS="Ec">The C++ Programming Language</CITE>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which current versions of DOS and Windows accept in liu of a backslash.

<DT>
<A NAME="Footnote 32"></A>
[32]
<DD>
Under Windows 95, 98, and ME, the
system time is in 1 millisecond units.
Under Windows NT, 2000, XP, and Server 2003 the
system time is in 100 nanosecond units;
if the high resolution timer option (see
<A HREF="#Driver Configuration Parameters"CLASS="Er">Driver Configuration Parameters</A>)
is used, the units are dependent upon Windows and the host computer.
Under DOS+Tenberry, the
system time is in 54.94 millisecond (i.e. 1/18.2&nbsp;Hz)
units.
Under Linux, the system time units
are dependent on the Linux version and host hardware
(i.e. the reciprocal of Linux's
''HZ'');
for common 2.4 and 2.6 kernels on a PC, the system time is in 10 millisecond units.
<P>
The time provided by the operating system is recorded
by software's response to a hardware interrupt
after the frame is captured, and provided on request.
No claim is made regarding the operating system clock's
accuracy, repeatability, or resolution,
nor the latency between the end of frame capture
and software's recording of the time.

<DT>
<A NAME="Footnote 33"></A>
[33]
<DD>
The
''CCCC''
is a common Windows macro.
For other environments use:
<BLOCKQUOTE>
<PRE>
    #define CCCC(a,b,c,d)   (((uint32)(a)&lt;&lt;24) | ((uint32)(b)&lt;&lt;16) | ((c)&lt;&lt;8) | (d))
</PRE>
</BLOCKQUOTE>

<DT>
<A NAME="Footnote 34"></A>
[34]
<DD>
A reminder regarding file names:
C/C++
interprets
any backslash
(''\'')
in a character string as a special escape character
(see
<CITE CLASS="Ec">The C Programming Language</CITE>
by Kernighan &amp; Ritchie or
<CITE CLASS="Ec">The C++ Programming Language</CITE>
by Stroustrup).
Either use two backslashes which C/C++ translates to a single backslash,
or use a forward slash
(''/''),
which current versions of DOS and Windows accept in liu of a backslash.

<DT>
<A NAME="Footnote 35"></A>
[35]
<DD>
The XCLIB-Lite does not support the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>
or the
<EM CLASS="Ep">pximage</EM>
and
<EM CLASS="Ep">pximage3</EM>
interfaces.

<DT>
<A NAME="Footnote 36"></A>
[36]
<DD>
The
<CITE CLASS="Ec">pximage_file</CITE>,
and
<CITE CLASS="Ec">pximage_memory</CITE>
are provided with the
<CITE CLASS="Ec">PXIPL Image Processing Library</CITE>.

<DT>
<A NAME="Footnote 37"></A>
[37]
<DD>
These allowed variations do not complicate the typical application program.
When reading and writing pixie values, it typically isn't necessary
to worry about left or right justification, or the following topic
of dirty and clean bits; for most
<EM CLASS="Ep">pximage</EM>
device drivers,
pixel reads/writes can produce/accept data in the form that the
application program requests/generates.
These detailed specifications allow
an application program to optionally improve
efficiency by using the data in its natural format,
rather than having the data converted.

<DT>
<A NAME="Footnote 38"></A>
[38]
<DD>
This particular
<EM CLASS="Ep">d.pixelhint</EM>
begs for an explanation.
When used with
''uchar''
pixie types, and multiple pixels read into a
''uchar''
buffer, on Intel machines with little-endian architecture
(least significant byte of multi-byte word has lowest address),
with the buffer typecast to the Windows
''COLORREF''
type, the resulting pixels are compatible with Windows' RGB() data type,
as well as many SVGA cards operating in RGB 32 bit per pixel mode.

<DT>
<A NAME="Footnote 39"></A>
[39]
<DD>
For
<A HREF="#::imap"CLASS="Er">::imap</A>,
the relative access time is not the execution time of
<A HREF="#::imap"CLASS="Er">::imap</A>
itself,
but the relative number of wait states in using the
pointer returned by
<A HREF="#::imap"CLASS="Er">::imap</A>.

<DT>
<A NAME="Footnote 40"></A>
[40]
<DD>
For example, a
<EM CLASS="Ep">pximage</EM>
(or
<EM CLASS="Ep">pximage3</EM>)
which references image buffers on a SILICON VIDEO&reg;
or a 4MEG VIDEO imaging board might provide
access only when the board is not capturing or displaying video.

<DT>
<A NAME="Footnote 41"></A>
[41]
<DD>
For example, on a
<EM CLASS="Ep">pximage</EM>
(or
<EM CLASS="Ep">pximage3</EM>)
which references image buffers on a SILICON VIDEO&reg;
or a 4MEG VIDEO imaging board, where video was off
during
<EM CLASS="Ep">::imapset</EM>
and then activated before
<EM CLASS="Ep">::imap</EM>.
The direct access pointer provided by
<EM CLASS="Ep">::imap</EM>
could even be invalidated after receipt from
<EM CLASS="Ep">::imap</EM>,
such as by activating video.
The
<EM CLASS="Ep">pximage</EM>
(or
<EM CLASS="Ep">pximage3</EM>)
provides no method of handling invalidation;
during use of the
<EM CLASS="Ep">::imap</EM>
direct access pointer,
the user must avoid using services beyond the
<EM CLASS="Ep">pximage</EM>'s
(or
<EM CLASS="Ep">pximage3</EM>'s)
domain which adversely affect the state of the underlying device.

<DT>
<A NAME="Footnote 42"></A>
[42]
<DD>
With the exception of the Silicon Imaging 3170 and 3171 cameras,
which are initialized to the manufacturer's suggested default mode
via the Camera Link serial port.

<DT>
<A NAME="Footnote 43"></A>
[43]
<DD>
Compatibility requires that the XCAP and XCLIB
are using the same version libraries.

<DT>
<A NAME="Footnote 44"></A>
[44]
<DD>
This example of programming a non-EPIX&reg; imaging product
is provided without warranties of any kind.

<DT>
<A NAME="Footnote 45"></A>
[45]
<DD>
A newer release of XCLIB and XCAP may be required.

<DT>
<A NAME="Footnote 46"></A>
[46]
<DD>
Compatibility requires that the XCAP and XCLIB
be using the same version libraries.

<DT>
<A NAME="Footnote 47"></A>
[47]
<DD>
The XCLIB-Lite does not support the
<A HREF="#pxd_videoFormatAsIncluded"CLASS="Er">pxd_videoFormatAsIncluded</A>.

<DT>
<A NAME="Footnote 48"></A>
[48]
<DD>
The requirement for a signature is intended to prevent
an imported Video Format Configuration, which contains a
<EM CLASS="Ep">pxvidphys</EM>,
from accidentally being re-used to specify a user space
or bus physical target.
Closing and re-opening the XCLIB, even within the same
application or process requires new signatures!

<DT>
<A NAME="Footnote 49"></A>
[49]
<DD>
A
''secondary surface''
is a DirectDraw term.

</DL>
<HR>
<A NAME="Index" CLASS="Ch"></A>
<H1>Index</H1>
<LI><A HREF="#::aeiou NX775"CLASS="NX">::aeiou</A>
<LI><A HREF="#::bxta NX801"CLASS="NX">::bxta</A>
<LI><A HREF="#::bxtp NX800"CLASS="NX">::bxtp</A>
<LI><A HREF="#::bxts NX799"CLASS="NX">::bxts</A>
<LI><A HREF="#::bxtw NX802"CLASS="NX">::bxtw</A>
<LI><A HREF="#::imap NX813"CLASS="NX">::imap</A>
<LI><A HREF="#::imapr NX814"CLASS="NX">::imapr</A>
<LI><A HREF="#::imapset NX812"CLASS="NX">::imapset</A>
<LI><A HREF="#::iolen NX790"CLASS="NX">::iolen</A>
<LI><A HREF="#::ioread NX787"CLASS="NX">::ioread</A>
<LI><A HREF="#::iorite NX788"CLASS="NX">::iorite</A>
<LI><A HREF="#::ioset NX786"CLASS="NX">::ioset</A>
<LI><A HREF="#::iowait NX789"CLASS="NX">::iowait</A>
<LI><A HREF="#::pxaux.bufferLoadStream NX675"CLASS="NX">::pxaux.bufferLoadStream</A>
<LI><A HREF="#::pxaux.bufferSaveStream NX677"CLASS="NX">::pxaux.bufferSaveStream</A>
<LI><A HREF="#::pxaux.errorCodeString NX679"CLASS="NX">::pxaux.errorCodeString</A>
<LI><A HREF="#::pxaux.faultMessageBox NX681"CLASS="NX">::pxaux.faultMessageBox</A>
<LI><A HREF="#::pxaux.faultPrintf NX683"CLASS="NX">::pxaux.faultPrintf</A>
<LI><A HREF="#::pxaux.freeDIB NX715"CLASS="NX">::pxaux.freeDIB</A>
<LI><A HREF="#::pxaux.imageLoadBmp NX685"CLASS="NX">::pxaux.imageLoadBmp</A>
<LI><A HREF="#::pxaux.imageLoadTiff NX687"CLASS="NX">::pxaux.imageLoadTiff</A>
<LI><A HREF="#::pxaux.imageReadUChar NX701"CLASS="NX">::pxaux.imageReadUChar</A>
<LI><A HREF="#::pxaux.imageReadUInt NX705"CLASS="NX">::pxaux.imageReadUInt</A>
<LI><A HREF="#::pxaux.imageReadUShort NX703"CLASS="NX">::pxaux.imageReadUShort</A>
<LI><A HREF="#::pxaux.imageSaveBmp NX689"CLASS="NX">::pxaux.imageSaveBmp</A>
<LI><A HREF="#::pxaux.imageSavePcx NX691"CLASS="NX">::pxaux.imageSavePcx</A>
<LI><A HREF="#::pxaux.imageSaveTga NX693"CLASS="NX">::pxaux.imageSaveTga</A>
<LI><A HREF="#::pxaux.imageSaveTiff NX695"CLASS="NX">::pxaux.imageSaveTiff</A>
<LI><A HREF="#::pxaux.imageWriteUChar NX707"CLASS="NX">::pxaux.imageWriteUChar</A>
<LI><A HREF="#::pxaux.imageWriteUInt NX711"CLASS="NX">::pxaux.imageWriteUInt</A>
<LI><A HREF="#::pxaux.imageWriteUShort NX709"CLASS="NX">::pxaux.imageWriteUShort</A>
<LI><A HREF="#::pxaux.makeDIB NX713"CLASS="NX">::pxaux.makeDIB</A>
<LI><A HREF="#::pxaux.StretchDIBits NX717"CLASS="NX">::pxaux.StretchDIBits</A>
<LI><A HREF="#::pxdev.freeImap NX621"CLASS="NX">::pxdev.freeImap</A>
<LI><A HREF="#::pxdev.getDevInfo NX581"CLASS="NX">::pxdev.getDevInfo</A>
<LI><A HREF="#::pxdev.getFault NX585"CLASS="NX">::pxdev.getFault</A>
<LI><A HREF="#::pxdev.getImap NX619"CLASS="NX">::pxdev.getImap</A>
<LI><A HREF="#::pxdev.getVidStatus NX635"CLASS="NX">::pxdev.getVidStatus</A>
<LI><A HREF="#::pxdev.getVidStatusValue NX639"CLASS="NX">::pxdev.getVidStatusValue</A>
<LI><A HREF="#::pxdev.io NX631"CLASS="NX">::pxdev.io</A>
<LI><A HREF="#::pxdev.ioctl NX673"CLASS="NX">::pxdev.ioctl</A>
<LI><A HREF="#::pxlib.allocStateCopy NX591"CLASS="NX">::pxlib.allocStateCopy</A>
<LI><A HREF="#::pxlib.compareStateCopy NX595"CLASS="NX">::pxlib.compareStateCopy</A>
<LI><A HREF="#::pxlib.defineState NX597"CLASS="NX">::pxlib.defineState</A>
<LI><A HREF="#::pxlib.deleteState NX599"CLASS="NX">::pxlib.deleteState</A>
<LI><A HREF="#::pxlib.exportStateCopy NX603"CLASS="NX">::pxlib.exportStateCopy</A>
<LI><A HREF="#::pxlib.freeStateCopy NX593"CLASS="NX">::pxlib.freeStateCopy</A>
<LI><A HREF="#::pxlib.getState NX601"CLASS="NX">::pxlib.getState</A>
<LI><A HREF="#::pxlib.goingBufStatus NX641"CLASS="NX">::pxlib.goingBufStatus</A>
<LI><A HREF="#::pxlib.importStateCopy NX605"CLASS="NX">::pxlib.importStateCopy</A>
<LI><A HREF="#::pxlib.initFilteredPximage NX627"CLASS="NX">::pxlib.initFilteredPximage</A>
<LI><A HREF="#::pxlib.initFilteredPximage3 NX629"CLASS="NX">::pxlib.initFilteredPximage3</A>
<LI><A HREF="#::pxlib.initPximage NX623"CLASS="NX">::pxlib.initPximage</A>
<LI><A HREF="#::pxlib.initPximage3 NX625"CLASS="NX">::pxlib.initPximage3</A>
<LI><A HREF="#::pxlib.initStateCopy NX613"CLASS="NX">::pxlib.initStateCopy</A>
<LI><A HREF="#::setLivePhys NX651"CLASS="NX">::setLivePhys</A>
<LI><A HREF="#::setLiveSeqBuf NX653"CLASS="NX">::setLiveSeqBuf</A>
<LI><A HREF="#::setLiveTrigBuf NX655"CLASS="NX">::setLiveTrigBuf</A>
<LI><A HREF="#::xcdev.getDevInfo NX583"CLASS="NX">::xcdev.getDevInfo</A>
<LI><A HREF="#::xcdev.getDevParms NX587"CLASS="NX">::xcdev.getDevParms</A>
<LI><A HREF="#::xcdev.getGpin NX665"CLASS="NX">::xcdev.getGpin</A>
<LI><A HREF="#::xcdev.getGpout NX671"CLASS="NX">::xcdev.getGpout</A>
<LI><A HREF="#::xcdev.getLiveStatus NX633"CLASS="NX">::xcdev.getLiveStatus</A>
<LI><A HREF="#::xcdev.getVidStatus NX637"CLASS="NX">::xcdev.getVidStatus</A>
<LI><A HREF="#::xcdev.setAbortLive NX659"CLASS="NX">::xcdev.setAbortLive</A>
<LI><A HREF="#::xcdev.setDevParms NX589"CLASS="NX">::xcdev.setDevParms</A>
<LI><A HREF="#::xcdev.setGpin NX667"CLASS="NX">::xcdev.setGpin</A>
<LI><A HREF="#::xcdev.setGpout NX669"CLASS="NX">::xcdev.setGpout</A>
<LI><A HREF="#::xcdev.setLiveBuf NX647"CLASS="NX">::xcdev.setLiveBuf</A>
<LI><A HREF="#::xcdev.setLivePairBuf NX649"CLASS="NX">::xcdev.setLivePairBuf</A>
<LI><A HREF="#::xcdev.setSnapBuf NX643"CLASS="NX">::xcdev.setSnapBuf</A>
<LI><A HREF="#::xcdev.setSnapPairBuf NX645"CLASS="NX">::xcdev.setSnapPairBuf</A>
<LI><A HREF="#::xcdev.setUnLive NX657"CLASS="NX">::xcdev.setUnLive</A>
<LI><A HREF="#::xcdev.setVideoAdjust NX663"CLASS="NX">::xcdev.setVideoAdjust</A>
<LI><A HREF="#::xcdev.setVideoConfig NX661"CLASS="NX">::xcdev.setVideoConfig</A>
<LI><A HREF="#::xclib.fillStateCopy NX609"CLASS="NX">::xclib.fillStateCopy</A>
<LI><A HREF="#::xclib.fixxStateCopy NX607"CLASS="NX">::xclib.fixxStateCopy</A>
<LI><A HREF="#::xclib.signStateCopy NX611"CLASS="NX">::xclib.signStateCopy</A>
<LI><A HREF="#::xwind NX772"CLASS="NX">::xwind</A>
<LI><A HREF="#Abort Live/Snap into Frame Buffer NX660"CLASS="NX">Abort Live/Snap into Frame Buffer</A>
<LI><A HREF="#Adjust Video Configuration NX664"CLASS="NX">Adjust Video Configuration</A>
<LI><A HREF="#Allocate Copy of Video State NX592"CLASS="NX">Allocate Copy of Video State</A>
<LI><A HREF="#BMP Format NX291"CLASS="NX">BMP Format</A>
<LI><A HREF="#BMP Format NX698"CLASS="NX">BMP Format</A>
<LI><A HREF="#Buffer's Capture Field Count NX156"CLASS="NX">Buffer's Capture Field Count</A>
<LI><A HREF="#Buffer's Capture General Purpose Input NX158"CLASS="NX">Buffer's Capture General Purpose Input</A>
<LI><A HREF="#Buffer's Capture System Time NX160"CLASS="NX">Buffer's Capture System Time</A>
<LI><A HREF="#Camera Control: SILICON VIDEO&reg; 1281 NX733"CLASS="NX">Camera Control: SILICON VIDEO&reg; 1281</A>
<LI><A HREF="#Camera Control: SILICON VIDEO&reg; 1310 NX727"CLASS="NX">Camera Control: SILICON VIDEO&reg; 1310</A>
<LI><A HREF="#Camera Control: SILICON VIDEO&reg; 2112 NX721"CLASS="NX">Camera Control: SILICON VIDEO&reg; 2112</A>
<LI><A HREF="#Camera Control: SILICON VIDEO&reg; 642 NX747"CLASS="NX">Camera Control: SILICON VIDEO&reg; 642</A>
<LI><A HREF="#Camera Control: SILICON VIDEO&reg; 9M001 NX739"CLASS="NX">Camera Control: SILICON VIDEO&reg; 9M001</A>
<LI><A HREF="#Camera Control: SILICON VIDEO&reg; 9T001 NX741"CLASS="NX">Camera Control: SILICON VIDEO&reg; 9T001</A>
<LI><A HREF="#Camera Link Serial: Close NX345"CLASS="NX">Camera Link Serial: Close</A>
<LI><A HREF="#Camera Link Serial: Error Text NX355"CLASS="NX">Camera Link Serial: Error Text</A>
<LI><A HREF="#Camera Link Serial: Get Baud Rates NX363"CLASS="NX">Camera Link Serial: Get Baud Rates</A>
<LI><A HREF="#Camera Link Serial: Initialize NX343"CLASS="NX">Camera Link Serial: Initialize</A>
<LI><A HREF="#Camera Link Serial: Manufacturer ID NX361"CLASS="NX">Camera Link Serial: Manufacturer ID</A>
<LI><A HREF="#Camera Link Serial: Ports ID NX359"CLASS="NX">Camera Link Serial: Ports ID</A>
<LI><A HREF="#Camera Link Serial: Ports NX357"CLASS="NX">Camera Link Serial: Ports</A>
<LI><A HREF="#Camera Link Serial: Read Available NX351"CLASS="NX">Camera Link Serial: Read Available</A>
<LI><A HREF="#Camera Link Serial: Read Flush NX353"CLASS="NX">Camera Link Serial: Read Flush</A>
<LI><A HREF="#Camera Link Serial: Read NX347"CLASS="NX">Camera Link Serial: Read</A>
<LI><A HREF="#Camera Link Serial: Set Baud Rate NX365"CLASS="NX">Camera Link Serial: Set Baud Rate</A>
<LI><A HREF="#Camera Link Serial: Write NX349"CLASS="NX">Camera Link Serial: Write</A>
<LI><A HREF="#Check if Video Initiated NX249"CLASS="NX">Check if Video Initiated</A>
<LI><A HREF="#clFlushPort NX352"CLASS="NX">clFlushPort</A>
<LI><A HREF="#clGetErrorText NX354"CLASS="NX">clGetErrorText</A>
<LI><A HREF="#clGetManufacturerInfo NX360"CLASS="NX">clGetManufacturerInfo</A>
<LI><A HREF="#clGetNumBytesAvail NX350"CLASS="NX">clGetNumBytesAvail</A>
<LI><A HREF="#clGetNumSerialPorts NX356"CLASS="NX">clGetNumSerialPorts</A>
<LI><A HREF="#clGetSerialPortIdentifier NX358"CLASS="NX">clGetSerialPortIdentifier</A>
<LI><A HREF="#clGetSupportedBaudRates NX362"CLASS="NX">clGetSupportedBaudRates</A>
<LI><A HREF="#clSerialClose NX344"CLASS="NX">clSerialClose</A>
<LI><A HREF="#clSerialInit NX342"CLASS="NX">clSerialInit</A>
<LI><A HREF="#clSerialRead NX346"CLASS="NX">clSerialRead</A>
<LI><A HREF="#clSerialWrite NX348"CLASS="NX">clSerialWrite</A>
<LI><A HREF="#clSetBaudRate NX364"CLASS="NX">clSetBaudRate</A>
<LI><A HREF="#Compare Pair of Video State Copies NX596"CLASS="NX">Compare Pair of Video State Copies</A>
<LI><A HREF="#Compilation NX1"CLASS="NX">Compilation</A>
<LI><A HREF="#ddch.cnt NX42"CLASS="NX">ddch.cnt</A>
<LI><A HREF="#ddch.len NX41"CLASS="NX">ddch.len</A>
<LI><A HREF="#Declare Instance of Video Format Configuration Structures NX616"CLASS="NX">Declare Instance of Video Format Configuration Structures</A>
<LI><A HREF="#Define Video State NX598"CLASS="NX">Define Video State</A>
<LI><A HREF="#Delete Video State NX600"CLASS="NX">Delete Video State</A>
<LI><A HREF="#Device Control NX674"CLASS="NX">Device Control</A>
<LI><A HREF="#DOS NX206"CLASS="NX">DOS</A>
<LI><A HREF="#DOS: Register Callback upon Captured Video Field NX199"CLASS="NX">DOS: Register Callback upon Captured Video Field</A>
<LI><A HREF="#DOS: Register Callback upon General Purpose Trigger NX203"CLASS="NX">DOS: Register Callback upon General Purpose Trigger</A>
<LI><A HREF="#DOS: Register Callback upon Video Field NX195"CLASS="NX">DOS: Register Callback upon Video Field</A>
<LI><A HREF="#DOS: Unregister Callback upon Captured Video Field NX201"CLASS="NX">DOS: Unregister Callback upon Captured Video Field</A>
<LI><A HREF="#DOS: Unregister Callback upon General Purpose Trigger NX205"CLASS="NX">DOS: Unregister Callback upon General Purpose Trigger</A>
<LI><A HREF="#DOS: Unregister Callback upon Video Field NX197"CLASS="NX">DOS: Unregister Callback upon Video Field</A>
<LI><A HREF="#Driver Configuration Parameters NX153"CLASS="NX">Driver Configuration Parameters</A>
<LI><A HREF="#EMM386 NX154"CLASS="NX">EMM386</A>
<LI><A HREF="#Errors: Check &amp; Report Faults NX301"CLASS="NX">Errors: Check &amp; Report Faults</A>
<LI><A HREF="#Errors: Check &amp; Report Faults NX303"CLASS="NX">Errors: Check &amp; Report Faults</A>
<LI><A HREF="#Errors: Check &amp; Report Faults NX682"CLASS="NX">Errors: Check &amp; Report Faults</A>
<LI><A HREF="#Errors: Check &amp; Report Faults NX684"CLASS="NX">Errors: Check &amp; Report Faults</A>
<LI><A HREF="#Errors: Translate Error Code to String NX299"CLASS="NX">Errors: Translate Error Code to String</A>
<LI><A HREF="#Errors: Translate Error Code to String NX680"CLASS="NX">Errors: Translate Error Code to String</A>
<LI><A HREF="#Export Copy of Video State NX604"CLASS="NX">Export Copy of Video State</A>
<LI><A HREF="#Fill Video State NX610"CLASS="NX">Fill Video State</A>
<LI><A HREF="#Fixup Video State NX608"CLASS="NX">Fixup Video State</A>
<LI><A HREF="#Free Copy of Video State NX594"CLASS="NX">Free Copy of Video State</A>
<LI><A HREF="#Free Pointer into Imaging Board Memory NX622"CLASS="NX">Free Pointer into Imaging Board Memory</A>
<LI><A HREF="#Functional Units NX38"CLASS="NX">Functional Units</A>
<LI><A HREF="#General Purpose Input Signal: Reset NX223"CLASS="NX">General Purpose Input Signal: Reset</A>
<LI><A HREF="#General Purpose Input Signal: Reset NX668"CLASS="NX">General Purpose Input Signal: Reset</A>
<LI><A HREF="#General Purpose Input Signal: Sense NX221"CLASS="NX">General Purpose Input Signal: Sense</A>
<LI><A HREF="#General Purpose Input Signal: Sense NX666"CLASS="NX">General Purpose Input Signal: Sense</A>
<LI><A HREF="#General Purpose Output Signal: Get NX227"CLASS="NX">General Purpose Output Signal: Get</A>
<LI><A HREF="#General Purpose Output Signal: Get NX672"CLASS="NX">General Purpose Output Signal: Get</A>
<LI><A HREF="#General Purpose Output Signal: Set NX225"CLASS="NX">General Purpose Output Signal: Set</A>
<LI><A HREF="#General Purpose Output Signal: Set NX670"CLASS="NX">General Purpose Output Signal: Set</A>
<LI><A HREF="#General Purpose Trigger Count: Sense NX229"CLASS="NX">General Purpose Trigger Count: Sense</A>
<LI><A HREF="#Get Current Buffer Status NX642"CLASS="NX">Get Current Buffer Status</A>
<LI><A HREF="#Get Current Video Status NX636"CLASS="NX">Get Current Video Status</A>
<LI><A HREF="#Get Current Video Status Value NX640"CLASS="NX">Get Current Video Status Value</A>
<LI><A HREF="#Get Driver Parameters NX588"CLASS="NX">Get Driver Parameters</A>
<LI><A HREF="#Get EXSYNC Mode NX375"CLASS="NX">Get EXSYNC Mode</A>
<LI><A HREF="#Get EXSYNC Value NX369"CLASS="NX">Get EXSYNC Value</A>
<LI><A HREF="#Get Extended Imaging Board and Driver Information NX584"CLASS="NX">Get Extended Imaging Board and Driver Information</A>
<LI><A HREF="#Get Extended Video Status NX638"CLASS="NX">Get Extended Video Status</A>
<LI><A HREF="#Get Frame Buffer Image Aspect Ratio NX251"CLASS="NX">Get Frame Buffer Image Aspect Ratio</A>
<LI><A HREF="#Get Frame Buffer Image Bit Depth NX253"CLASS="NX">Get Frame Buffer Image Bit Depth</A>
<LI><A HREF="#Get Frame Buffer Image Color Components NX255"CLASS="NX">Get Frame Buffer Image Color Components</A>
<LI><A HREF="#Get Frame Buffer Image Count NX263"CLASS="NX">Get Frame Buffer Image Count</A>
<LI><A HREF="#Get Frame Buffer Image Field Dimension NX257"CLASS="NX">Get Frame Buffer Image Field Dimension</A>
<LI><A HREF="#Get Frame Buffer Image Horizontal Dimension NX259"CLASS="NX">Get Frame Buffer Image Horizontal Dimension</A>
<LI><A HREF="#Get Frame Buffer Image Vertical Dimension NX261"CLASS="NX">Get Frame Buffer Image Vertical Dimension</A>
<LI><A HREF="#Get Imaging Board and Driver Information NX582"CLASS="NX">Get Imaging Board and Driver Information</A>
<LI><A HREF="#Get Imaging Board Driver ID NX265"CLASS="NX">Get Imaging Board Driver ID</A>
<LI><A HREF="#Get Imaging Board Include Files ID NX267"CLASS="NX">Get Imaging Board Include Files ID</A>
<LI><A HREF="#Get Imaging Board Include Files ID NX574"CLASS="NX">Get Imaging Board Include Files ID</A>
<LI><A HREF="#Get Imaging Board Library ID NX269"CLASS="NX">Get Imaging Board Library ID</A>
<LI><A HREF="#Get Imaging Board Library ID NX576"CLASS="NX">Get Imaging Board Library ID</A>
<LI><A HREF="#Get Imaging Board Unit Count NX277"CLASS="NX">Get Imaging Board Unit Count</A>
<LI><A HREF="#Get Imaging Board's Frame Buffer Size NX271"CLASS="NX">Get Imaging Board's Frame Buffer Size</A>
<LI><A HREF="#Get Imaging Board's Model NX273"CLASS="NX">Get Imaging Board's Model</A>
<LI><A HREF="#Get Imaging Board's Submodel NX275"CLASS="NX">Get Imaging Board's Submodel</A>
<LI><A HREF="#Get Live/Snap Status NX634"CLASS="NX">Get Live/Snap Status</A>
<LI><A HREF="#Get PRIN Value NX371"CLASS="NX">Get PRIN Value</A>
<LI><A HREF="#Get PRINC Mode NX377"CLASS="NX">Get PRINC Mode</A>
<LI><A HREF="#Get PXIMAGE3: Access Imaging Board Frame Buffers NX170"CLASS="NX">Get PXIMAGE3: Access Imaging Board Frame Buffers</A>
<LI><A HREF="#Get PXIMAGE3: Access Imaging Board Frame Buffers NX174"CLASS="NX">Get PXIMAGE3: Access Imaging Board Frame Buffers</A>
<LI><A HREF="#Get PXIMAGE3: Release Access to Imaging Board Frame Buffers NX178"CLASS="NX">Get PXIMAGE3: Release Access to Imaging Board Frame Buffers</A>
<LI><A HREF="#Get PXIMAGE: Access Imaging Board Frame Buffer NX168"CLASS="NX">Get PXIMAGE: Access Imaging Board Frame Buffer</A>
<LI><A HREF="#Get PXIMAGE: Access Imaging Board Frame Buffer NX172"CLASS="NX">Get PXIMAGE: Access Imaging Board Frame Buffer</A>
<LI><A HREF="#Get PXIMAGE: Release Access to Imaging Board Frame Buffers NX176"CLASS="NX">Get PXIMAGE: Release Access to Imaging Board Frame Buffers</A>
<LI><A HREF="#Get SV1281 Aoi Left Edge NX494"CLASS="NX">Get SV1281 Aoi Left Edge</A>
<LI><A HREF="#Get SV1281 Aoi Top Edge NX492"CLASS="NX">Get SV1281 Aoi Top Edge</A>
<LI><A HREF="#Get SV1281 Controlled Frame Rate NX508"CLASS="NX">Get SV1281 Controlled Frame Rate</A>
<LI><A HREF="#Get SV1281 Controlled Trigger Mode NX506"CLASS="NX">Get SV1281 Controlled Trigger Mode</A>
<LI><A HREF="#Get SV1281 Controlled Video Mode NX504"CLASS="NX">Get SV1281 Controlled Video Mode</A>
<LI><A HREF="#Get SV1281 Exposure NX483"CLASS="NX">Get SV1281 Exposure</A>
<LI><A HREF="#Get SV1281 Gain NX485"CLASS="NX">Get SV1281 Gain</A>
<LI><A HREF="#Get SV1281 Offset NX487"CLASS="NX">Get SV1281 Offset</A>
<LI><A HREF="#Get SV1281 Pixel Clock Frequency NX496"CLASS="NX">Get SV1281 Pixel Clock Frequency</A>
<LI><A HREF="#Get SV1281 Video Mode NX502"CLASS="NX">Get SV1281 Video Mode</A>
<LI><A HREF="#Get SV1310 Aoi Left Edge NX459"CLASS="NX">Get SV1310 Aoi Left Edge</A>
<LI><A HREF="#Get SV1310 Aoi Top Edge NX457"CLASS="NX">Get SV1310 Aoi Top Edge</A>
<LI><A HREF="#Get SV1310 Color Specific Gain NX451"CLASS="NX">Get SV1310 Color Specific Gain</A>
<LI><A HREF="#Get SV1310 Controlled Exposure NX479"CLASS="NX">Get SV1310 Controlled Exposure</A>
<LI><A HREF="#Get SV1310 Controlled Frame Rate NX477"CLASS="NX">Get SV1310 Controlled Frame Rate</A>
<LI><A HREF="#Get SV1310 Controlled Trigger Mode NX475"CLASS="NX">Get SV1310 Controlled Trigger Mode</A>
<LI><A HREF="#Get SV1310 Controlled Video Mode NX473"CLASS="NX">Get SV1310 Controlled Video Mode</A>
<LI><A HREF="#Get SV1310 Exposure NX442"CLASS="NX">Get SV1310 Exposure</A>
<LI><A HREF="#Get SV1310 Frame Period NX465"CLASS="NX">Get SV1310 Frame Period</A>
<LI><A HREF="#Get SV1310 Gain NX444"CLASS="NX">Get SV1310 Gain</A>
<LI><A HREF="#Get SV1310 Offset NX446"CLASS="NX">Get SV1310 Offset</A>
<LI><A HREF="#Get SV1310 Pixel Clock Frequency NX461"CLASS="NX">Get SV1310 Pixel Clock Frequency</A>
<LI><A HREF="#Get SV1310 Readout Direction NX463"CLASS="NX">Get SV1310 Readout Direction</A>
<LI><A HREF="#Get SV1310 Subsample NX455"CLASS="NX">Get SV1310 Subsample</A>
<LI><A HREF="#Get SV1310 Video Mode NX471"CLASS="NX">Get SV1310 Video Mode</A>
<LI><A HREF="#Get SV2112 Aoi Left Edge NX420"CLASS="NX">Get SV2112 Aoi Left Edge</A>
<LI><A HREF="#Get SV2112 Aoi Top Edge NX418"CLASS="NX">Get SV2112 Aoi Top Edge</A>
<LI><A HREF="#Get SV2112 Controlled Exposure NX438"CLASS="NX">Get SV2112 Controlled Exposure</A>
<LI><A HREF="#Get SV2112 Controlled Frame Rate NX436"CLASS="NX">Get SV2112 Controlled Frame Rate</A>
<LI><A HREF="#Get SV2112 Controlled Trigger Mode NX434"CLASS="NX">Get SV2112 Controlled Trigger Mode</A>
<LI><A HREF="#Get SV2112 Controlled Video Mode NX432"CLASS="NX">Get SV2112 Controlled Video Mode</A>
<LI><A HREF="#Get SV2112 Decimation NX416"CLASS="NX">Get SV2112 Decimation</A>
<LI><A HREF="#Get SV2112 Exposure NX409"CLASS="NX">Get SV2112 Exposure</A>
<LI><A HREF="#Get SV2112 Gain NX411"CLASS="NX">Get SV2112 Gain</A>
<LI><A HREF="#Get SV2112 Pixel Clock Frequency NX422"CLASS="NX">Get SV2112 Pixel Clock Frequency</A>
<LI><A HREF="#Get SV2112 Scan Direction NX424"CLASS="NX">Get SV2112 Scan Direction</A>
<LI><A HREF="#Get SV2112 Video Mode NX430"CLASS="NX">Get SV2112 Video Mode</A>
<LI><A HREF="#Get SV642 Aoi Left Edge NX558"CLASS="NX">Get SV642 Aoi Left Edge</A>
<LI><A HREF="#Get SV642 Aoi Top Edge NX556"CLASS="NX">Get SV642 Aoi Top Edge</A>
<LI><A HREF="#Get SV642 Controlled Frame Rate NX572"CLASS="NX">Get SV642 Controlled Frame Rate</A>
<LI><A HREF="#Get SV642 Controlled Trigger Mode NX570"CLASS="NX">Get SV642 Controlled Trigger Mode</A>
<LI><A HREF="#Get SV642 Controlled Video Mode NX568"CLASS="NX">Get SV642 Controlled Video Mode</A>
<LI><A HREF="#Get SV642 Exposure NX547"CLASS="NX">Get SV642 Exposure</A>
<LI><A HREF="#Get SV642 Gain NX549"CLASS="NX">Get SV642 Gain</A>
<LI><A HREF="#Get SV642 Gain Range NX551"CLASS="NX">Get SV642 Gain Range</A>
<LI><A HREF="#Get SV642 Pixel Clock Frequency NX560"CLASS="NX">Get SV642 Pixel Clock Frequency</A>
<LI><A HREF="#Get SV642 Video Mode NX566"CLASS="NX">Get SV642 Video Mode</A>
<LI><A HREF="#Get SV9M001 Scan Direction NX527"CLASS="NX">Get SV9M001 Scan Direction</A>
<LI><A HREF="#Get SV9M001/SV9T001 Aoi Left Edge NX525"CLASS="NX">Get SV9M001/SV9T001 Aoi Left Edge</A>
<LI><A HREF="#Get SV9M001/SV9T001 Aoi Top Edge NX523"CLASS="NX">Get SV9M001/SV9T001 Aoi Top Edge</A>
<LI><A HREF="#Get SV9M001/SV9T001 Controlled Frame Rate NX543"CLASS="NX">Get SV9M001/SV9T001 Controlled Frame Rate</A>
<LI><A HREF="#Get SV9M001/SV9T001 Controlled Trigger Mode NX541"CLASS="NX">Get SV9M001/SV9T001 Controlled Trigger Mode</A>
<LI><A HREF="#Get SV9M001/SV9T001 Controlled Video Mode NX539"CLASS="NX">Get SV9M001/SV9T001 Controlled Video Mode</A>
<LI><A HREF="#Get SV9M001/SV9T001 Exposure NX514"CLASS="NX">Get SV9M001/SV9T001 Exposure</A>
<LI><A HREF="#Get SV9M001/SV9T001 Gain NX516"CLASS="NX">Get SV9M001/SV9T001 Gain</A>
<LI><A HREF="#Get SV9M001/SV9T001 Pixel Clock Frequency NX531"CLASS="NX">Get SV9M001/SV9T001 Pixel Clock Frequency</A>
<LI><A HREF="#Get SV9M001/SV9T001 Subsample NX529"CLASS="NX">Get SV9M001/SV9T001 Subsample</A>
<LI><A HREF="#Get SV9M001/SV9T001 Video Mode NX537"CLASS="NX">Get SV9M001/SV9T001 Video Mode</A>
<LI><A HREF="#Get SV9T001 Digital Gain NX518"CLASS="NX">Get SV9T001 Digital Gain</A>
<LI><A HREF="#Get Video Brightness NX389"CLASS="NX">Get Video Brightness</A>
<LI><A HREF="#Get Video Contrast NX387"CLASS="NX">Get Video Contrast</A>
<LI><A HREF="#Get Video Field Characteristic NX403"CLASS="NX">Get Video Field Characteristic</A>
<LI><A HREF="#Get Video Field Count NX401"CLASS="NX">Get Video Field Count</A>
<LI><A HREF="#Get Video Hue NX391"CLASS="NX">Get Video Hue</A>
<LI><A HREF="#Get Video Input Multiplexer NX385"CLASS="NX">Get Video Input Multiplexer</A>
<LI><A HREF="#Get Video State NX602"CLASS="NX">Get Video State</A>
<LI><A HREF="#Get Video U Saturation NX393"CLASS="NX">Get Video U Saturation</A>
<LI><A HREF="#Get Video V Saturation NX395"CLASS="NX">Get Video V Saturation</A>
<LI><A HREF="#Graphics Display System NX334"CLASS="NX">Graphics Display System</A>
<LI><A HREF="#Import Copy of Video State NX606"CLASS="NX">Import Copy of Video State</A>
<LI><A HREF="#Inclusions NX3"CLASS="NX">Inclusions</A>
<LI><A HREF="#Initialize Instance of Video Format Configuration Structures NX618"CLASS="NX">Initialize Instance of Video Format Configuration Structures</A>
<LI><A HREF="#Initiate Continuous Alternate Capture into Frame Buffers NX650"CLASS="NX">Initiate Continuous Alternate Capture into Frame Buffers</A>
<LI><A HREF="#Initiate Continuous Capture into Frame Buffer NX648"CLASS="NX">Initiate Continuous Capture into Frame Buffer</A>
<LI><A HREF="#Initiate Continuous Capture into Memory Space NX652"CLASS="NX">Initiate Continuous Capture into Memory Space</A>
<LI><A HREF="#Initiate Sequence Capture into Frame Buffers NX654"CLASS="NX">Initiate Sequence Capture into Frame Buffers</A>
<LI><A HREF="#Initiate Snap into Frame Buffer NX644"CLASS="NX">Initiate Snap into Frame Buffer</A>
<LI><A HREF="#Initiate Snap Pair into Frame Buffers NX646"CLASS="NX">Initiate Snap Pair into Frame Buffers</A>
<LI><A HREF="#Initiate Triggered Capture into Frame Buffer NX656"CLASS="NX">Initiate Triggered Capture into Frame Buffer</A>
<LI><A HREF="#Last Captured Buffer: Buffer Number NX162"CLASS="NX">Last Captured Buffer: Buffer Number</A>
<LI><A HREF="#Last Captured Buffer: Field Count NX164"CLASS="NX">Last Captured Buffer: Field Count</A>
<LI><A HREF="#Last Captured Buffer: System Time NX166"CLASS="NX">Last Captured Buffer: System Time</A>
<LI><A HREF="#Libraries NX0"CLASS="NX">Libraries</A>
<LI><A HREF="#Linux NX219"CLASS="NX">Linux</A>
<LI><A HREF="#Linux: Register Signal upon Captured Video Field NX212"CLASS="NX">Linux: Register Signal upon Captured Video Field</A>
<LI><A HREF="#Linux: Register Signal upon General Purpose Trigger NX216"CLASS="NX">Linux: Register Signal upon General Purpose Trigger</A>
<LI><A HREF="#Linux: Register Signal upon Video Field NX208"CLASS="NX">Linux: Register Signal upon Video Field</A>
<LI><A HREF="#Linux: Unregister Signal upon Captured Video Field NX214"CLASS="NX">Linux: Unregister Signal upon Captured Video Field</A>
<LI><A HREF="#Linux: Unregister Signal upon General Purpose Trigger NX218"CLASS="NX">Linux: Unregister Signal upon General Purpose Trigger</A>
<LI><A HREF="#Linux: Unregister Signal upon Video Field NX210"CLASS="NX">Linux: Unregister Signal upon Video Field</A>
<LI><A HREF="#Load Frame Buffers as Stream NX676"CLASS="NX">Load Frame Buffers as Stream</A>
<LI><A HREF="#Load Frame Buffers NX295"CLASS="NX">Load Frame Buffers</A>
<LI><A HREF="#Load Image: BMP Format NX279"CLASS="NX">Load Image: BMP Format</A>
<LI><A HREF="#Load Image: BMP Format NX686"CLASS="NX">Load Image: BMP Format</A>
<LI><A HREF="#Load Image: TIFF Format NX281"CLASS="NX">Load Image: TIFF Format</A>
<LI><A HREF="#Load Image: TIFF Format NX688"CLASS="NX">Load Image: TIFF Format</A>
<LI><A HREF="#Obtain Filtered pximage Access into Imaging Board Memory NX628"CLASS="NX">Obtain Filtered pximage Access into Imaging Board Memory</A>
<LI><A HREF="#Obtain Filtered pximage3 Access into Imaging Board Memory NX630"CLASS="NX">Obtain Filtered pximage3 Access into Imaging Board Memory</A>
<LI><A HREF="#Obtain Last Logged Fault NX586"CLASS="NX">Obtain Last Logged Fault</A>
<LI><A HREF="#Obtain Pointer into Imaging Board Memory NX620"CLASS="NX">Obtain Pointer into Imaging Board Memory</A>
<LI><A HREF="#Obtain pximage Access into Imaging Board Memory NX624"CLASS="NX">Obtain pximage Access into Imaging Board Memory</A>
<LI><A HREF="#Obtain pximage3 Access into Imaging Board Memory NX626"CLASS="NX">Obtain pximage3 Access into Imaging Board Memory</A>
<LI><A HREF="#PCX Format NX293"CLASS="NX">PCX Format</A>
<LI><A HREF="#PCX Format NX700"CLASS="NX">PCX Format</A>
<LI><A HREF="#PIXCI&reg; Imaging Board: Close NX307"CLASS="NX">PIXCI&reg; Imaging Board: Close</A>
<LI><A HREF="#PIXCI&reg; Imaging Board: Open and Set Video Format Configuration NX305"CLASS="NX">PIXCI&reg; Imaging Board: Open and Set Video Format Configuration</A>
<LI><A HREF="#PIXCI&reg; Imaging Board: Structured Close NX580"CLASS="NX">PIXCI&reg; Imaging Board: Structured Close</A>
<LI><A HREF="#PIXCI&reg; Imaging Board: Structured Open NX578"CLASS="NX">PIXCI&reg; Imaging Board: Structured Open</A>
<LI><A HREF="#Printing NX335"CLASS="NX">Printing</A>
<LI><A HREF="#pxabortfunc_t NX36"CLASS="NX">pxabortfunc_t</A>
<LI><A HREF="#pxauxservice, struct NX119"CLASS="NX">pxauxservice, struct</A>
<LI><A HREF="#pxauxservice_s NX149"CLASS="NX">pxauxservice_s</A>
<LI><A HREF="#pxbuffer_t NX15"CLASS="NX">pxbuffer_t</A>
<LI><A HREF="#pxbufstatus, struct NX122"CLASS="NX">pxbufstatus, struct</A>
<LI><A HREF="#pxbufstatus_s NX152"CLASS="NX">pxbufstatus_s</A>
<LI><A HREF="#pxcamcntl, struct NX103"CLASS="NX">pxcamcntl, struct</A>
<LI><A HREF="#pxcamcntl_s NX133"CLASS="NX">pxcamcntl_s</A>
<LI><A HREF="#PXCam_SILICONVIDEO1281 NX732"CLASS="NX">PXCam_SILICONVIDEO1281</A>
<LI><A HREF="#PXCam_SILICONVIDEO1310 NX726"CLASS="NX">PXCam_SILICONVIDEO1310</A>
<LI><A HREF="#PXCam_SILICONVIDEO2112 NX720"CLASS="NX">PXCam_SILICONVIDEO2112</A>
<LI><A HREF="#PXCam_SILICONVIDEO642 NX746"CLASS="NX">PXCam_SILICONVIDEO642</A>
<LI><A HREF="#PXCam_SILICONVIDEO9M001 NX738"CLASS="NX">PXCam_SILICONVIDEO9M001</A>
<LI><A HREF="#PXCam_SILICONVIDEO9M001 NX740"CLASS="NX">PXCam_SILICONVIDEO9M001</A>
<LI><A HREF="#PXCam_SV1281State, struct NX735"CLASS="NX">PXCam_SV1281State, struct</A>
<LI><A HREF="#PXCam_SV1281State_s NX736"CLASS="NX">PXCam_SV1281State_s</A>
<LI><A HREF="#PXCam_SV1310State, struct NX729"CLASS="NX">PXCam_SV1310State, struct</A>
<LI><A HREF="#PXCam_SV1310State_s NX730"CLASS="NX">PXCam_SV1310State_s</A>
<LI><A HREF="#PXCam_SV2112State, struct NX723"CLASS="NX">PXCam_SV2112State, struct</A>
<LI><A HREF="#PXCam_SV2112State_s NX724"CLASS="NX">PXCam_SV2112State_s</A>
<LI><A HREF="#PXCam_SV642State, struct NX749"CLASS="NX">PXCam_SV642State, struct</A>
<LI><A HREF="#PXCam_SV642State_s NX750"CLASS="NX">PXCam_SV642State_s</A>
<LI><A HREF="#PXCam_SV9M001State, struct NX743"CLASS="NX">PXCam_SV9M001State, struct</A>
<LI><A HREF="#PXCam_SV9M001State_s NX744"CLASS="NX">PXCam_SV9M001State_s</A>
<LI><A HREF="#pxcoord_t NX14"CLASS="NX">pxcoord_t</A>
<LI><A HREF="#pxcoord_t NX755"CLASS="NX">pxcoord_t</A>
<LI><A HREF="#pxddch, struct NX93"CLASS="NX">pxddch, struct</A>
<LI><A HREF="#pxddch_s NX123"CLASS="NX">pxddch_s</A>
<LI><A HREF="#pxdevfault, struct NX113"CLASS="NX">pxdevfault, struct</A>
<LI><A HREF="#pxdevfault_s NX143"CLASS="NX">pxdevfault_s</A>
<LI><A HREF="#pxdevinfo, struct NX107"CLASS="NX">pxdevinfo, struct</A>
<LI><A HREF="#pxdevinfo_s NX137"CLASS="NX">pxdevinfo_s</A>
<LI><A HREF="#pxdevservice, struct NX118"CLASS="NX">pxdevservice, struct</A>
<LI><A HREF="#pxdevservice_s NX148"CLASS="NX">pxdevservice_s</A>
<LI><A HREF="#pxd_buffersFieldCount NX155"CLASS="NX">pxd_buffersFieldCount</A>
<LI><A HREF="#pxd_buffersGPIn NX157"CLASS="NX">pxd_buffersGPIn</A>
<LI><A HREF="#pxd_buffersSysTicks NX159"CLASS="NX">pxd_buffersSysTicks</A>
<LI><A HREF="#pxd_capturedBuffer NX161"CLASS="NX">pxd_capturedBuffer</A>
<LI><A HREF="#pxd_capturedFieldCount NX163"CLASS="NX">pxd_capturedFieldCount</A>
<LI><A HREF="#pxd_capturedSysTicks NX165"CLASS="NX">pxd_capturedSysTicks</A>
<LI><A HREF="#pxd_defineImage NX167"CLASS="NX">pxd_defineImage</A>
<LI><A HREF="#pxd_defineImage3 NX169"CLASS="NX">pxd_defineImage3</A>
<LI><A HREF="#pxd_definePximage NX171"CLASS="NX">pxd_definePximage</A>
<LI><A HREF="#pxd_definePximage3 NX173"CLASS="NX">pxd_definePximage3</A>
<LI><A HREF="#pxd_definePximage3Free NX177"CLASS="NX">pxd_definePximage3Free</A>
<LI><A HREF="#pxd_definePximageFree NX175"CLASS="NX">pxd_definePximageFree</A>
<LI><A HREF="#pxd_doSnap NX179"CLASS="NX">pxd_doSnap</A>
<LI><A HREF="#pxd_eventCapturedFieldClose NX187"CLASS="NX">pxd_eventCapturedFieldClose</A>
<LI><A HREF="#pxd_eventCapturedFieldClose NX200"CLASS="NX">pxd_eventCapturedFieldClose</A>
<LI><A HREF="#pxd_eventCapturedFieldClose NX213"CLASS="NX">pxd_eventCapturedFieldClose</A>
<LI><A HREF="#pxd_eventCapturedFieldCreate NX185"CLASS="NX">pxd_eventCapturedFieldCreate</A>
<LI><A HREF="#pxd_eventCapturedFieldCreate NX198"CLASS="NX">pxd_eventCapturedFieldCreate</A>
<LI><A HREF="#pxd_eventCapturedFieldCreate NX211"CLASS="NX">pxd_eventCapturedFieldCreate</A>
<LI><A HREF="#pxd_eventFieldClose NX183"CLASS="NX">pxd_eventFieldClose</A>
<LI><A HREF="#pxd_eventFieldClose NX196"CLASS="NX">pxd_eventFieldClose</A>
<LI><A HREF="#pxd_eventFieldClose NX209"CLASS="NX">pxd_eventFieldClose</A>
<LI><A HREF="#pxd_eventFieldCreate NX181"CLASS="NX">pxd_eventFieldCreate</A>
<LI><A HREF="#pxd_eventFieldCreate NX194"CLASS="NX">pxd_eventFieldCreate</A>
<LI><A HREF="#pxd_eventFieldCreate NX207"CLASS="NX">pxd_eventFieldCreate</A>
<LI><A HREF="#pxd_eventGPTriggerClose NX191"CLASS="NX">pxd_eventGPTriggerClose</A>
<LI><A HREF="#pxd_eventGPTriggerClose NX204"CLASS="NX">pxd_eventGPTriggerClose</A>
<LI><A HREF="#pxd_eventGPTriggerClose NX217"CLASS="NX">pxd_eventGPTriggerClose</A>
<LI><A HREF="#pxd_eventGPTriggerCreate NX189"CLASS="NX">pxd_eventGPTriggerCreate</A>
<LI><A HREF="#pxd_eventGPTriggerCreate NX202"CLASS="NX">pxd_eventGPTriggerCreate</A>
<LI><A HREF="#pxd_eventGPTriggerCreate NX215"CLASS="NX">pxd_eventGPTriggerCreate</A>
<LI><A HREF="#pxd_getBrightness NX388"CLASS="NX">pxd_getBrightness</A>
<LI><A HREF="#pxd_getContrast NX386"CLASS="NX">pxd_getContrast</A>
<LI><A HREF="#pxd_getExsync NX368"CLASS="NX">pxd_getExsync</A>
<LI><A HREF="#pxd_getExsyncMode NX374"CLASS="NX">pxd_getExsyncMode</A>
<LI><A HREF="#pxd_getGPIn NX220"CLASS="NX">pxd_getGPIn</A>
<LI><A HREF="#pxd_getGPOut NX226"CLASS="NX">pxd_getGPOut</A>
<LI><A HREF="#pxd_getGPTrigger NX228"CLASS="NX">pxd_getGPTrigger</A>
<LI><A HREF="#pxd_getHue NX390"CLASS="NX">pxd_getHue</A>
<LI><A HREF="#pxd_getPrin NX370"CLASS="NX">pxd_getPrin</A>
<LI><A HREF="#pxd_getPrincMode NX376"CLASS="NX">pxd_getPrincMode</A>
<LI><A HREF="#pxd_getUGain NX392"CLASS="NX">pxd_getUGain</A>
<LI><A HREF="#pxd_getVGain NX394"CLASS="NX">pxd_getVGain</A>
<LI><A HREF="#pxd_getVidMux NX384"CLASS="NX">pxd_getVidMux</A>
<LI><A HREF="#pxd_goAbortLive NX242"CLASS="NX">pxd_goAbortLive</A>
<LI><A HREF="#pxd_goLive NX234"CLASS="NX">pxd_goLive</A>
<LI><A HREF="#pxd_goLivePair NX236"CLASS="NX">pxd_goLivePair</A>
<LI><A HREF="#pxd_goLiveSeq NX238"CLASS="NX">pxd_goLiveSeq</A>
<LI><A HREF="#pxd_goLiveSeqTrig NX246"CLASS="NX">pxd_goLiveSeqTrig</A>
<LI><A HREF="#pxd_goLiveTrig NX244"CLASS="NX">pxd_goLiveTrig</A>
<LI><A HREF="#pxd_goneLive NX248"CLASS="NX">pxd_goneLive</A>
<LI><A HREF="#pxd_goSnap NX230"CLASS="NX">pxd_goSnap</A>
<LI><A HREF="#pxd_goSnapPair NX232"CLASS="NX">pxd_goSnapPair</A>
<LI><A HREF="#pxd_goUnLive NX240"CLASS="NX">pxd_goUnLive</A>
<LI><A HREF="#pxd_imageAspectRatio NX250"CLASS="NX">pxd_imageAspectRatio</A>
<LI><A HREF="#pxd_imageBdim NX252"CLASS="NX">pxd_imageBdim</A>
<LI><A HREF="#pxd_imageCdim NX254"CLASS="NX">pxd_imageCdim</A>
<LI><A HREF="#pxd_imageIdim NX256"CLASS="NX">pxd_imageIdim</A>
<LI><A HREF="#pxd_imageXdim NX258"CLASS="NX">pxd_imageXdim</A>
<LI><A HREF="#pxd_imageYdim NX260"CLASS="NX">pxd_imageYdim</A>
<LI><A HREF="#pxd_imageZdim NX262"CLASS="NX">pxd_imageZdim</A>
<LI><A HREF="#pxd_infoDriverId NX264"CLASS="NX">pxd_infoDriverId</A>
<LI><A HREF="#pxd_infoIncludeId NX266"CLASS="NX">pxd_infoIncludeId</A>
<LI><A HREF="#pxd_infoLibraryId NX268"CLASS="NX">pxd_infoLibraryId</A>
<LI><A HREF="#pxd_infoMemsize NX270"CLASS="NX">pxd_infoMemsize</A>
<LI><A HREF="#pxd_infoModel NX272"CLASS="NX">pxd_infoModel</A>
<LI><A HREF="#pxd_infoSubmodel NX274"CLASS="NX">pxd_infoSubmodel</A>
<LI><A HREF="#pxd_infoUnits NX276"CLASS="NX">pxd_infoUnits</A>
<LI><A HREF="#pxd_loadBmp NX278"CLASS="NX">pxd_loadBmp</A>
<LI><A HREF="#pxd_loadRawBuffers NX294"CLASS="NX">pxd_loadRawBuffers</A>
<LI><A HREF="#pxd_loadTiff NX280"CLASS="NX">pxd_loadTiff</A>
<LI><A HREF="#pxd_mesgErrorCode NX298"CLASS="NX">pxd_mesgErrorCode</A>
<LI><A HREF="#pxd_mesgFault NX300"CLASS="NX">pxd_mesgFault</A>
<LI><A HREF="#pxd_mesgFaultText NX302"CLASS="NX">pxd_mesgFaultText</A>
<LI><A HREF="#pxd_PIXCIclose NX306"CLASS="NX">pxd_PIXCIclose</A>
<LI><A HREF="#pxd_PIXCIopen NX304"CLASS="NX">pxd_PIXCIopen</A>
<LI><A HREF="#pxd_readuchar NX308"CLASS="NX">pxd_readuchar</A>
<LI><A HREF="#pxd_readushort NX310"CLASS="NX">pxd_readushort</A>
<LI><A HREF="#pxd_renderDIBCreate NX316"CLASS="NX">pxd_renderDIBCreate</A>
<LI><A HREF="#pxd_renderDIBFree NX318"CLASS="NX">pxd_renderDIBFree</A>
<LI><A HREF="#pxd_renderDirectVideoDone NX322"CLASS="NX">pxd_renderDirectVideoDone</A>
<LI><A HREF="#pxd_renderDirectVideoInit NX320"CLASS="NX">pxd_renderDirectVideoInit</A>
<LI><A HREF="#pxd_renderDirectVideoLive NX325"CLASS="NX">pxd_renderDirectVideoLive</A>
<LI><A HREF="#pxd_renderDirectVideoUnLive NX327"CLASS="NX">pxd_renderDirectVideoUnLive</A>
<LI><A HREF="#pxd_renderStretchDIBits NX330"CLASS="NX">pxd_renderStretchDIBits</A>
<LI><A HREF="#pxd_saveBmp NX282"CLASS="NX">pxd_saveBmp</A>
<LI><A HREF="#pxd_savePcx NX284"CLASS="NX">pxd_savePcx</A>
<LI><A HREF="#pxd_saveRawBuffers NX296"CLASS="NX">pxd_saveRawBuffers</A>
<LI><A HREF="#pxd_saveTga NX286"CLASS="NX">pxd_saveTga</A>
<LI><A HREF="#pxd_saveTiff NX288"CLASS="NX">pxd_saveTiff</A>
<LI><A HREF="#pxd_serialConfigure NX336"CLASS="NX">pxd_serialConfigure</A>
<LI><A HREF="#pxd_serialRead NX338"CLASS="NX">pxd_serialRead</A>
<LI><A HREF="#pxd_serialWrite NX340"CLASS="NX">pxd_serialWrite</A>
<LI><A HREF="#pxd_setContrastBrightness NX380"CLASS="NX">pxd_setContrastBrightness</A>
<LI><A HREF="#pxd_setExsyncPrin NX366"CLASS="NX">pxd_setExsyncPrin</A>
<LI><A HREF="#pxd_setExsyncPrincMode NX372"CLASS="NX">pxd_setExsyncPrincMode</A>
<LI><A HREF="#pxd_setGPIn NX222"CLASS="NX">pxd_setGPIn</A>
<LI><A HREF="#pxd_setGPOut NX224"CLASS="NX">pxd_setGPOut</A>
<LI><A HREF="#pxd_setHueSaturation NX382"CLASS="NX">pxd_setHueSaturation</A>
<LI><A HREF="#pxd_setImageBrightBalance NX396"CLASS="NX">pxd_setImageBrightBalance</A>
<LI><A HREF="#pxd_setImageDarkBalance NX398"CLASS="NX">pxd_setImageDarkBalance</A>
<LI><A HREF="#pxd_setVidMux NX378"CLASS="NX">pxd_setVidMux</A>
<LI><A HREF="#pxd_SV1281_getAoiLeft NX493"CLASS="NX">pxd_SV1281_getAoiLeft</A>
<LI><A HREF="#pxd_SV1281_getAoiTop NX491"CLASS="NX">pxd_SV1281_getAoiTop</A>
<LI><A HREF="#pxd_SV1281_getCtrlFrameRate NX507"CLASS="NX">pxd_SV1281_getCtrlFrameRate</A>
<LI><A HREF="#pxd_SV1281_getCtrlTriggerMode NX505"CLASS="NX">pxd_SV1281_getCtrlTriggerMode</A>
<LI><A HREF="#pxd_SV1281_getCtrlVideoMode NX503"CLASS="NX">pxd_SV1281_getCtrlVideoMode</A>
<LI><A HREF="#pxd_SV1281_getExposure NX482"CLASS="NX">pxd_SV1281_getExposure</A>
<LI><A HREF="#pxd_SV1281_getGain NX484"CLASS="NX">pxd_SV1281_getGain</A>
<LI><A HREF="#pxd_SV1281_getOffset NX486"CLASS="NX">pxd_SV1281_getOffset</A>
<LI><A HREF="#pxd_SV1281_getPixelClock NX495"CLASS="NX">pxd_SV1281_getPixelClock</A>
<LI><A HREF="#pxd_SV1281_getVideoMode NX501"CLASS="NX">pxd_SV1281_getVideoMode</A>
<LI><A HREF="#pxd_SV1281_setCtrlRate NX499"CLASS="NX">pxd_SV1281_setCtrlRate</A>
<LI><A HREF="#pxd_SV1281_setExposureGainOffset NX480"CLASS="NX">pxd_SV1281_setExposureGainOffset</A>
<LI><A HREF="#pxd_SV1281_setResolutionAndTiming NX489"CLASS="NX">pxd_SV1281_setResolutionAndTiming</A>
<LI><A HREF="#pxd_SV1281_setVideoAndTriggerMode NX497"CLASS="NX">pxd_SV1281_setVideoAndTriggerMode</A>
<LI><A HREF="#pxd_SV1310_getAoiLeft NX458"CLASS="NX">pxd_SV1310_getAoiLeft</A>
<LI><A HREF="#pxd_SV1310_getAoiTop NX456"CLASS="NX">pxd_SV1310_getAoiTop</A>
<LI><A HREF="#pxd_SV1310_getColorGain NX450"CLASS="NX">pxd_SV1310_getColorGain</A>
<LI><A HREF="#pxd_SV1310_getCtrlExposure NX478"CLASS="NX">pxd_SV1310_getCtrlExposure</A>
<LI><A HREF="#pxd_SV1310_getCtrlFrameRate NX476"CLASS="NX">pxd_SV1310_getCtrlFrameRate</A>
<LI><A HREF="#pxd_SV1310_getCtrlTriggerMode NX474"CLASS="NX">pxd_SV1310_getCtrlTriggerMode</A>
<LI><A HREF="#pxd_SV1310_getCtrlVideoMode NX472"CLASS="NX">pxd_SV1310_getCtrlVideoMode</A>
<LI><A HREF="#pxd_SV1310_getExposure NX441"CLASS="NX">pxd_SV1310_getExposure</A>
<LI><A HREF="#pxd_SV1310_getFramePeriod NX464"CLASS="NX">pxd_SV1310_getFramePeriod</A>
<LI><A HREF="#pxd_SV1310_getGain NX443"CLASS="NX">pxd_SV1310_getGain</A>
<LI><A HREF="#pxd_SV1310_getOffset NX445"CLASS="NX">pxd_SV1310_getOffset</A>
<LI><A HREF="#pxd_SV1310_getPixelClock NX460"CLASS="NX">pxd_SV1310_getPixelClock</A>
<LI><A HREF="#pxd_SV1310_getReadoutDirection NX462"CLASS="NX">pxd_SV1310_getReadoutDirection</A>
<LI><A HREF="#pxd_SV1310_getSubsample NX454"CLASS="NX">pxd_SV1310_getSubsample</A>
<LI><A HREF="#pxd_SV1310_getVideoMode NX470"CLASS="NX">pxd_SV1310_getVideoMode</A>
<LI><A HREF="#pxd_SV1310_setColorGain NX448"CLASS="NX">pxd_SV1310_setColorGain</A>
<LI><A HREF="#pxd_SV1310_setCtrlRate NX468"CLASS="NX">pxd_SV1310_setCtrlRate</A>
<LI><A HREF="#pxd_SV1310_setExposureGainOffset NX439"CLASS="NX">pxd_SV1310_setExposureGainOffset</A>
<LI><A HREF="#pxd_SV1310_setResolutionAndTiming NX452"CLASS="NX">pxd_SV1310_setResolutionAndTiming</A>
<LI><A HREF="#pxd_SV1310_setVideoAndTriggerMode NX466"CLASS="NX">pxd_SV1310_setVideoAndTriggerMode</A>
<LI><A HREF="#pxd_SV2112_getAoiLeft NX419"CLASS="NX">pxd_SV2112_getAoiLeft</A>
<LI><A HREF="#pxd_SV2112_getAoiTop NX417"CLASS="NX">pxd_SV2112_getAoiTop</A>
<LI><A HREF="#pxd_SV2112_getCtrlExposure NX437"CLASS="NX">pxd_SV2112_getCtrlExposure</A>
<LI><A HREF="#pxd_SV2112_getCtrlFrameRate NX435"CLASS="NX">pxd_SV2112_getCtrlFrameRate</A>
<LI><A HREF="#pxd_SV2112_getCtrlTriggerMode NX433"CLASS="NX">pxd_SV2112_getCtrlTriggerMode</A>
<LI><A HREF="#pxd_SV2112_getCtrlVideoMode NX431"CLASS="NX">pxd_SV2112_getCtrlVideoMode</A>
<LI><A HREF="#pxd_SV2112_getDecimation NX415"CLASS="NX">pxd_SV2112_getDecimation</A>
<LI><A HREF="#pxd_SV2112_getExposure NX408"CLASS="NX">pxd_SV2112_getExposure</A>
<LI><A HREF="#pxd_SV2112_getGain NX410"CLASS="NX">pxd_SV2112_getGain</A>
<LI><A HREF="#pxd_SV2112_getPixelClock NX421"CLASS="NX">pxd_SV2112_getPixelClock</A>
<LI><A HREF="#pxd_SV2112_getScanDirection NX423"CLASS="NX">pxd_SV2112_getScanDirection</A>
<LI><A HREF="#pxd_SV2112_getVideoMode NX429"CLASS="NX">pxd_SV2112_getVideoMode</A>
<LI><A HREF="#pxd_SV2112_setCtrlExposureAndRate NX427"CLASS="NX">pxd_SV2112_setCtrlExposureAndRate</A>
<LI><A HREF="#pxd_SV2112_setExposureAndGain NX406"CLASS="NX">pxd_SV2112_setExposureAndGain</A>
<LI><A HREF="#pxd_SV2112_setResolutionAndTiming NX413"CLASS="NX">pxd_SV2112_setResolutionAndTiming</A>
<LI><A HREF="#pxd_SV2112_setVideoAndTriggerMode NX425"CLASS="NX">pxd_SV2112_setVideoAndTriggerMode</A>
<LI><A HREF="#pxd_SV642_getAoiLeft NX557"CLASS="NX">pxd_SV642_getAoiLeft</A>
<LI><A HREF="#pxd_SV642_getAoiTop NX555"CLASS="NX">pxd_SV642_getAoiTop</A>
<LI><A HREF="#pxd_SV642_getCtrlFrameRate NX571"CLASS="NX">pxd_SV642_getCtrlFrameRate</A>
<LI><A HREF="#pxd_SV642_getCtrlTriggerMode NX569"CLASS="NX">pxd_SV642_getCtrlTriggerMode</A>
<LI><A HREF="#pxd_SV642_getCtrlVideoMode NX567"CLASS="NX">pxd_SV642_getCtrlVideoMode</A>
<LI><A HREF="#pxd_SV642_getExposure NX546"CLASS="NX">pxd_SV642_getExposure</A>
<LI><A HREF="#pxd_SV642_getGain NX548"CLASS="NX">pxd_SV642_getGain</A>
<LI><A HREF="#pxd_SV642_getGainRange NX550"CLASS="NX">pxd_SV642_getGainRange</A>
<LI><A HREF="#pxd_SV642_getPixelClock NX559"CLASS="NX">pxd_SV642_getPixelClock</A>
<LI><A HREF="#pxd_SV642_getVideoMode NX565"CLASS="NX">pxd_SV642_getVideoMode</A>
<LI><A HREF="#pxd_SV642_setCtrlRate NX563"CLASS="NX">pxd_SV642_setCtrlRate</A>
<LI><A HREF="#pxd_SV642_setExposureAndGain NX544"CLASS="NX">pxd_SV642_setExposureAndGain</A>
<LI><A HREF="#pxd_SV642_setResolutionAndTiming NX553"CLASS="NX">pxd_SV642_setResolutionAndTiming</A>
<LI><A HREF="#pxd_SV642_setVideoAndTriggerMode NX561"CLASS="NX">pxd_SV642_setVideoAndTriggerMode</A>
<LI><A HREF="#pxd_SV9M001_getAoiLeft NX524"CLASS="NX">pxd_SV9M001_getAoiLeft</A>
<LI><A HREF="#pxd_SV9M001_getAoiTop NX522"CLASS="NX">pxd_SV9M001_getAoiTop</A>
<LI><A HREF="#pxd_SV9M001_getCtrlFrameRate NX542"CLASS="NX">pxd_SV9M001_getCtrlFrameRate</A>
<LI><A HREF="#pxd_SV9M001_getCtrlTriggerMode NX540"CLASS="NX">pxd_SV9M001_getCtrlTriggerMode</A>
<LI><A HREF="#pxd_SV9M001_getCtrlVideoMode NX538"CLASS="NX">pxd_SV9M001_getCtrlVideoMode</A>
<LI><A HREF="#pxd_SV9M001_getDigitalGain NX517"CLASS="NX">pxd_SV9M001_getDigitalGain</A>
<LI><A HREF="#pxd_SV9M001_getExposure NX513"CLASS="NX">pxd_SV9M001_getExposure</A>
<LI><A HREF="#pxd_SV9M001_getGain NX515"CLASS="NX">pxd_SV9M001_getGain</A>
<LI><A HREF="#pxd_SV9M001_getPixelClock NX530"CLASS="NX">pxd_SV9M001_getPixelClock</A>
<LI><A HREF="#pxd_SV9M001_getScanDirection NX526"CLASS="NX">pxd_SV9M001_getScanDirection</A>
<LI><A HREF="#pxd_SV9M001_getSubsample NX528"CLASS="NX">pxd_SV9M001_getSubsample</A>
<LI><A HREF="#pxd_SV9M001_getVideoMode NX536"CLASS="NX">pxd_SV9M001_getVideoMode</A>
<LI><A HREF="#pxd_SV9M001_setCtrlRate NX534"CLASS="NX">pxd_SV9M001_setCtrlRate</A>
<LI><A HREF="#pxd_SV9M001_setExposureAndDigitalGain NX511"CLASS="NX">pxd_SV9M001_setExposureAndDigitalGain</A>
<LI><A HREF="#pxd_SV9M001_setExposureAndGain NX509"CLASS="NX">pxd_SV9M001_setExposureAndGain</A>
<LI><A HREF="#pxd_SV9M001_setResolutionAndTiming NX520"CLASS="NX">pxd_SV9M001_setResolutionAndTiming</A>
<LI><A HREF="#pxd_SV9M001_setVideoAndTriggerMode NX532"CLASS="NX">pxd_SV9M001_setVideoAndTriggerMode</A>
<LI><A HREF="#pxd_videoFieldCount NX400"CLASS="NX">pxd_videoFieldCount</A>
<LI><A HREF="#pxd_videoFieldsPerFrame NX402"CLASS="NX">pxd_videoFieldsPerFrame</A>
<LI><A HREF="#pxd_videoFormatAsIncluded NX404"CLASS="NX">pxd_videoFormatAsIncluded</A>
<LI><A HREF="#pxd_writeuchar NX312"CLASS="NX">pxd_writeuchar</A>
<LI><A HREF="#pxd_writeushort NX314"CLASS="NX">pxd_writeushort</A>
<LI><A HREF="#pximadrs, struct NX804"CLASS="NX">pximadrs, struct</A>
<LI><A HREF="#pximadrs_s NX805"CLASS="NX">pximadrs_s</A>
<LI><A HREF="#pximage, struct NX58"CLASS="NX">pximage, struct</A>
<LI><A HREF="#pximage3, struct NX61"CLASS="NX">pximage3, struct</A>
<LI><A HREF="#pximage3buf, struct NX115"CLASS="NX">pximage3buf, struct</A>
<LI><A HREF="#pximage3buf_s NX145"CLASS="NX">pximage3buf_s</A>
<LI><A HREF="#pximage3_s NX62"CLASS="NX">pximage3_s</A>
<LI><A HREF="#PXIMAGE: Access Non-Sequential Pixels NX796"CLASS="NX">PXIMAGE: Access Non-Sequential Pixels</A>
<LI><A HREF="#PXIMAGE: Get Advice, Errors, Info &amp; Options NX774"CLASS="NX">PXIMAGE: Get Advice, Errors, Info &amp; Options</A>
<LI><A HREF="#PXIMAGE: Image and Pixel Specifications NX753"CLASS="NX">PXIMAGE: Image and Pixel Specifications</A>
<LI><A HREF="#PXIMAGE: Obtain Pointer to Pixels NX809"CLASS="NX">PXIMAGE: Obtain Pointer to Pixels</A>
<LI><A HREF="#PXIMAGE: Obtain Sequential Access Pixel Count NX785"CLASS="NX">PXIMAGE: Obtain Sequential Access Pixel Count</A>
<LI><A HREF="#PXIMAGE: Prepare for Non-Sequential Pixel Access NX794"CLASS="NX">PXIMAGE: Prepare for Non-Sequential Pixel Access</A>
<LI><A HREF="#PXIMAGE: Read Sequential Pixels NX779"CLASS="NX">PXIMAGE: Read Sequential Pixels</A>
<LI><A HREF="#PXIMAGE: Release Pointer to Pixels NX811"CLASS="NX">PXIMAGE: Release Pointer to Pixels</A>
<LI><A HREF="#PXIMAGE: Set &amp; Get Area of Interest Window NX771"CLASS="NX">PXIMAGE: Set &amp; Get Area of Interest Window</A>
<LI><A HREF="#PXIMAGE: Set to Access Non-Sequential Pixels NX792"CLASS="NX">PXIMAGE: Set to Access Non-Sequential Pixels</A>
<LI><A HREF="#PXIMAGE: Set to Access Sequential Pixels NX777"CLASS="NX">PXIMAGE: Set to Access Sequential Pixels</A>
<LI><A HREF="#PXIMAGE: Set to Obtain Pointer to Pixels NX807"CLASS="NX">PXIMAGE: Set to Obtain Pointer to Pixels</A>
<LI><A HREF="#PXIMAGE: Wait for Non-Sequential Access Completion NX798"CLASS="NX">PXIMAGE: Wait for Non-Sequential Access Completion</A>
<LI><A HREF="#PXIMAGE: Wait for Sequential Access Completion NX783"CLASS="NX">PXIMAGE: Wait for Sequential Access Completion</A>
<LI><A HREF="#PXIMAGE: Write Sequential Pixels NX781"CLASS="NX">PXIMAGE: Write Sequential Pixels</A>
<LI><A HREF="#pximage::aeiou NX773"CLASS="NX">pximage::aeiou</A>
<LI><A HREF="#pximage::bxta NX795"CLASS="NX">pximage::bxta</A>
<LI><A HREF="#pximage::bxtp NX793"CLASS="NX">pximage::bxtp</A>
<LI><A HREF="#pximage::bxts NX791"CLASS="NX">pximage::bxts</A>
<LI><A HREF="#pximage::bxtw NX797"CLASS="NX">pximage::bxtw</A>
<LI><A HREF="#pximage::imap NX808"CLASS="NX">pximage::imap</A>
<LI><A HREF="#pximage::imapr NX810"CLASS="NX">pximage::imapr</A>
<LI><A HREF="#pximage::imapset NX806"CLASS="NX">pximage::imapset</A>
<LI><A HREF="#pximage::iolen NX784"CLASS="NX">pximage::iolen</A>
<LI><A HREF="#pximage::ioread NX778"CLASS="NX">pximage::ioread</A>
<LI><A HREF="#pximage::iorite NX780"CLASS="NX">pximage::iorite</A>
<LI><A HREF="#pximage::ioset NX776"CLASS="NX">pximage::ioset</A>
<LI><A HREF="#pximage::iowait NX782"CLASS="NX">pximage::iowait</A>
<LI><A HREF="#pximage::xwind NX770"CLASS="NX">pximage::xwind</A>
<LI><A HREF="#pximagebuf, struct NX114"CLASS="NX">pximagebuf, struct</A>
<LI><A HREF="#pximagebuf_s NX144"CLASS="NX">pximagebuf_s</A>
<LI><A HREF="#pximage_s NX59"CLASS="NX">pximage_s</A>
<LI><A HREF="#pximap, struct NX816"CLASS="NX">pximap, struct</A>
<LI><A HREF="#pxtimestamp, struct NX110"CLASS="NX">pxtimestamp, struct</A>
<LI><A HREF="#pxtimestamp_s NX140"CLASS="NX">pxtimestamp_s</A>
<LI><A HREF="#pxtrigspec, struct NX116"CLASS="NX">pxtrigspec, struct</A>
<LI><A HREF="#pxtrigspec_s NX146"CLASS="NX">pxtrigspec_s</A>
<LI><A HREF="#pxvbtime_t NX16"CLASS="NX">pxvbtime_t</A>
<LI><A HREF="#pxviddim, struct NX97"CLASS="NX">pxviddim, struct</A>
<LI><A HREF="#pxviddim_s NX127"CLASS="NX">pxviddim_s</A>
<LI><A HREF="#pxvidformat, struct NX95"CLASS="NX">pxvidformat, struct</A>
<LI><A HREF="#pxvidformat_s NX125"CLASS="NX">pxvidformat_s</A>
<LI><A HREF="#pxvidimage, struct NX96"CLASS="NX">pxvidimage, struct</A>
<LI><A HREF="#pxvidimage_s NX126"CLASS="NX">pxvidimage_s</A>
<LI><A HREF="#pxvidmem, struct NX102"CLASS="NX">pxvidmem, struct</A>
<LI><A HREF="#pxvidmem_s NX132"CLASS="NX">pxvidmem_s</A>
<LI><A HREF="#pxvidmode, struct NX100"CLASS="NX">pxvidmode, struct</A>
<LI><A HREF="#pxvidmode_s NX130"CLASS="NX">pxvidmode_s</A>
<LI><A HREF="#pxvidopt, struct NX101"CLASS="NX">pxvidopt, struct</A>
<LI><A HREF="#pxvidopt_s NX131"CLASS="NX">pxvidopt_s</A>
<LI><A HREF="#pxvidphys, struct NX99"CLASS="NX">pxvidphys, struct</A>
<LI><A HREF="#pxvidphys_s NX129"CLASS="NX">pxvidphys_s</A>
<LI><A HREF="#pxvidres, struct NX98"CLASS="NX">pxvidres, struct</A>
<LI><A HREF="#pxvidres_s NX128"CLASS="NX">pxvidres_s</A>
<LI><A HREF="#pxvidstate, struct NX94"CLASS="NX">pxvidstate, struct</A>
<LI><A HREF="#pxvidstate_s NX124"CLASS="NX">pxvidstate_s</A>
<LI><A HREF="#pxvidstatus, struct NX111"CLASS="NX">pxvidstatus, struct</A>
<LI><A HREF="#pxvidstatus_s NX141"CLASS="NX">pxvidstatus_s</A>
<LI><A HREF="#pxy, struct NX44"CLASS="NX">pxy, struct</A>
<LI><A HREF="#pxy, struct NX757"CLASS="NX">pxy, struct</A>
<LI><A HREF="#pxypointz_s NX50"CLASS="NX">pxypointz_s</A>
<LI><A HREF="#pxypoint_s NX46"CLASS="NX">pxypoint_s</A>
<LI><A HREF="#pxypoint_s NX759"CLASS="NX">pxypoint_s</A>
<LI><A HREF="#pxywindow, struct NX52"CLASS="NX">pxywindow, struct</A>
<LI><A HREF="#pxywindow, struct NX761"CLASS="NX">pxywindow, struct</A>
<LI><A HREF="#pxywindow_s NX53"CLASS="NX">pxywindow_s</A>
<LI><A HREF="#pxywindow_s NX762"CLASS="NX">pxywindow_s</A>
<LI><A HREF="#pxyz, struct NX48"CLASS="NX">pxyz, struct</A>
<LI><A HREF="#pxyz, struct NX764"CLASS="NX">pxyz, struct</A>
<LI><A HREF="#pxyzpoint_s NX766"CLASS="NX">pxyzpoint_s</A>
<LI><A HREF="#pxyzwindow, struct NX55"CLASS="NX">pxyzwindow, struct</A>
<LI><A HREF="#pxyzwindow, struct NX768"CLASS="NX">pxyzwindow, struct</A>
<LI><A HREF="#pxyzwindow_s NX56"CLASS="NX">pxyzwindow_s</A>
<LI><A HREF="#pxyzwindow_s NX769"CLASS="NX">pxyzwindow_s</A>
<LI><A HREF="#pxyz_s NX49"CLASS="NX">pxyz_s</A>
<LI><A HREF="#pxyz_s NX765"CLASS="NX">pxyz_s</A>
<LI><A HREF="#pxy_s NX45"CLASS="NX">pxy_s</A>
<LI><A HREF="#pxy_s NX758"CLASS="NX">pxy_s</A>
<LI><A HREF="#Read Pixel Values as Unsigned Char NX309"CLASS="NX">Read Pixel Values as Unsigned Char</A>
<LI><A HREF="#Read Pixel Values as Unsigned Char NX702"CLASS="NX">Read Pixel Values as Unsigned Char</A>
<LI><A HREF="#Read Pixel Values as Unsigned Int NX706"CLASS="NX">Read Pixel Values as Unsigned Int</A>
<LI><A HREF="#Read Pixel Values as Unsigned Short NX311"CLASS="NX">Read Pixel Values as Unsigned Short</A>
<LI><A HREF="#Read Pixel Values as Unsigned Short NX704"CLASS="NX">Read Pixel Values as Unsigned Short</A>
<LI><A HREF="#Read/Write Imaging Board Memory NX632"CLASS="NX">Read/Write Imaging Board Memory</A>
<LI><A HREF="#S/VGA Adapter NX333"CLASS="NX">S/VGA Adapter</A>
<LI><A HREF="#Save Frame Buffers as Stream NX678"CLASS="NX">Save Frame Buffers as Stream</A>
<LI><A HREF="#Save Frame Buffers NX297"CLASS="NX">Save Frame Buffers</A>
<LI><A HREF="#Save Image: BMP Format NX283"CLASS="NX">Save Image: BMP Format</A>
<LI><A HREF="#Save Image: BMP Format NX690"CLASS="NX">Save Image: BMP Format</A>
<LI><A HREF="#Save Image: PCX Format NX285"CLASS="NX">Save Image: PCX Format</A>
<LI><A HREF="#Save Image: PCX Format NX692"CLASS="NX">Save Image: PCX Format</A>
<LI><A HREF="#Save Image: TARGA Format NX287"CLASS="NX">Save Image: TARGA Format</A>
<LI><A HREF="#Save Image: TARGA Format NX694"CLASS="NX">Save Image: TARGA Format</A>
<LI><A HREF="#Save Image: TIFF Format NX289"CLASS="NX">Save Image: TIFF Format</A>
<LI><A HREF="#Save Image: TIFF Format NX696"CLASS="NX">Save Image: TIFF Format</A>
<LI><A HREF="#schar NX10"CLASS="NX">schar</A>
<LI><A HREF="#Serial Port: Read NX339"CLASS="NX">Serial Port: Read</A>
<LI><A HREF="#Serial Port: Set Configuration NX337"CLASS="NX">Serial Port: Set Configuration</A>
<LI><A HREF="#Serial Port: Write NX341"CLASS="NX">Serial Port: Write</A>
<LI><A HREF="#Set Bright White Balance NX397"CLASS="NX">Set Bright White Balance</A>
<LI><A HREF="#Set Dark White Balance NX399"CLASS="NX">Set Dark White Balance</A>
<LI><A HREF="#Set Default Configuration Copy of Video State NX614"CLASS="NX">Set Default Configuration Copy of Video State</A>
<LI><A HREF="#Set Driver Parameters NX590"CLASS="NX">Set Driver Parameters</A>
<LI><A HREF="#Set EXSYNC and PRIN Values NX367"CLASS="NX">Set EXSYNC and PRIN Values</A>
<LI><A HREF="#Set EXSYNC and PRINC Modes NX373"CLASS="NX">Set EXSYNC and PRINC Modes</A>
<LI><A HREF="#Set SV1281 Controlled Frame Rate NX500"CLASS="NX">Set SV1281 Controlled Frame Rate</A>
<LI><A HREF="#Set SV1281 Exposure, Gain, and Offset NX481"CLASS="NX">Set SV1281 Exposure, Gain, and Offset</A>
<LI><A HREF="#Set SV1281 Resolution and Timing NX490"CLASS="NX">Set SV1281 Resolution and Timing</A>
<LI><A HREF="#Set SV1281 Video And Trigger Modes NX498"CLASS="NX">Set SV1281 Video And Trigger Modes</A>
<LI><A HREF="#Set SV1310 Color Specific Gain NX449"CLASS="NX">Set SV1310 Color Specific Gain</A>
<LI><A HREF="#Set SV1310 Controlled Frame Rate NX469"CLASS="NX">Set SV1310 Controlled Frame Rate</A>
<LI><A HREF="#Set SV1310 Exposure, Gain, and Offset NX440"CLASS="NX">Set SV1310 Exposure, Gain, and Offset</A>
<LI><A HREF="#Set SV1310 Resolution and Timing NX453"CLASS="NX">Set SV1310 Resolution and Timing</A>
<LI><A HREF="#Set SV1310 Video And Trigger Modes NX467"CLASS="NX">Set SV1310 Video And Trigger Modes</A>
<LI><A HREF="#Set SV2112 Controlled Exposure And Frame Rate NX428"CLASS="NX">Set SV2112 Controlled Exposure And Frame Rate</A>
<LI><A HREF="#Set SV2112 Exposure and Gain NX407"CLASS="NX">Set SV2112 Exposure and Gain</A>
<LI><A HREF="#Set SV2112 Resolution and Timing NX414"CLASS="NX">Set SV2112 Resolution and Timing</A>
<LI><A HREF="#Set SV2112 Video And Trigger Modes NX426"CLASS="NX">Set SV2112 Video And Trigger Modes</A>
<LI><A HREF="#Set SV642 Controlled Exposure And Frame Rate NX564"CLASS="NX">Set SV642 Controlled Exposure And Frame Rate</A>
<LI><A HREF="#Set SV642 Exposure and Gain NX545"CLASS="NX">Set SV642 Exposure and Gain</A>
<LI><A HREF="#Set SV642 Resolution and Timing NX554"CLASS="NX">Set SV642 Resolution and Timing</A>
<LI><A HREF="#Set SV642 Video And Trigger Modes NX562"CLASS="NX">Set SV642 Video And Trigger Modes</A>
<LI><A HREF="#Set SV9M001/SV9T001 Controlled Exposure And Frame Rate NX535"CLASS="NX">Set SV9M001/SV9T001 Controlled Exposure And Frame Rate</A>
<LI><A HREF="#Set SV9M001/SV9T001 Exposure and Gain NX510"CLASS="NX">Set SV9M001/SV9T001 Exposure and Gain</A>
<LI><A HREF="#Set SV9M001/SV9T001 Resolution and Timing NX521"CLASS="NX">Set SV9M001/SV9T001 Resolution and Timing</A>
<LI><A HREF="#Set SV9M001/SV9T001 Video And Trigger Modes NX533"CLASS="NX">Set SV9M001/SV9T001 Video And Trigger Modes</A>
<LI><A HREF="#Set SV9T001 Exposure and Digital Gain NX512"CLASS="NX">Set SV9T001 Exposure and Digital Gain</A>
<LI><A HREF="#Set Video Configuration as per Compiled Include NX405"CLASS="NX">Set Video Configuration as per Compiled Include</A>
<LI><A HREF="#Set Video Configuration NX662"CLASS="NX">Set Video Configuration</A>
<LI><A HREF="#Set Video Contrast and Brightness NX381"CLASS="NX">Set Video Contrast and Brightness</A>
<LI><A HREF="#Set Video Hue and Saturation NX383"CLASS="NX">Set Video Hue and Saturation</A>
<LI><A HREF="#Set Video Input Multiplexer NX379"CLASS="NX">Set Video Input Multiplexer</A>
<LI><A HREF="#Sign Video State NX612"CLASS="NX">Sign Video State</A>
<LI><A HREF="#SILICON VIDEO 1281 NX737"CLASS="NX">SILICON VIDEO 1281</A>
<LI><A HREF="#SILICON VIDEO 1310 NX731"CLASS="NX">SILICON VIDEO 1310</A>
<LI><A HREF="#SILICON VIDEO 2112 NX725"CLASS="NX">SILICON VIDEO 2112</A>
<LI><A HREF="#SILICON VIDEO 642 NX751"CLASS="NX">SILICON VIDEO 642</A>
<LI><A HREF="#SILICON VIDEO 9M001 NX745"CLASS="NX">SILICON VIDEO 9M001</A>
<LI><A HREF="#SILICON VIDEO&reg; NX412"CLASS="NX">SILICON VIDEO&reg;</A>
<LI><A HREF="#SILICON VIDEO&reg; NX447"CLASS="NX">SILICON VIDEO&reg;</A>
<LI><A HREF="#SILICON VIDEO&reg; NX488"CLASS="NX">SILICON VIDEO&reg;</A>
<LI><A HREF="#SILICON VIDEO&reg; NX519"CLASS="NX">SILICON VIDEO&reg;</A>
<LI><A HREF="#SILICON VIDEO&reg; NX552"CLASS="NX">SILICON VIDEO&reg;</A>
<LI><A HREF="#sint NX11"CLASS="NX">sint</A>
<LI><A HREF="#size_t NX4"CLASS="NX">size_t</A>
<LI><A HREF="#slong NX13"CLASS="NX">slong</A>
<LI><A HREF="#sshort NX12"CLASS="NX">sshort</A>
<LI><A HREF="#Stack Overflow NX2"CLASS="NX">Stack Overflow</A>
<LI><A HREF="#Struct pxauxservice NX89"CLASS="NX">Struct pxauxservice</A>
<LI><A HREF="#Struct pxbufstatus NX92"CLASS="NX">Struct pxbufstatus</A>
<LI><A HREF="#Struct pxcamcntl NX73"CLASS="NX">Struct pxcamcntl</A>
<LI><A HREF="#Struct PXCam_SV1281State NX734"CLASS="NX">Struct PXCam_SV1281State</A>
<LI><A HREF="#Struct PXCam_SV1310State NX728"CLASS="NX">Struct PXCam_SV1310State</A>
<LI><A HREF="#Struct PXCam_SV2112State NX722"CLASS="NX">Struct PXCam_SV2112State</A>
<LI><A HREF="#Struct PXCam_SV642State NX748"CLASS="NX">Struct PXCam_SV642State</A>
<LI><A HREF="#Struct PXCam_SV9M001State NX742"CLASS="NX">Struct PXCam_SV9M001State</A>
<LI><A HREF="#Struct pxddch NX63"CLASS="NX">Struct pxddch</A>
<LI><A HREF="#Struct pxdevfault NX83"CLASS="NX">Struct pxdevfault</A>
<LI><A HREF="#Struct pxdevinfo NX77"CLASS="NX">Struct pxdevinfo</A>
<LI><A HREF="#Struct pxdevservice NX88"CLASS="NX">Struct pxdevservice</A>
<LI><A HREF="#Struct pximadrs NX803"CLASS="NX">Struct pximadrs</A>
<LI><A HREF="#Struct pximage NX57"CLASS="NX">Struct pximage</A>
<LI><A HREF="#Struct pximage NX752"CLASS="NX">Struct pximage</A>
<LI><A HREF="#Struct pximage3 NX60"CLASS="NX">Struct pximage3</A>
<LI><A HREF="#Struct pximage3buf NX85"CLASS="NX">Struct pximage3buf</A>
<LI><A HREF="#Struct pximagebuf NX84"CLASS="NX">Struct pximagebuf</A>
<LI><A HREF="#Struct pximap NX815"CLASS="NX">Struct pximap</A>
<LI><A HREF="#Struct pxtimestamp NX80"CLASS="NX">Struct pxtimestamp</A>
<LI><A HREF="#Struct pxtrigspec NX86"CLASS="NX">Struct pxtrigspec</A>
<LI><A HREF="#Struct pxviddim NX67"CLASS="NX">Struct pxviddim</A>
<LI><A HREF="#Struct pxvidformat NX65"CLASS="NX">Struct pxvidformat</A>
<LI><A HREF="#Struct pxvidimage NX66"CLASS="NX">Struct pxvidimage</A>
<LI><A HREF="#Struct pxvidmem NX72"CLASS="NX">Struct pxvidmem</A>
<LI><A HREF="#Struct pxvidmode NX70"CLASS="NX">Struct pxvidmode</A>
<LI><A HREF="#Struct pxvidopt NX71"CLASS="NX">Struct pxvidopt</A>
<LI><A HREF="#Struct pxvidphys NX69"CLASS="NX">Struct pxvidphys</A>
<LI><A HREF="#Struct pxvidres NX68"CLASS="NX">Struct pxvidres</A>
<LI><A HREF="#Struct pxvidstate NX64"CLASS="NX">Struct pxvidstate</A>
<LI><A HREF="#Struct pxvidstatus NX81"CLASS="NX">Struct pxvidstatus</A>
<LI><A HREF="#Struct pxy NX43"CLASS="NX">Struct pxy</A>
<LI><A HREF="#Struct pxy NX756"CLASS="NX">Struct pxy</A>
<LI><A HREF="#Struct pxywindow NX51"CLASS="NX">Struct pxywindow</A>
<LI><A HREF="#Struct pxywindow NX760"CLASS="NX">Struct pxywindow</A>
<LI><A HREF="#Struct pxyz NX47"CLASS="NX">Struct pxyz</A>
<LI><A HREF="#Struct pxyz NX763"CLASS="NX">Struct pxyz</A>
<LI><A HREF="#Struct pxyzwindow NX54"CLASS="NX">Struct pxyzwindow</A>
<LI><A HREF="#Struct pxyzwindow NX767"CLASS="NX">Struct pxyzwindow</A>
<LI><A HREF="#Struct xcdevinfo NX78"CLASS="NX">Struct xcdevinfo</A>
<LI><A HREF="#Struct xcdevparms NX79"CLASS="NX">Struct xcdevparms</A>
<LI><A HREF="#Struct xcdevservice NX90"CLASS="NX">Struct xcdevservice</A>
<LI><A HREF="#Struct xcdxxformat NX76"CLASS="NX">Struct xcdxxformat</A>
<LI><A HREF="#Struct xclibs NX87"CLASS="NX">Struct xclibs</A>
<LI><A HREF="#Struct xclibservice NX91"CLASS="NX">Struct xclibservice</A>
<LI><A HREF="#Struct xcsv2format NX74"CLASS="NX">Struct xcsv2format</A>
<LI><A HREF="#Struct xcsv2mode NX75"CLASS="NX">Struct xcsv2mode</A>
<LI><A HREF="#Struct xcvidstatus NX82"CLASS="NX">Struct xcvidstatus</A>
<LI><A HREF="#TARGA Format NX292"CLASS="NX">TARGA Format</A>
<LI><A HREF="#TARGA Format NX699"CLASS="NX">TARGA Format</A>
<LI><A HREF="#Terminate Live/Snap into Frame Buffer NX658"CLASS="NX">Terminate Live/Snap into Frame Buffer</A>
<LI><A HREF="#TIFF Format NX290"CLASS="NX">TIFF Format</A>
<LI><A HREF="#TIFF Format NX697"CLASS="NX">TIFF Format</A>
<LI><A HREF="#Type pxabortfunc_t NX37"CLASS="NX">Type pxabortfunc_t</A>
<LI><A HREF="#Type pxbuffer_t NX27"CLASS="NX">Type pxbuffer_t</A>
<LI><A HREF="#Type pxcoord_t NX26"CLASS="NX">Type pxcoord_t</A>
<LI><A HREF="#Type pxcoord_t NX754"CLASS="NX">Type pxcoord_t</A>
<LI><A HREF="#Type pxvbtime_t NX28"CLASS="NX">Type pxvbtime_t</A>
<LI><A HREF="#Type schar NX22"CLASS="NX">Type schar</A>
<LI><A HREF="#Type sint NX23"CLASS="NX">Type sint</A>
<LI><A HREF="#Type size_t NX5"CLASS="NX">Type size_t</A>
<LI><A HREF="#Type slong NX25"CLASS="NX">Type slong</A>
<LI><A HREF="#Type sshort NX24"CLASS="NX">Type sshort</A>
<LI><A HREF="#Type uchar NX18"CLASS="NX">Type uchar</A>
<LI><A HREF="#Type uint NX19"CLASS="NX">Type uint</A>
<LI><A HREF="#Type ulong NX21"CLASS="NX">Type ulong</A>
<LI><A HREF="#Type ushort NX20"CLASS="NX">Type ushort</A>
<LI><A HREF="#Type _cfunacc NX35"CLASS="NX">Type _cfunacc</A>
<LI><A HREF="#Type _cfunfcc NX33"CLASS="NX">Type _cfunfcc</A>
<LI><A HREF="#Type _cfunvcc NX34"CLASS="NX">Type _cfunvcc</A>
<LI><A HREF="#Type _farimap NX29"CLASS="NX">Type _farimap</A>
<LI><A HREF="#uchar NX6"CLASS="NX">uchar</A>
<LI><A HREF="#uint NX7"CLASS="NX">uint</A>
<LI><A HREF="#ulong NX9"CLASS="NX">ulong</A>
<LI><A HREF="#ushort NX8"CLASS="NX">ushort</A>
<LI><A HREF="#Video Abort NX243"CLASS="NX">Video Abort</A>
<LI><A HREF="#Video Format Configuration NX39"CLASS="NX">Video Format Configuration</A>
<LI><A HREF="#Video Format Configuration NX817"CLASS="NX">Video Format Configuration</A>
<LI><A HREF="#Video Live NX235"CLASS="NX">Video Live</A>
<LI><A HREF="#Video Live Pair Alternate NX237"CLASS="NX">Video Live Pair Alternate</A>
<LI><A HREF="#Video Live Sequence NX239"CLASS="NX">Video Live Sequence</A>
<LI><A HREF="#Video Live Sequence Trigger NX247"CLASS="NX">Video Live Sequence Trigger</A>
<LI><A HREF="#Video Live Trigger NX245"CLASS="NX">Video Live Trigger</A>
<LI><A HREF="#Video Snap and Wait NX180"CLASS="NX">Video Snap and Wait</A>
<LI><A HREF="#Video Snap NX231"CLASS="NX">Video Snap</A>
<LI><A HREF="#Video Snap Pair NX233"CLASS="NX">Video Snap Pair</A>
<LI><A HREF="#Video State ID NX40"CLASS="NX">Video State ID</A>
<LI><A HREF="#Video UnLive NX241"CLASS="NX">Video UnLive</A>
<LI><A HREF="#Windows NX193"CLASS="NX">Windows</A>
<LI><A HREF="#Windows NX324"CLASS="NX">Windows</A>
<LI><A HREF="#Windows NX329"CLASS="NX">Windows</A>
<LI><A HREF="#Windows NX332"CLASS="NX">Windows</A>
<LI><A HREF="#Windows NX719"CLASS="NX">Windows</A>
<LI><A HREF="#Windows: Create Device Independent Bitmap (DIB) NX317"CLASS="NX">Windows: Create Device Independent Bitmap (DIB)</A>
<LI><A HREF="#Windows: Direct Video Display, Done NX323"CLASS="NX">Windows: Direct Video Display, Done</A>
<LI><A HREF="#Windows: Direct Video Display, Init NX321"CLASS="NX">Windows: Direct Video Display, Init</A>
<LI><A HREF="#Windows: Direct Video Display, Start NX326"CLASS="NX">Windows: Direct Video Display, Start</A>
<LI><A HREF="#Windows: Direct Video Display, Stop NX328"CLASS="NX">Windows: Direct Video Display, Stop</A>
<LI><A HREF="#Windows: Display Image Frame Buffer On Device Context NX331"CLASS="NX">Windows: Display Image Frame Buffer On Device Context</A>
<LI><A HREF="#Windows: Display Image Frame Buffer On Device Context NX718"CLASS="NX">Windows: Display Image Frame Buffer On Device Context</A>
<LI><A HREF="#Windows: Free Device Independent Bitmap NX716"CLASS="NX">Windows: Free Device Independent Bitmap</A>
<LI><A HREF="#Windows: Make Device Independent Bitmap NX714"CLASS="NX">Windows: Make Device Independent Bitmap</A>
<LI><A HREF="#Windows: Register Event upon Captured Video Field NX186"CLASS="NX">Windows: Register Event upon Captured Video Field</A>
<LI><A HREF="#Windows: Register Event upon General Purpose Trigger NX190"CLASS="NX">Windows: Register Event upon General Purpose Trigger</A>
<LI><A HREF="#Windows: Register Event upon Video Field NX182"CLASS="NX">Windows: Register Event upon Video Field</A>
<LI><A HREF="#Windows: Release Device Independent Bitmap (DIB) NX319"CLASS="NX">Windows: Release Device Independent Bitmap (DIB)</A>
<LI><A HREF="#Windows: Unregister Event upon Captured Video Field NX188"CLASS="NX">Windows: Unregister Event upon Captured Video Field</A>
<LI><A HREF="#Windows: Unregister Event upon General Purpose Trigger NX192"CLASS="NX">Windows: Unregister Event upon General Purpose Trigger</A>
<LI><A HREF="#Windows: Unregister Event upon Video Field NX184"CLASS="NX">Windows: Unregister Event upon Video Field</A>
<LI><A HREF="#Write Pixel Values as Unsigned Char NX313"CLASS="NX">Write Pixel Values as Unsigned Char</A>
<LI><A HREF="#Write Pixel Values as Unsigned Char NX708"CLASS="NX">Write Pixel Values as Unsigned Char</A>
<LI><A HREF="#Write Pixel Values as Unsigned Int NX712"CLASS="NX">Write Pixel Values as Unsigned Int</A>
<LI><A HREF="#Write Pixel Values as Unsigned Short NX315"CLASS="NX">Write Pixel Values as Unsigned Short</A>
<LI><A HREF="#Write Pixel Values as Unsigned Short NX710"CLASS="NX">Write Pixel Values as Unsigned Short</A>
<LI><A HREF="#xcdevinfo, struct NX108"CLASS="NX">xcdevinfo, struct</A>
<LI><A HREF="#xcdevinfo_s NX138"CLASS="NX">xcdevinfo_s</A>
<LI><A HREF="#xcdevparms, struct NX109"CLASS="NX">xcdevparms, struct</A>
<LI><A HREF="#xcdevparms_s NX139"CLASS="NX">xcdevparms_s</A>
<LI><A HREF="#xcdevservice, struct NX120"CLASS="NX">xcdevservice, struct</A>
<LI><A HREF="#xcdevservice_s NX150"CLASS="NX">xcdevservice_s</A>
<LI><A HREF="#xcdxxformat, struct NX106"CLASS="NX">xcdxxformat, struct</A>
<LI><A HREF="#xcdxxformat_s NX136"CLASS="NX">xcdxxformat_s</A>
<LI><A HREF="#xclibs, struct NX117"CLASS="NX">xclibs, struct</A>
<LI><A HREF="#xclibservice, struct NX121"CLASS="NX">xclibservice, struct</A>
<LI><A HREF="#xclibservice_s NX151"CLASS="NX">xclibservice_s</A>
<LI><A HREF="#xclibs_s NX147"CLASS="NX">xclibs_s</A>
<LI><A HREF="#xclib_close NX579"CLASS="NX">xclib_close</A>
<LI><A HREF="#xclib_DeclareVidStateStructs NX615"CLASS="NX">xclib_DeclareVidStateStructs</A>
<LI><A HREF="#xclib_InitVidStateStructs NX617"CLASS="NX">xclib_InitVidStateStructs</A>
<LI><A HREF="#xclib_libincid NX573"CLASS="NX">xclib_libincid</A>
<LI><A HREF="#xclib_liblibid NX575"CLASS="NX">xclib_liblibid</A>
<LI><A HREF="#xclib_open NX577"CLASS="NX">xclib_open</A>
<LI><A HREF="#xcsv2format, struct NX104"CLASS="NX">xcsv2format, struct</A>
<LI><A HREF="#xcsv2format_s NX134"CLASS="NX">xcsv2format_s</A>
<LI><A HREF="#xcsv2mode, struct NX105"CLASS="NX">xcsv2mode, struct</A>
<LI><A HREF="#xcsv2mode_s NX135"CLASS="NX">xcsv2mode_s</A>
<LI><A HREF="#xcvidstatus, struct NX112"CLASS="NX">xcvidstatus, struct</A>
<LI><A HREF="#xcvidstatus_s NX142"CLASS="NX">xcvidstatus_s</A>
<LI><A HREF="#_cfunacc NX32"CLASS="NX">_cfunacc</A>
<LI><A HREF="#_cfunfcc NX30"CLASS="NX">_cfunfcc</A>
<LI><A HREF="#_cfunvcc NX31"CLASS="NX">_cfunvcc</A>
<LI><A HREF="#_farimap NX17"CLASS="NX">_farimap</A>
</DIV>
</BODY>
</HTML>
